<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  
    
      
    

    
  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=consolas:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="keywords" content="Java Kafka Docker JVM NIO Netty">
<meta property="og:type" content="website">
<meta property="og:title" content="Focus-1">
<meta property="og:url" content="https://carlo-z.com/page/2/index.html">
<meta property="og:site_name" content="Focus-1">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Focus-1">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://carlo-z.com/page/2/">





  <title>Focus-1</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Focus-1</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/flink/flink-sql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Focus-1">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus-1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/flink/flink-sql/" itemprop="url">深入分析Flink SQL的工作机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-11T00:00:00+08:00">
                2020-06-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flink/" itemprop="url" rel="index">
                    <span itemprop="name">flink</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <br>



<blockquote>
<p>摘要：本文整理自 Flink Forward 2020 全球在线会议中文精华版，由 Apache Flink PMC 伍翀（云邪）分享，社区志愿者陈婧敏（清樾）整理。旨在帮助大家更好地理解 Flink SQL 引擎的工作原理。文章主要分为以下四部分：</p>
<ol>
<li>Flink SQL Architecture</li>
<li>How Flink SQL Works?</li>
<li>Flink SQL Optimizations</li>
<li>Summary and Futures</li>
</ol>
<p><strong>Tips：</strong>点击下方链接可查看作者分享的原版视频～<br><a href="https://ververica.cn/developers/flink-forward-virtual-conference/" target="_blank" rel="noopener">https://ververica.cn/developers/flink-forward-virtual-conference/</a></p>
</blockquote>
<p>Apache Flink 社区在最近的两个版本（1.9 &amp; 1.10 ）中为面向未来的统一流批处理在架构层面做了很多优化，其中一个重大改造是引入了 Blink Planner，开始支持 SQL &amp; Table API 使用不同的 SQL Planner 进行编译（Planner 的插件化）。</p>
<p>本文首先会介绍推动这些优化背后的思考，展示统一的架构如何更好地处理流式和批式查询，其次将深入剖析 Flink SQL 的编译及优化过程，包括：</p>
<ol>
<li>Flink SQL 利用 Apache Calcite 将 SQL 翻译为关系代数表达式，使用表达式折叠（Expression Reduce），下推优化（Predicate / Projection Pushdown ）等优化技术生成物理执行计划（Physical Plan），利用 Codegen 技术生成高效执行代码。</li>
<li>Flink SQL 使用高效的二进制数据存储结构 BinaryRow 加速计算性能；使用 Mini-batch 攒批提高吞吐，降低两层聚合时由 Retraction 引起的数据抖动；聚合场景下数据倾斜处理和 Top-N 排序的优化原理。</li>
</ol>
<h1 id="Flink-SQL-架构-amp-Blink-Planner（1-9-）"><a href="#Flink-SQL-架构-amp-Blink-Planner（1-9-）" class="headerlink" title="Flink SQL 架构 &amp; Blink Planner（1.9+ ）"></a>Flink SQL 架构 &amp; Blink Planner（1.9+ ）</h1><h3 id="1-1-Old-Planner-的限制"><a href="#1-1-Old-Planner-的限制" class="headerlink" title="1.1 Old Planner 的限制"></a>1.1 Old Planner 的限制</h3><p>要想了解 Flink SQL 在1.9 版本引入新架构的动机，我们首先看下 1.9 版本之前的架构设计</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200611121152.gif" alt></p>
<p>从图中可以看出，虽然面向用户的 Table API &amp; SQL 是统一的，但是流式和批式任务在翻译层分别对应了 DataStreamAPI 和 DataSetAPI，在 Runtime 层面也要根据不同的 API 获取执行计划，两层的设计使得整个架构能够复用的模块有限，不易扩展。</p>
<h3 id="1-2-统一的-Blink-Planner"><a href="#1-2-统一的-Blink-Planner" class="headerlink" title="1.2 统一的 Blink Planner"></a>1.2 统一的 Blink Planner</h3><p>Flink 在设计之初就遵循“批是流的特例”的理念，在架构上做到流批统一是大势所趋。在社区和阿里巴巴的共同努力下，1.9 版本引入了新的 Blink Planner，将批 SQL 处理作为流 SQL 处理的特例，尽量对通用的处理和优化逻辑进行抽象和复用，通过 Flink 内部的 Stream Transformation API 实现流 &amp; 批的统一处理，替代原 Flink Planner 将流 &amp; 批区分处理的方式。</p>
<p>此外，新架构通过灵活的插件化方式兼容老版本 Planner，用户可自行选择。不过在 1.11 版本 Blink Planner 会代替 Old Planner 成为默认的 Planner 来支持流 &amp; 批进一步融合统一（ Old Planner 将在之后逐步退出历史舞台）。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611121414.gif" alt></p>
<br>

<br>

<h1 id="Flink-SQL-工作流"><a href="#Flink-SQL-工作流" class="headerlink" title="Flink SQL 工作流"></a>Flink SQL 工作流</h1><p> Flink SQL 引擎的工作流总结如图所示。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611121557.png" alt></p>
<p>从图中可以看出，一段查询 SQL / 使用TableAPI 编写的程序（以下简称 TableAPI 代码）从输入到编译为可执行的 JobGraph 主要经历如下几个阶段</p>
<ol>
<li>将 SQL文本 / TableAPI 代码转化为逻辑执行计划（Logical Plan）</li>
<li>Logical Plan 通过优化器优化为物理执行计划（Physical Plan）</li>
<li>通过代码生成技术生成 Transformations 后进一步编译为可执行的 JobGraph 提交运行</li>
</ol>
<p>本节将重点对 Flink SQL 优化器的常用优化方法和 CodeGen 生成 Transformations 进行介绍。</p>
<h3 id="2-1-Logical-Planning"><a href="#2-1-Logical-Planning" class="headerlink" title="2.1 Logical Planning"></a>2.1 Logical Planning</h3><p>Flink SQL 引擎使用 Apache Calcite SQL Parser 将 SQL 文本解析为词法树，SQL Validator 获取 Catalog 中元数据的信息进行语法分析和验证，转化为关系代数表达式（RelNode），再由 Optimizer 将关系代数表达式转换为初始状态的逻辑执行计划。</p>
<p>备注：TableAPI 代码使用 TableAPI Validator 对接 Catalog 后生成逻辑执行计划。</p>
<p>E.g.1 考虑如下表达 JOIN 操作的一段 SQL。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  t1.id, <span class="number">1</span> + <span class="number">2</span> + t1.value <span class="keyword">AS</span> v </span><br><span class="line"><span class="keyword">FROM</span> t1, t2 </span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">  t1.id = t2.id <span class="keyword">AND</span> </span><br><span class="line">  t2.id &lt; <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p>经过上述操作后得到了一个树状结构的逻辑执行计划，根节点对应最上层的 Select 语句，叶子节点对应输入表 t1 和 t2 的 TableScan 操作，Join 和 Where 条件过滤 分别对应了 Join 和 Filter 节点。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LogicalProject</span>(id=[$<span class="number">0</span>], v=[+(+(<span class="number">1</span>, <span class="number">2</span>), $<span class="number">1</span>)])</span><br><span class="line">+- <span class="type">LogicalFilter</span>(condition=[<span class="type">AND</span>(=($<span class="number">0</span>, $<span class="number">3</span>), &lt;($<span class="number">3</span>, <span class="number">1000</span>))])</span><br><span class="line">   +- <span class="type">LogicalJoin</span>(condition=[<span class="literal">true</span>], joinType=[inner])</span><br><span class="line">      :- <span class="type">LogicalTableScan</span>(table=[[default_catalog, <span class="keyword">default</span>, t1]])</span><br><span class="line">      +- <span class="type">LogicalTableScan</span>(table=[[default_catalog, <span class="keyword">default</span>, t2]])</span><br></pre></td></tr></table></figure>

<p>可视化后如图所示，这是优化器开始工作的初始状态。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611121906.png" alt></p>
<p>下面开始介绍 Flink SQL 优化器常见的几种优化方式。</p>
<p><strong>■ 2.1.1 Expression Reduce</strong></p>
<p>表达式（Expression） 是 SQL 中最常见的语法。比如 t1.id 是一个表达式， 1 + 2 + t1.value 也是一个表达式。优化器在优化过程中会递归遍历树上节点，尽可能预计算出每个表达式的值，这个过程就称为表达式折叠。这种转换在逻辑上等价，通过优化后，真正执行时不再需要为每一条记录都计算一遍 1 + 2。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611122001.png" alt></p>
<p><strong>■ 2.1.2 PushDown Optimization</strong></p>
<p>下推优化是指在保持关系代数语义不变的前提下将 SQL 语句中的变换操作尽可能下推到靠近数据源的位置以获得更优的性能，常见的下推优化有谓词下推（Predicate Pushdown），投影下推（Projection Pushdown，有时也译作列裁剪）等。</p>
<ul>
<li>Predicate Pushdown</li>
</ul>
<p>回顾 E.g.1，我们发现 WHERE 条件表达式中 t2.id &lt; 1000 这个过滤条件描述的是对表 t2 的约束，跟表 t1 无关，完全可以下推到 JOIN 操作之前完成。假设表 t2 中有一百万行数据，但是满足 id &lt; 1000 的数据只有 1,000 条，则通过谓词下推优化后到达 JOIN 节点的数据量降低了1,000 倍，极大地节省了 I / O 开销，提升了 JOIN 性能。</p>
<p>谓词下推（Predicate Pushdown）是优化 SQL 查询的一项基本技术，谓词一词来源于数学，指能推导出一个布尔返回值（TRUE / FALSE）的函数或表达式，通过判断布尔值可以进行数据过滤。谓词下推是指保持关系代数语义不变的前提下将 Filter 尽可能移至靠近数据源的位置（比如读取数据的 SCAN 阶段）来降低查询和传递的数据量（记录数）。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611122053.png" alt></p>
<ul>
<li>Projection Pushdown</li>
</ul>
<p>列裁剪是 Projection Pushdown 更直观的描述方式，指在优化过程中去掉没有使用的列来降低 I / O 开销，提升性能。但与谓词下推只移动节点位置不同，投影下推可能会增加节点个数。比如最后计算出的投影组合应该放在 TableScan 操作之上，而 TableScan 节点之上没有 Projection 节点，优化器就会显式地新增 Projection 节点来完成优化。另外如果输入表是基于列式存储的（如 Parquet 或 ORC 等），优化还会继续下推到 Scan 操作中进行。</p>
<p>回顾 E.g.1，我们发现整个查询中只用到了表 t1 的 id 和 value 字段，表 t2 的 id 字段，在 TableScan 节点之上分别增加 Projection 节点去掉多余字段，极大地节省了 I / O 开销</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611122150.png" alt></p>
<p>简要总结一下，谓词下推和投影下推分别通过避免处理不必要的记录数和字段数来降低 I / O 开销提升性能。</p>
<h3 id="2-2-Physical-Planning-on-Batch"><a href="#2-2-Physical-Planning-on-Batch" class="headerlink" title="2.2 Physical Planning on Batch"></a>2.2 Physical Planning on Batch</h3><p>通过上述一系列操作后，我们得到了优化后的逻辑执行计划。逻辑执行计划描述了执行步骤和每一步需要完成的操作，但没有描述操作的具体实现方式。而物理执行计划会考虑物理实现的特性，生成每一个操作的具体实现方式。比如 Join 是使用 SortMergeJoin、HashJoin 或 BroadcastHashJoin 等。优化器在生成逻辑执行计划时会计算整棵树上每一个节点的 Cost，对于有多种实现方式的节点（比如 Join 节点），优化器会展开所有可能的 Join 方式分别计算。最终整条路径上 Cost 最小的实现方式就被选中成为 Final Physical Plan。</p>
<p>回顾 E.g.1，当它以批模式执行，同时我们可以拿到输入表的 Statistics 信息。在经过前述优化后，表 t2 到达 Join 节点时只有 1,000 条数据，使用 BroadcastJoin 的开销相对最低，则最终的 Physical Plan 如下图所示。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611122251.png" alt></p>
<h3 id="2-3-Translation-amp-Code-Generation"><a href="#2-3-Translation-amp-Code-Generation" class="headerlink" title="2.3 Translation &amp; Code Generation"></a>2.3 Translation &amp; Code Generation</h3><p>代码生成（Code Generation） 在计算机领域是一种广泛使用的技术。在 Physical Plan 到生成 Transformation Tree 过程中就使用了 Code Generation。</p>
<p>回顾 E.g.1，以 表 t2 之上的 Calc 节点 t2.id &lt; 1000 表达式为例，通过 Code Generation 后生成了描述 Transformation Operator 的一段 Java 代码，将接收到的 Row 中 id &lt; 1000 的 Row 发送到下一个 Operator。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611122339.png" alt></p>
<p>Flink SQL 引擎会将 Physical Plan 通过 Code Generation 翻译为 Transformations，再进一步编译为可执行的 JobGraph。</p>
<h3 id="2-4-Physical-Planning-on-Stream"><a href="#2-4-Physical-Planning-on-Stream" class="headerlink" title="2.4 Physical Planning on Stream"></a>2.4 Physical Planning on Stream</h3><p>以上介绍了 Flink SQL 引擎的整体工作流，上述例子是假定以批模式编译的，下面我们来介绍一下以流模式编译时，在生成 Physical Plan 过程中的一个重要机制：Retraction Mechanism （aka. Changelog Mechanism）。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611122438.png" alt></p>
<p>■ <strong>2.4.1 Retraction Mechanism</strong></p>
<p>Retraction 是流式数据处理中撤回过早下发（Early Firing）数据的一种机制，类似于传统数据库的 Update 操作。级联的聚合等复杂 SQL 中如果没有 Retraction 机制，就会导致最终的计算结果与批处理不同，这也是目前业界很多流计算引擎的缺陷。</p>
<p>E.g.2 考虑如下统计词频分布的 SQL。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT cnt, COUNT(cnt) as freq</span><br><span class="line">FROM (</span><br><span class="line">  SELECT word, COUNT(*) as cnt</span><br><span class="line">  FROM words</span><br><span class="line">  GROUP BY word)</span><br><span class="line">GROUP BY cnt</span><br></pre></td></tr></table></figure>

<p> 假设输入数据是：</p>
<table>
<thead>
<tr>
<th><strong>word</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Hello</td>
</tr>
<tr>
<td>World</td>
</tr>
<tr>
<td>Hello</td>
</tr>
</tbody></table>
<p>则经过上面的计算后，预期的输出结果应该是：</p>
<table>
<thead>
<tr>
<th><strong>cnt</strong></th>
<th><strong>freq</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
</tr>
</tbody></table>
<p>但与批处理不同，流处理的数据是一条条到达的，理论上每一条数据都会触发一次计算，所以在处理了第一个 Hello 和第一个 World 之后，词频为 1 的单词数已经变成了 2，此时再处理第二个 Hello 时，如果不能修正之前的结果，Hello 就会在词频等于 1 和词频等于 2 这两个窗口下被同时统计，显然这个结果是错误的，这就是没有 Retraction 机制带来的问题。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611122614.gif" alt></p>
<p>Flink SQL 在流计算领域中的一个重大贡献就是首次提出了这个机制的具体实现方案。Retraction 机制又名 Changelog 机制，因为某种程度上 Flink 将输入的流数据看作是数据库的 Changelog，每条输入数据都可以看作是对数据库的一次变更操作，比如 Insert，Delete 或者 Update。以 MySQL 数据库为例，其Binlog 信息以二进制形式存储，其中 Update_rows_log_event 会对应 2 条标记 Before Image （BI） 和 After Image （AI），分别表示某一行在更新前后的信息。</p>
<p>在 Flink SQL 优化器生成流作业的 Physical Plan 时会判断当前节点是否是更新操作，如果是则会同时发出 2 条消息 update_before 和 update_after 到下游节点，update_before 表示之前“错误”下发的数据，需要被撤回，update_after 表示当前下发的“正确”数据。下游收到后，会在结果上先减去 update_before，再加上 update_after。</p>
<p>回顾 E.g.2，下面的动图演示了加入 Retraction 机制后正确结果的计算过程。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611122658.gif" alt></p>
<p>update_before 是一条非常关键的信息，相当于标记出了导致当前结果不正确的那个“元凶”。不过额外操作会带来额外的开销，有些情况下不需要发送 update_before 也可以获得正确的结果，比如下游节点接的是 UpsertSink（MySQL 或者 HBase的情况下，数据库可以按主键用 update_after 消息覆盖结果）。是否发送 update_before 由优化器决定，用户不需要关心。</p>
<p>■ <strong>2.4.2 Update_before Decision</strong></p>
<p>前面介绍了 Retraction 机制和 update_before，那优化器是怎样决定是否需要发送update_before 呢？本节将介绍这一部分的工作。</p>
<p><strong>Step1：确定每个节点对应的 Changelog 变更类型</strong></p>
<p>数据库中最常见的三种操作类型分别是 Insert （记为 [I]），Delete（记为 [D]），Update（记为 [U]）。优化器首先会自底向上检查每个节点，判断它属于哪（几）种类型，分别打上对应标记。</p>
<p>回顾 E.g.2，第一个 Source 节点由于只产生新数据，所以属于 Insert，记为 [I]；第二个节点计算内层的聚合，所以会发出更新的消息，记为 [I，U]；第三个节点裁掉 word 字段，属于简单计算，传递了上游的变更类型，记为 [I，U]；第四个节点是外层的聚合计算，由于它收到了来自上游的 Update 消息，所以额外需要 Delete 操作来保证更新成功，记为 [I，U，D]。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611122745.gif" alt></p>
<p><strong>Step2：确定每个节点发送的消息类型</strong></p>
<p>在介绍 Step2 之前，我们先介绍下 Flink 中 Update 消息类型的表示形式。在 Flink 中 Update 由两条 update_before（简称 UB）和 update_after （简称 UA）来表示，其中 UB 消息在某些情况下可以不发送，从而提高性能。</p>
<p>在 Step1 中优化器自底向上推导出了每个节点对应的 Changelog 变更操作，这一步里会先自顶向下推断当前节点需要父节点提供的消息类型，直到遇到第一个不需要父节点提供任何消息类型的节点，再往上回推每个节点最终的实现方式和需要的消息类型。</p>
<p>回顾 E.g.2，由于最上层节点是 UpsertSink 节点，只需要它的父节点提供 [UA] 即可。到了外层聚合的 Aggregate 节点，由于 Aggregate 节点的输入有 Update 操作，所以需要父节点需要提供 [UB，UA]，这样才能正确更新自己的计算状态。</p>
<p>再往下到 Calc 节点，它需要传递 [UB，UA] 的需求给它的父节点，也就是内层的 Aggregate 节点。而到了内层 Aggregation 节点，它的父节点是 Source 节点，不会产生 Update 操作，所以它不需要 Source 节点额外发送任何 [UB / UA ]。当优化器遍历到 Source 节点，便开始进行回溯，如果当前节点能满足子节点的 requirement，则将对应的标签更新到节点上，否则便无法生成 plan。首先内层的 Aggregate 能产生 UB，所以能满足子节点的 requirement，所以优化器会给内层的 Aggregate 节点打上 [UB，UA] 的标签，然后向上传递到 Calc 节点，同样打上 [UB，UA] ，再到外层的 Aggregate 节点，由于它的下游只需要接受更新后的消息，所以打上 [UA] 标签，表示它只需要向下游发送 update_after 即可。</p>
<p>这些标签最终会影响算子的物理实现，比如外层的 Aggregate 节点，由于它会接收到来自上游的 [UB]，所以物理实现会使用带 Retract 的 Count，同时它只会向 Sink 发送 update_after。而内层的 Aggregate 节点，由于上游发送过来的数据没有 [UB]，所以可以采用不带 Retract 的 Count 实现，同时由于带有 [UB] 标签，所以需要往下游发送 update_before。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611122835.gif" alt></p>
<br>

<br>

<h1 id="Flink-SQL-Internal-Optimization"><a href="#Flink-SQL-Internal-Optimization" class="headerlink" title="Flink SQL Internal Optimization"></a>Flink SQL Internal Optimization</h1><p>前面介绍了 Flink SQL 引擎的工作原理，接下来会简要概括一下 Flink SQL 内部的一些优化，更多资料可以在 Flink Forward Asia 2019 查看。</p>
<h3 id="3-1-BinaryRow"><a href="#3-1-BinaryRow" class="headerlink" title="3.1 BinaryRow"></a>3.1 BinaryRow</h3><p>在 Flink 1.9+ 前， Flink Runtime 层各算子间传递的数据结构是 Row，其内部实现是 Object[]。这种数据结构的问题在于不但需要额外开销存 Object Metadata，计算过程中还涉及到大量序列化 / 反序列 （特别是只需要处理某几个字段时需要反序列化整个 Row），primitive 类型的拆 / 装箱等，都会带来大量额外的性能开销。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611122929.png" alt></p>
<p>Flink 1.9 开始引入了 Blink Planner，使用二进制数据结构的 BinaryRow 来表示 Record。BinaryRow 作用于默认大小为 32K 的 Memory Segment，直接映射到内存。BinaryRow 内部分为 Header，定长区和变长区。Header 用于存储 Retraction 消息的标识，定长区使用 8 个 bytes 来记录字段的 Nullable 信息及所有 primitive 和可以在 8 个 bytes 内表示的类型。其它类型会按照基于起始位置的 offset 存放在变长区。</p>
<p>BinaryRow 作为 Blink Planner 的基础数据结构，带来的好处是显而易见的：首先存储上更为紧凑，去掉了额外开销；其次在序列化和反序列化上带来的显著性能提升，可根据 offset 只反序列化需要的字段，在开启 Object Reuse 后，序列化可以直接通过内存拷贝完成。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611122950.png" alt></p>
<h3 id="3-2-Mini-batch-Processing"><a href="#3-2-Mini-batch-Processing" class="headerlink" title="3.2 Mini-batch Processing"></a>3.2 Mini-batch Processing</h3><p>Flink 是纯流式处理框架，在理论上每一条新到的数据都会触发一次计算。然而在实现层面，这样做会导致聚合场景下每处理一条数据都需要读写 State 及序列化 / 反序列化。如果能够在内存中 buffer 一定量的数据，预先做一次聚合后再更新 State，则不但会降低操作 State 的开销，还会有效减少发送到下游的数据量，提升 throughput，降低两层聚合时由 Retraction 引起的数据抖动, 这就是 Mini-batch 攒批优化的核心思想。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611123052.gif" alt></p>
<h3 id="3-3-Skew-Processing"><a href="#3-3-Skew-Processing" class="headerlink" title="3.3 Skew Processing"></a>3.3 Skew Processing</h3><p>对于数据倾斜的优化，主要分为是否带 DISTINCT 去重语义的两种方式。对于普通聚合的数据倾斜，Flink 引入了 Local-Global 两阶段优化，类似于 MapReduce 增加 Local Combiner 的处理模式。而对于带有去重的聚合，Flink 则会将用户的 SQL 按原有聚合的 key 组合再加上 DISTINCT key 做 Hash 取模后改写为两层聚合来进行打散。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611123127.gif" alt></p>
<h3 id="3-4-Top-N-Rewrite"><a href="#3-4-Top-N-Rewrite" class="headerlink" title="3.4 Top-N Rewrite"></a>3.4 Top-N Rewrite</h3><p>全局排序在流式的场景是很难实现的，但如果只需要计算到目前的 Top-N 极值，问题就变得可解。不过传统数据库求排序的 SQL 语法是通过 ORDER BY 加 LIMIT 限制条数，背后实现的机制也是通过扫描全表排序后再返回 LIMIT 条数的记录。另外如果按照某些字段开窗排序，ORDER BY 也无法满足要求。Flink SQL 借鉴了批场景下开窗求 Top-N 的语法，使用 ROW_NUMBER 语法来做流场景下的 Top-N 排序。</p>
<p>E.g.3 下面这段 SQL 计算了每个类目下销量 Top3 的店铺</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>*</span><br><span class="line"><span class="keyword">FROM</span>(</span><br><span class="line">  <span class="keyword">SELECT</span> *, <span class="comment">-- you can get like shopId or other information from this</span></span><br><span class="line">    ROW_NUMBER() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">category</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> sales <span class="keyword">DESC</span>) <span class="keyword">AS</span> <span class="keyword">rowNum</span></span><br><span class="line">  <span class="keyword">FROM</span> shop_sales ) </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">rowNum</span> &lt;= <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611123233.png" alt></p>
<p>在生成 Plan 方面，ROW_NUMBER 语义对应 OverAggregate 窗口节点和一个过滤行数的 Calc 节点，而这个窗口节点在实现层面需要为每一个到达的数据重新将 State 中的历史数据拿出来排序，这显然不是最优解。</p>
<p>我们知道流式场景求解极大 / 小值的最优操作是通过维护一个 size 为 N 的 minHeap / maxHeap。由实现反推出我们需要在优化器上新增一条规则，在遇到 ROW_NUMBER 生成的逻辑节点后，将其优化为一个特殊的 Rank 节点，对应上述的最优实现方式（当然这只是特殊 Rank 对应的其中一种实现）。这便是 Top-N Rewrite 的核心思想。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611123313.gif" alt></p>
<br>

<br>

<h1 id="Summary-amp-Futures"><a href="#Summary-amp-Futures" class="headerlink" title="Summary &amp; Futures"></a>Summary &amp; Futures</h1><p><strong>本文内容回顾</strong></p>
<ol>
<li><p>简要介绍 Flink 1.9 + 在 SQL &amp; TableAPI 上引入新架构，统一技术栈，朝着流 &amp; 批一体的方向迈进了一大步。</p>
</li>
<li><p>深入介绍 Flink SQL 引擎的内部运行机制，以及在对用户透明的同时，Flink SQL 在优化方面做的许多工作。</p>
</li>
</ol>
<p><strong>未来工作计划</strong></p>
<ol>
<li>在 Flink 1.11+ 后的版本，Blink Planner 将作为默认的 Planner 提供生产级别的支持。</li>
<li>FLIP-95：重构 TableSource &amp; TableSink 的接口设计，面向流批一体化，在 Source 端支持 changelog 消息流，从而支持 FLIP-105 的 CDC 数据源。</li>
<li>FLIP-105：Flink TableAPI &amp; SQL 对 CDC 的支持。</li>
<li>FLIP-115：扩展目前只支持 CSV 的 FileSystem Connector，使其成为流批统一的 Generalized FileSystem Connector。</li>
<li>FLIP-123：对 Hive DDL 和 DML 的兼容，支持用户在 Flink 中运行 Hive DDL。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/micro-service/istio/istio-doc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Focus-1">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus-1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/micro-service/istio/istio-doc/" itemprop="url">Istio 介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-05T21:17:51+08:00">
                2020-06-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <br>

<blockquote>
<p>官方文档：<a href="https://istio.io/zh/docs/" target="_blank" rel="noopener">https://istio.io/zh/docs/</a></p>
</blockquote>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="Istio-是什么？"><a href="#Istio-是什么？" class="headerlink" title="Istio 是什么？"></a>Istio 是什么？</h2><p>云平台令使用它们的公司受益匪浅。但不可否认的是，上云会给 DevOps 团队带来压力。为了可移植性，开发人员必须使用微服务来构建应用，同时运维人员也正在管理着极端庞大的混合云和多云的部署环境。 Istio 允许您连接、保护、控制和观察服务。</p>
<p>从较高的层面来说，Istio 有助于降低这些部署的复杂性，并减轻开发团队的压力。它是一个完全开源的服务网格，作为透明的一层接入到现有的分布式应用程序里。它也是一个平台，拥有可以集成任何日志、遥测和策略系统的 API 接口。Istio 多样化的特性使您能够成功且高效地运行分布式微服务架构，并提供保护、连接和监控微服务的统一方法。</p>
<h2 id="服务网格是什么？"><a href="#服务网格是什么？" class="headerlink" title="服务网格是什么？"></a>服务网格是什么？</h2><p>Istio 解决了开发人员和运维人员所面临的从单体应用向分布式微服务架构转变的挑战。了解它是如何做到这一点的可以让我们更详细地理解 Istio 的服务网格。</p>
<p>术语<strong>服务网格</strong>用来描述组成这些应用程序的微服务网络以及它们之间的交互。随着服务网格的规模和复杂性不断的增长，它将会变得越来越难以理解和管理。它的需求包括服务发现、负载均衡、故障恢复、度量和监控等。服务网格通常还有更复杂的运维需求，比如 A/B 测试、金丝雀发布、速率限制、访问控制和端到端认证。</p>
<p>Istio 提供了对整个服务网格的行为洞察和操作控制的能力，以及一个完整的满足微服务应用各种需求的解决方案。</p>
<h2 id="为什么使用-Istio？"><a href="#为什么使用-Istio？" class="headerlink" title="为什么使用 Istio？"></a>为什么使用 Istio？</h2><p>通过负载均衡、服务间的身份验证、监控等方法，Istio 可以轻松地创建一个已经部署了服务的网络，而服务的代码只需<a href="https://istio.io/zh/docs/tasks/observability/distributed-tracing/overview/#trace-context-propagation" target="_blank" rel="noopener">很少</a>更改甚至无需更改。通过在整个环境中部署一个特殊的 sidecar 代理为服务添加 Istio 的支持，而代理会拦截微服务之间的所有网络通信，然后使用其控制平面的功能来配置和管理 Istio，这包括：</p>
<ul>
<li>为 HTTP、gRPC、WebSocket 和 TCP 流量自动负载均衡。</li>
<li>通过丰富的路由规则、重试、故障转移和故障注入对流量行为进行细粒度控制。</li>
<li>可插拔的策略层和配置 API，支持访问控制、速率限制和配额。</li>
<li>集群内（包括集群的入口和出口）所有流量的自动化度量、日志记录和追踪。</li>
<li>在具有强大的基于身份验证和授权的集群中实现安全的服务间通信。</li>
</ul>
<p>Istio 为可扩展性而设计，可以满足不同的部署需求。</p>
<h2 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h2><p>Istio 以统一的方式提供了许多跨服务网络的关键功能：</p>
<h3 id="流量管理"><a href="#流量管理" class="headerlink" title="流量管理"></a>流量管理</h3><p>Istio 简单的规则配置和流量路由允许您控制服务之间的流量和 API 调用过程。Istio 简化了服务级属性（如熔断器、超时和重试）的配置，并且让它轻而易举的执行重要的任务（如 A/B 测试、金丝雀发布和按流量百分比划分的分阶段发布）。</p>
<p>有了更好的对流量的可视性和开箱即用的故障恢复特性，您就可以在问题产生之前捕获它们，无论面对什么情况都可以使调用更可靠，网络更健壮。</p>
<p>请参考<a href="https://istio.io/zh/docs/concepts/traffic-management/" target="_blank" rel="noopener">流量管理文档</a>获取更多细节。</p>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>Istio 的安全特性解放了开发人员，使其只需要专注于应用程序级别的安全。Istio 提供了底层的安全通信通道，并为大规模的服务通信管理认证、授权和加密。有了 Istio，服务通信在默认情况下就是受保护的，可以让您在跨不同协议和运行时的情况下实施一致的策略——而所有这些都只需要很少甚至不需要修改应用程序。</p>
<p>Istio 是独立于平台的，可以与 Kubernetes（或基础设施）的网络策略一起使用。但它更强大，能够在网络和应用层面保护pod到 pod 或者服务到服务之间的通信。</p>
<p>请参考<a href="https://istio.io/zh/docs/concepts/security/" target="_blank" rel="noopener">安全文档</a>获取更多细节。</p>
<h3 id="可观察性"><a href="#可观察性" class="headerlink" title="可观察性"></a>可观察性</h3><p>Istio 健壮的追踪、监控和日志特性让您能够深入的了解服务网格部署。通过 Istio 的监控能力，可以真正的了解到服务的性能是如何影响上游和下游的；而它的定制 Dashboard 提供了对所有服务性能的可视化能力，并让您看到它如何影响其他进程。</p>
<p>Istio 的 Mixer 组件负责策略控制和遥测数据收集。它提供了后端抽象和中介，将一部分 Istio 与后端的基础设施实现细节隔离开来，并为运维人员提供了对网格与后端基础实施之间交互的细粒度控制。</p>
<p>所有这些特性都使您能够更有效地设置、监控和加强服务的 SLO。当然，底线是您可以快速有效地检测到并修复出现的问题。</p>
<p>请参考<a href="https://istio.io/zh/docs/concepts/observability/" target="_blank" rel="noopener">可观察性文档</a>获取更多细节。</p>
<h2 id="平台支持"><a href="#平台支持" class="headerlink" title="平台支持"></a>平台支持</h2><p>Istio 独立于平台，被设计为可以在各种环境中运行，包括跨云、内部环境、Kubernetes、Mesos 等等。您可以在 Kubernetes 或是装有 Consul 的 Nomad 环境上部署 Istio。Istio 目前支持：</p>
<ul>
<li>Kubernetes 上的服务部署</li>
<li>基于 Consul 的服务注册</li>
<li>服务运行在独立的虚拟机上</li>
</ul>
<h2 id="整合和定制"><a href="#整合和定制" class="headerlink" title="整合和定制"></a>整合和定制</h2><p>Istio 的策略实施组件可以扩展和定制，与现有的 ACL、日志、监控、配额、审查等解决方案集成。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>要开始使用 Istio，只需遵循以下三个步骤：</p>
<ol>
<li><a href="https://istio.io/zh/docs/setup/getting-started/#platform" target="_blank" rel="noopener">搭建平台</a></li>
<li><a href="https://istio.io/zh/docs/setup/getting-started/#download" target="_blank" rel="noopener">下载 Istio</a></li>
<li><a href="https://istio.io/zh/docs/setup/getting-started/#install" target="_blank" rel="noopener">安装 Istio</a></li>
</ol>
<h2 id="搭建平台"><a href="#搭建平台" class="headerlink" title="搭建平台"></a>搭建平台</h2><p>在安装 Istio 之前，需要一个运行着 Kubernetes 的兼容版本的 cluster。</p>
<p>Istio 1.6 已经在 Kubernetes 版本 1.15, 1.16, 1.17, 1.18 中测试过。</p>
<ul>
<li>通过选择合适的 <a href="https://istio.io/zh/docs/setup/platform-setup/" target="_blank" rel="noopener">platform-specific setup instructions</a> 来创建一个集群。</li>
</ul>
<p>有些平台提供了 managed control plane，您可以使用它来代替手动安装 Istio。如果您选择的平台支持这种方式，并且您选择使用它，那么，在创建完集群后，您将完成 Istio 的安装。因此，可以跳过以下说明。</p>
<h2 id="下载-Istio"><a href="#下载-Istio" class="headerlink" title="下载 Istio"></a>下载 Istio</h2><p>下载 Istio，下载内容将包含：安装文件、示例和 <a href="https://istio.io/zh/docs/reference/commands/istioctl/" target="_blank" rel="noopener">istioctl</a> 命令行工具。</p>
<ol>
<li><p>访问 <a href="https://github.com/istio/istio/releases/tag/1.6.0" target="_blank" rel="noopener">Istio release</a> 页面下载与您操作系统对应的安装文件。在 macOS 或 Linux 系统中，也可以通过以下命令下载最新版本的 Istio：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L https://istio.io/downloadIstio | sh -</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>切换到 Istio 包所在目录下。例如：Istio 包名为 <code>istio-1.6.0</code>，则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd istio-1.6.0</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>   安装目录包含如下内容：</p>
<ul>
<li><code>install/kubernetes</code> 目录下，有 Kubernetes 相关的 YAML 安装文件</li>
<li><code>samples/</code> 目录下，有示例应用程序</li>
<li><code>bin/</code> 目录下，包含 <a href="https://istio.io/zh/docs/reference/commands/istioctl" target="_blank" rel="noopener"><code>istioctl</code></a> 的客户端文件。<code>istioctl</code> 工具用于手动注入 Envoy sidecar 代理。</li>
</ul>
<ol start="3">
<li><p>将 <code>istioctl</code> 客户端路径增加到 path 环境变量中，macOS 或 Linux 系统的增加方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export PATH=$PWD/bin:$PATH</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li>在使用 bash 或 ZSH 控制台时，可以选择启动 <a href="https://istio.io/zh/docs/ops/diagnostic-tools/istioctl#enabling-auto-completion" target="_blank" rel="noopener">auto-completion option</a>。</li>
</ol>
<h2 id="安装-Istio"><a href="#安装-Istio" class="headerlink" title="安装 Istio"></a>安装 Istio</h2><p>请按照以下步骤在您所选的平台上使用 <code>demo</code> 配置文件安装 Istio。</p>
<ol>
<li><p>安装 <code>demo</code> 配置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> istioctl manifest apply --<span class="built_in">set</span> profile=demo</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>为了验证是否安装成功，需要先确保以下 Kubernetes 服务正确部署，然后验证除 <code>jaeger-agent</code> 服务外的其他服务，是否均有正确的 <code>CLUSTER-IP</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get svc -n istio-system</span></span><br><span class="line">NAME                     TYPE           CLUSTER-IP       EXTERNAL-IP     PORT(S)                                                                                                                                      AGE</span><br><span class="line">grafana                  ClusterIP      172.21.211.123   &lt;none&gt;          3000/TCP                                                                                                                                     2m</span><br><span class="line">istio-citadel            ClusterIP      172.21.177.222   &lt;none&gt;          8060/TCP,15014/TCP                                                                                                                           2m</span><br><span class="line">istio-egressgateway      ClusterIP      172.21.113.24    &lt;none&gt;          80/TCP,443/TCP,15443/TCP                                                                                                                     2m</span><br><span class="line">istio-galley             ClusterIP      172.21.132.247   &lt;none&gt;          443/TCP,15014/TCP,9901/TCP                                                                                                                   2m</span><br><span class="line">istio-ingressgateway     LoadBalancer   172.21.144.254   52.116.22.242   15020:31831/TCP,80:31380/TCP,443:31390/TCP,31400:31400/TCP,15029:30318/TCP,15030:32645/TCP,15031:31933/TCP,15032:31188/TCP,15443:30838/TCP   2m</span><br><span class="line">istio-pilot              ClusterIP      172.21.105.205   &lt;none&gt;          15010/TCP,15011/TCP,8080/TCP,15014/TCP                                                                                                       2m</span><br><span class="line">istio-policy             ClusterIP      172.21.14.236    &lt;none&gt;          9091/TCP,15004/TCP,15014/TCP                                                                                                                 2m</span><br><span class="line">istio-sidecar-injector   ClusterIP      172.21.155.47    &lt;none&gt;          443/TCP,15014/TCP                                                                                                                            2m</span><br><span class="line">istio-telemetry          ClusterIP      172.21.196.79    &lt;none&gt;          9091/TCP,15004/TCP,15014/TCP,42422/TCP                                                                                                       2m</span><br><span class="line">jaeger-agent             ClusterIP      None             &lt;none&gt;          5775/UDP,6831/UDP,6832/UDP                                                                                                                   2m</span><br><span class="line">jaeger-collector         ClusterIP      172.21.135.51    &lt;none&gt;          14267/TCP,14268/TCP                                                                                                                          2m</span><br><span class="line">jaeger-query             ClusterIP      172.21.26.187    &lt;none&gt;          16686/TCP                                                                                                                                    2m</span><br><span class="line">kiali                    ClusterIP      172.21.155.201   &lt;none&gt;          20001/TCP                                                                                                                                    2m</span><br><span class="line">prometheus               ClusterIP      172.21.63.159    &lt;none&gt;          9090/TCP                                                                                                                                     2m</span><br><span class="line">tracing                  ClusterIP      172.21.2.245     &lt;none&gt;          80/TCP                                                                                                                                       2m</span><br><span class="line">zipkin                   ClusterIP      172.21.182.245   &lt;none&gt;          9411/TCP                                                                                                                                     2m</span><br></pre></td></tr></table></figure>





</li>
</ol>
<p>   如果集群运行在一个不支持外部负载均衡器的环境中（例如：minikube），<code>istio-ingressgateway</code> 的 <code>EXTERNAL-IP</code> 将显示为 `` 状态。请使用服务的 <code>NodePort</code> 或 端口转发来访问网关。</p>
<p>   请确保关联的 Kubernetes pod 已经部署，并且 <code>STATUS</code> 为 <code>Running</code>：</p>
   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -n istio-system</span></span><br><span class="line">NAME                                                           READY   STATUS      RESTARTS   AGE</span><br><span class="line">grafana-f8467cc6-rbjlg                                         1/1     Running     0          1m</span><br><span class="line">istio-citadel-78df5b548f-g5cpw                                 1/1     Running     0          1m</span><br><span class="line">istio-egressgateway-78569df5c4-zwtb5                           1/1     Running     0          1m</span><br><span class="line">istio-galley-74d5f764fc-q7nrk                                  1/1     Running     0          1m</span><br><span class="line">istio-ingressgateway-7ddcfd665c-dmtqz                          1/1     Running     0          1m</span><br><span class="line">istio-pilot-f479bbf5c-qwr28                                    1/1     Running     0          1m</span><br><span class="line">istio-policy-6fccc5c868-xhblv                                  1/1     Running     2          1m</span><br><span class="line">istio-sidecar-injector-78499d85b8-x44m6                        1/1     Running     0          1m</span><br><span class="line">istio-telemetry-78b96c6cb6-ldm9q                               1/1     Running     2          1m</span><br><span class="line">istio-tracing-69b5f778b7-s2zvw                                 1/1     Running     0          1m</span><br><span class="line">kiali-99f7467dc-6rvwp                                          1/1     Running     0          1m</span><br><span class="line">prometheus-67cdb66cbb-9w2hm                                    1/1     Running     0          1m</span><br></pre></td></tr></table></figure>



<h2 id="后续步骤"><a href="#后续步骤" class="headerlink" title="后续步骤"></a>后续步骤</h2><p>安装 Istio 后，就可以部署您自己的服务，或部署安装程序中系统的任意一个示例应用。</p>
<p>应用程序必须使用 HTTP/1.1 或 HTTP/2.0 协议用于 HTTP 通信；HTTP/1.0 不支持。</p>
<p>当使用 <code>kubectl apply</code> 来部署应用时，如果 pod 启动在标有 <code>istio-injection=enabled</code> 的命名空间中，那么，<a href="https://istio.io/zh/docs/setup/additional-setup/sidecar-injection/#automatic-sidecar-injection" target="_blank" rel="noopener">Istio sidecar 注入器</a>将自动注入 Envoy 容器到应用的 pod 中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl label namespace &lt;namespace&gt; istio-injection=enabled</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl create -n &lt;namespace&gt; -f &lt;your-app-spec&gt;.yaml</span></span><br></pre></td></tr></table></figure>

<p>在没有 <code>istio-injection</code> 标记的命名空间中，在部署前可以使用 <a href="https://istio.io/zh/docs/reference/commands/istioctl/#istioctl-kube-inject" target="_blank" rel="noopener"><code>istioctl kube-inject</code></a> 命令将 Envoy 容器手动注入到应用的 pod 中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> istioctl kube-inject -f &lt;your-app-spec&gt;.yaml | kubectl apply -f -</span></span><br></pre></td></tr></table></figure>

<p>如果您不确定要从哪开始，可以先<a href="https://istio.io/zh/docs/examples/bookinfo/" target="_blank" rel="noopener">部署 Bookinfo 示例</a>，它会让您体验到 Istio 的流量路由、故障注入、速率限制等功能。 然后您可以根据您的兴趣浏览各种各样的 <a href="https://istio.io/zh/docs/tasks/" target="_blank" rel="noopener">Istio 任务</a>。</p>
<p>下列任务都是初学者开始学习的好入口：</p>
<ul>
<li><a href="https://istio.io/zh/docs/tasks/traffic-management/request-routing/" target="_blank" rel="noopener">请求路由</a></li>
<li><a href="https://istio.io/zh/docs/tasks/traffic-management/fault-injection/" target="_blank" rel="noopener">故障注入</a></li>
<li><a href="https://istio.io/zh/docs/tasks/traffic-management/traffic-shifting/" target="_blank" rel="noopener">流量转移</a></li>
<li><a href="https://istio.io/zh/docs/tasks/observability/metrics/querying-metrics/" target="_blank" rel="noopener">查询指标</a></li>
<li><a href="https://istio.io/zh/docs/tasks/observability/metrics/using-istio-dashboard/" target="_blank" rel="noopener">可视化指标</a></li>
<li><a href="https://istio.io/zh/docs/tasks/observability/logs/collecting-logs/" target="_blank" rel="noopener">日志收集</a></li>
<li><a href="https://istio.io/zh/docs/tasks/policy-enforcement/rate-limiting/" target="_blank" rel="noopener">速率限制</a></li>
<li><a href="https://istio.io/zh/docs/tasks/traffic-management/ingress/ingress-control/" target="_blank" rel="noopener">Ingress 网关</a></li>
<li><a href="https://istio.io/zh/docs/tasks/traffic-management/egress/egress-control/" target="_blank" rel="noopener">访问外部服务</a></li>
<li><a href="https://istio.io/zh/docs/tasks/observability/kiali/" target="_blank" rel="noopener">可视化您的网格</a></li>
</ul>
<p>下一步，可以定制 Istio 并部署您自己的应用。在您开始自定义 Istio 来适配您的平台或者其他用途之前，请查看以下资源：</p>
<ul>
<li><a href="https://istio.io/zh/docs/ops/deployment/deployment-models/" target="_blank" rel="noopener">部署模型</a></li>
<li><a href="https://istio.io/zh/docs/ops/best-practices/deployment/" target="_blank" rel="noopener">部署最佳实践</a></li>
<li><a href="https://istio.io/zh/docs/ops/deployment/requirements/" target="_blank" rel="noopener">Pod 需求</a></li>
<li><a href="https://istio.io/zh/docs/setup/" target="_blank" rel="noopener">常规安装说明</a></li>
</ul>
<h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h1 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/java/sharding-sphere/vitness/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Focus-1">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus-1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/java/sharding-sphere/vitness/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-02T21:58:22+08:00">
                2020-06-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/java/collection/java-collection-map-init-oom-bug/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Focus-1">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus-1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/java/collection/java-collection-map-init-oom-bug/" itemprop="url">永远不要使用双花括号初始化实例，否则可能会OOM！</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-23T00:00:00+08:00">
                2020-05-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <br>



<p>生活中的尴尬无处不在，有时候你只是想简单的装一把，但某些“老同志”总是在不经意之间，给你无情的一脚，踹得你简直无法呼吸。</p>
<p>但谁让咱年轻呢？吃亏要趁早，前路会更好。</p>
<p>喝了这口温热的鸡汤之后，咱们来聊聊是怎么回事。</p>
<p>事情是这样的，在一个不大不小的项目中，小王写下了这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap() &#123;&#123;</span><br><span class="line">    put(<span class="string">"map1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">    put(<span class="string">"map2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">    put(<span class="string">"map3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line">map.forEach((k, v) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"key:"</span> + k + <span class="string">" value:"</span> + v);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>本来是用它来替代下面这段代码的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="string">"map1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">map.put(<span class="string">"map2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">map.put(<span class="string">"map3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">map.forEach((k, v) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"key:"</span> + k + <span class="string">" value:"</span> + v);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>两块代码的执行结果也是完全一样的：</p>
<blockquote>
<p>key:map3 value:value3</p>
<p>key:map2 value:value2</p>
<p>key:map1 value:value1</p>
</blockquote>
<p>所以小王正在得意的把这段代码介绍给部门新来的妹子小甜甜看，却不巧被正在经过的老张也看到了。</p>
<p>老张本来只是想给昨天的枸杞再续上一杯 85° 的热水，但说来也巧，刚好撞到了一次能在小甜甜面前秀技术的一波机会，于是习惯性的整理了一下自己稀疏的秀发，便开启了 diss 模式。</p>
<p>“小王啊，你这个代码问题很大啊！”</p>
<p>“怎么能用双花括号初始化实例呢？”</p>
<p>此时的小王被问的一脸懵逼，内心有无数个草泥马奔腾而过，心想你这头老牛竟然也和我争这颗嫩草，但内心却有一种不祥的预感，感觉自己要输，瞬间羞涩的不知该说啥，只能红着小脸，轻轻的“嗯？”了一声。</p>
<p>老张：“使用双花括号初始化实例是会导致内存溢出的啦！侬不晓得嘛？”</p>
<p>小王沉默了片刻，只是凭借着以往的经验来看，这“老家伙”还是有点东西的，于是敷衍的“哦~”了一声，仿佛自己明白了怎么回事一样，，其实内心仍然迷茫的一匹，为了不让其他同事发现，只得这般作态。</p>
<p>于是片刻的敷衍，待老张离去之后，才悄悄的打开了 Google，默默的搜索了一下。</p>
<p>小王：哦，原来如此……</p>
<h1 id="双花括号初始化分析"><a href="#双花括号初始化分析" class="headerlink" title="双花括号初始化分析"></a>双花括号初始化分析</h1><p>首先，我们来看使用双花括号初始化的本质是什么？</p>
<p>以我们这段代码为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap() &#123;&#123;</span><br><span class="line">    put(<span class="string">"map1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">    put(<span class="string">"map2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">    put(<span class="string">"map3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>这段代码<strong>其实是创建了匿名内部类，然后再进行初始化代码块</strong>。</p>
<p>这一点我们可以使用命令<code>javac</code>将代码编译成字节码之后发现，我们发现之前的一个类被编译成两个字节码（.class）文件，如下图所示：</p>
<p>我们使用 Idea 打开<code>DoubleBracket$1.class</code>文件发现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleBracket</span>$1 <span class="keyword">extends</span> <span class="title">HashMap</span> </span>&#123;</span><br><span class="line">    DoubleBracket$<span class="number">1</span>(DoubleBracket var1) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = var1;</span><br><span class="line">        <span class="keyword">this</span>.put(<span class="string">"map1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">        <span class="keyword">this</span>.put(<span class="string">"map2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时我们可以确认，它就是一个匿名内部类。那么问题来了，匿名内部类为什么会导致内存溢出呢？</p>
<br>

<h1 id="匿名内部类的“锅”"><a href="#匿名内部类的“锅”" class="headerlink" title="匿名内部类的“锅”"></a>匿名内部类的“锅”</h1><p>在 Java 语言中非静态内部类会持有外部类的引用，从而导致 GC 无法回收这部分代码的引用，以至于造成内存溢出。</p>
<h3 id="思考-1：为什么要持有外部类？"><a href="#思考-1：为什么要持有外部类？" class="headerlink" title="思考 1：为什么要持有外部类？"></a>思考 1：为什么要持有外部类？</h3><p>这个就要从匿名内部类的设计说起了，在 Java 语言中，非静态匿名内部类的主要作用有两个。</p>
<p><strong>1</strong>、当匿名内部类只在外部类（主类）中使用时，匿名内部类可以让外部不知道它的存在，从而减少了代码的维护工作。</p>
<p><strong>2</strong>、当匿名内部类持有外部类时，它就可以直接使用外部类中的变量了，这样可以很方便的完成调用，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleBracket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String userName = <span class="string">"磊哥"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap() &#123;&#123;</span><br><span class="line">            put(<span class="string">"map1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">            put(<span class="string">"map2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">            put(<span class="string">"map3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">            put(userName, userName);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码可以看出在<code>HashMap</code>的方法内部，可以直接使用外部类的变量<code>userName</code>。</p>
<h3 id="思考-2：它是怎么持有外部类的？"><a href="#思考-2：它是怎么持有外部类的？" class="headerlink" title="思考 2：它是怎么持有外部类的？"></a>思考 2：它是怎么持有外部类的？</h3><p>关于匿名内部类是如何持久外部对象的，我们可以通过查看匿名内部类的字节码得知，我们使用<code>javap -c DoubleBracket\$1.class</code>命令进行查看，其中<code>$1</code>为以匿名类的字节码，字节码的内容如下；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">javap -c DoubleBracket\$<span class="number">1</span>.class</span><br><span class="line">Compiled from <span class="string">"DoubleBracket.java"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">DoubleBracket</span>$1 <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">HashMap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> com.example.DoubleBracket <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  com.example.DoubleBracket$<span class="number">1</span>(com.example.DoubleBracket);</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: aload_1</span><br><span class="line">       2: putfield      #1                  // Field this$0:Lcom/example/DoubleBracket;</span><br><span class="line">       <span class="number">5</span>: aload_0</span><br><span class="line">       6: invokespecial #7                  // Method java/util/HashMap."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">9</span>: aload_0</span><br><span class="line">      10: ldc           #13                 // String map1</span><br><span class="line">      12: ldc           #15                 // String value1</span><br><span class="line">      14: invokevirtual #17                 // Method put:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">      <span class="number">17</span>: pop</span><br><span class="line">      <span class="number">18</span>: aload_0</span><br><span class="line">      19: ldc           #21                 // String map2</span><br><span class="line">      21: ldc           #23                 // String value2</span><br><span class="line">      23: invokevirtual #17                 // Method put:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">      <span class="number">26</span>: pop</span><br><span class="line">      <span class="number">27</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，关键代码的在<code>putfield</code>这一行，此行表示有一个对<code>DoubleBracket</code>的引用被存入到<code>this$0</code>中，也就是说这个匿名内部类持有了外部类的引用。</p>
<p>如果您觉得以上字节码不够直观，没关系，我们用下面的实际的代码来证明一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleBracket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        Map map = <span class="keyword">new</span> DoubleBracket().createMap();</span><br><span class="line">        <span class="comment">// 获取一个类的所有字段</span></span><br><span class="line">        Field field = map.getClass().getDeclaredField(<span class="string">"this$0"</span>);</span><br><span class="line">        <span class="comment">// 设置允许方法私有的 private 修饰的变量</span></span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(field.get(map).getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">createMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 双花括号初始化</span></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap() &#123;&#123;</span><br><span class="line">            put(<span class="string">"map1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">            put(<span class="string">"map2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">            put(<span class="string">"map3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们开启调试模式时，可以看出<code>map</code>中持有了外部对象<code>DoubleBracket</code>，如下图所示：</p>
<p>以上代码的执行结果为：</p>
<blockquote>
<p>class com.example.DoubleBracket</p>
</blockquote>
<p>从以上程序输出结果可以看出：<strong>匿名内部类持有了外部类的引用，因此我们才可以使用<code>$0</code>正常获取到外部类，并输出相关的类信息</strong>。</p>
<br>

<h1 id="什么情况会导致内存泄漏？"><a href="#什么情况会导致内存泄漏？" class="headerlink" title="什么情况会导致内存泄漏？"></a>什么情况会导致内存泄漏？</h1><p>当我们把以下正常的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap() &#123;&#123;</span><br><span class="line">        put(<span class="string">"map1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">        put(<span class="string">"map2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">        put(<span class="string">"map3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    <span class="comment">// 业务处理....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改为下面这个样子时，可能会造成内存泄漏：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map <span class="title">createMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap() &#123;&#123;</span><br><span class="line">        put(<span class="string">"map1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">        put(<span class="string">"map2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">        put(<span class="string">"map3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么用了「可能」而不是「一定」会造成内存泄漏？</p>
<p>这是因为当此<code>map</code>被赋值为其他类属性时，可能会导致 GC 收集时不清理此对象，这时候才会导致内存泄漏。可以关注我「Java中文社群」后面会专门写一篇关于此问题的文章。</p>
<br>

<h1 id="如何保证内存不泄露？"><a href="#如何保证内存不泄露？" class="headerlink" title="如何保证内存不泄露？"></a>如何保证内存不泄露？</h1><p>要想保证双花扣号不泄漏，办法也很简单，只需要将<code>map</code>对象声明为<code>static</code>静态类型的就可以了，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title">createMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap() &#123;&#123;</span><br><span class="line">        put(<span class="string">"map1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">        put(<span class="string">"map2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">        put(<span class="string">"map3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>什么？你不相信！</p>
<p>没关系，我们用事实说话，使用以上代码，我们重新编译一份字节码，查看匿名类的内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">javap -c  DoubleBracket\$<span class="number">1</span>.class</span><br><span class="line">Compiled from <span class="string">"DoubleBracket.java"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">DoubleBracket</span>$1 <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">HashMap</span> </span>&#123;</span><br><span class="line">  com.example.DoubleBracket$<span class="number">1</span>();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/util/HashMap."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: aload_0</span><br><span class="line">       5: ldc           #7                  // String map1</span><br><span class="line">       7: ldc           #9                  // String value1</span><br><span class="line">       9: invokevirtual #11                 // Method put:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">      <span class="number">12</span>: pop</span><br><span class="line">      <span class="number">13</span>: aload_0</span><br><span class="line">      14: ldc           #17                 // String map2</span><br><span class="line">      16: ldc           #19                 // String value2</span><br><span class="line">      18: invokevirtual #11                 // Method put:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">      <span class="number">21</span>: pop</span><br><span class="line">      <span class="number">22</span>: aload_0</span><br><span class="line">      23: ldc           #21                 // String map3</span><br><span class="line">      25: ldc           #23                 // String value3</span><br><span class="line">      27: invokevirtual #11                 // Method put:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">      <span class="number">30</span>: pop</span><br><span class="line">      <span class="number">31</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这次的代码我们可以看出，<strong>已经没有<code>putfield</code>关键字这一行了，也就是说静态匿名类不会持有外部对象的引用了</strong>。</p>
<h3 id="为什么静态内部类不会持有外部类的引用？"><a href="#为什么静态内部类不会持有外部类的引用？" class="headerlink" title="为什么静态内部类不会持有外部类的引用？"></a>为什么静态内部类不会持有外部类的引用？</h3><p>原因其实很简单，因为匿名内部类是静态的之后，它所引用的对象或属性也必须是静态的了，因此就可以直接从 JVM 的 Method Area（方法区）获取到引用而无需持久外部对象了。</p>
<br>

<h1 id="双花括号的替代方案"><a href="#双花括号的替代方案" class="headerlink" title="双花括号的替代方案"></a>双花括号的替代方案</h1><p>即使声明为静态的变量可以避免内存泄漏，但依旧不建议这样使用，为什么呢？</p>
<p>原因很简单，项目一般都是需要团队协作的，假如那位老兄在不知情的情况下把你的<code>static</code>给删掉呢？这就相当于设置了一个隐形的“坑”，其他不知道的人，一不小心就跳进去了，所以我们可以尝试一些其他的方案，比如 Java8 中的 Stream API 和 Java9 中的集合工厂等。</p>
<h3 id="替代方案-1：Stream"><a href="#替代方案-1：Stream" class="headerlink" title="替代方案 1：Stream"></a>替代方案 1：Stream</h3><p>使用 Java8 中的 Stream API 替代，示例如下。原代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList() &#123;&#123;</span><br><span class="line">    add(<span class="string">"Java"</span>);</span><br><span class="line">    add(<span class="string">"Redis"</span>);</span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>替代代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Stream.of(<span class="string">"Java"</span>, <span class="string">"Redis"</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h3 id="替代方案-2：集合工厂"><a href="#替代方案-2：集合工厂" class="headerlink" title="替代方案 2：集合工厂"></a>替代方案 2：集合工厂</h3><p>使用集合工厂的<code>of</code>方法替代，示例如下。原代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span> HashMap() &#123;&#123;</span><br><span class="line">    put(<span class="string">"map1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">    put(<span class="string">"map2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>替代代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map map = Map.of(<span class="string">"map1"</span>, <span class="string">"Java"</span>, <span class="string">"map2"</span>, <span class="string">"Redis"</span>);</span><br></pre></td></tr></table></figure>

<p>显然使用 <code>Java9</code> 中的方案非常适合我们，简单又酷炫，只可惜我们还在用 <code>Java 6...6...6...</code>心碎了一地。</p>
<br>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文我们讲了双花括号初始化因为会持有外部类的引用，从而可以会导致内存泄漏的问题，还从字节码以及反射的层面演示了这个问题。</p>
<p>要想保证双花括号初始化不会出现内存泄漏的办法也很简单，只需要被<code>static</code>修饰即可，但这样做还是存在潜在的风险，可能会被某人不小心删除掉，于是我们另寻它道，发现了可以使用 <code>Java8</code> 中的 <code>Stream</code> 或 <code>Java9</code> 中的集合工厂<code>of</code>方法替代 双大括号。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/mysql/mysql-issue-max-connect-errors/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Focus-1">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus-1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/mysql/mysql-issue-max-connect-errors/" itemprop="url">被我误解的max_connect_errors</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-22T00:00:00+08:00">
                2020-05-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <br>

<blockquote>
<p>原文：<a href="https://developer.aliyun.com/article/755441" target="_blank" rel="noopener">https://developer.aliyun.com/article/755441</a></p>
</blockquote>
<h2 id="第一节-什么是max-connect-errors"><a href="#第一节-什么是max-connect-errors" class="headerlink" title="第一节 什么是max_connect_errors"></a>第一节 什么是<a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fserver-system-variables.html%23sysvar_max_connect_errors" target="_blank" rel="noopener">max_connect_errors</a></h2><p>一开始接触这个参数的时候，感觉他和max_connections的含义差不多，字面意思简单明了，这个参数的含义是最大连接错误数，翻翻mysql的文档中的解释是If more than this many successive connection requests from a host are interrupted without a successful connection, the server blocks that host from further connections,大意是：如果mysql服务器<strong>连续</strong>接收到了来自于<strong>同一个主机</strong>的请求，且这些<strong>连续</strong>的请求全部都<strong>没有成功的建立连接</strong>就被断开了，当这些<strong>连续</strong>的请求的累计值大于 max_connect_errors的设定值时，mysql服务器就会阻止这台主机后续的所有请求。”without a successful connection”那太好办了，故意输错密码不就行了，并且网上搜索了下该参数的说明，大量的文章充斥着” 防止暴力破解密码”的内容，于是兴高采烈的去做了测试。以下测试基于自建的mysql（非rds for mysql），由于rds for mysql无法直接设置set global，设置时需要在”rds控制台-参数这里”里进行设置：<a href="https://help.aliyun.com/document_detail/26179.html?spm=5176.11065259.1996646101.searchclickresult.44156de7pLffcV" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/26179.html?spm=5176.11065259.1996646101.searchclickresult.44156de7pLffcV</a></p>
<br>

<h2 id="第二节-测试max-connect-errors"><a href="#第二节-测试max-connect-errors" class="headerlink" title="第二节 测试max_connect_errors"></a>第二节 测试<a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fserver-system-variables.html%23sysvar_max_connect_errors" target="_blank" rel="noopener">max_connect_errors</a></h2><p>1,创建账号：</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/e7e62a3ea66248ab87c6a1da1b147896.png" alt="image.png"></p>
<p>2,设置max_connect_errors为3：</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/474298780e8146799e583ef69c8ece4a.png" alt="image.png"></p>
<p>3，故意输错密码3次，第四次使用正确密码登录进行验证：</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/8b0044d120c04ff8b8c721c78107207f.png" alt="image.png"></p>
<p>4,结论是第四次依然可以登录，即密码不对（认证失败）不属于” ”without a successful connection””的范畴，网上的” 防止暴力破解密码”也不成立了。</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/1ee779a11f0d41b880675f2833656da7.png" alt="image.png"></p>
<br>

<h2 id="第三节-继续分析max-connect-errors"><a href="#第三节-继续分析max-connect-errors" class="headerlink" title="第三节 继续分析max_connect_errors"></a>第三节 继续分析<a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fserver-system-variables.html%23sysvar_max_connect_errors" target="_blank" rel="noopener">max_connect_errors</a></h2><p>再继续看文档，发现还有以下说明：</p>
<p>You can unblock blocked hosts by flushing the host cache. To do so, issue a <a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fflush.html%23flush-hosts" target="_blank" rel="noopener">FLUSH HOSTS</a> statement or execute a <a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fmysqladmin.html" target="_blank" rel="noopener">mysqladmin flush-hosts</a> command.</p>
<p>大意是：</p>
<p>当你遇到主机被阻止的时候，你可以清空host cache来解决，具体的清空方法是执行flush hosts或者在mysql服务器的shell里执行 <a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fmysqladmin.html" target="_blank" rel="noopener">mysqladmin flush-hosts</a>操作</p>
<p>既然清空host cache可以解决主机被阻止访问的问题，那应该与host cache有些关系，看看host cache的介绍可能会有些眉目，关于host cache，文档解释如下：</p>
<p>The MySQL server maintains a host cache in memory that contains information about clients: IP address, host name, and error information. The server uses this cache for nonlocal TCP connections. It does not use the cache for TCP connections established using a loopback interface address (127.0.0.1 or ::1), or for connections established using a Unix socket file, named pipe, or shared memory.</p>
<p>大意是：</p>
<p>Mysql服务器会在内存里管理一个host cache，host cache里保存了一些客户端的ip地址，主机名，以及这个客户端在与server建立连接时遇到的一些错误信息，host cache对不是本地的TCP连接才有效，所以host cache对127.0.0.1 或者::1是无效的，并且对于Unix socket file、named pipe以及 shared memory方式建立的连接也是无效的。并且通过了解，host cache的内容可以通过performance_schema.host_cache来查看，通过performance_schema.host_cache表里的几个列的描述信息，对之前的测试不成立的原因有些了解了，部分相关列如下：</p>
<ul>
<li>IP<br>The IP address of the client that connected to the server, expressed as a string.</li>
</ul>
<p>连接到mysql server的主机的连接地址</p>
<ul>
<li>HOST<br>The resolved DNS host name for that client IP, or NULL if the name is unknown.</li>
</ul>
<p>通过dns解析IP地址获取到的该IP地址对应的mysql client的主机名</p>
<ul>
<li>SUM_CONNECT_ERRORS<br>The number of connection errors that are deemed “blocking” (assessed against the max_connect_errors system variable). Only protocol handshake errors are counted, and only for hosts that passed validation (HOST_VALIDATED = YES).</li>
<li>COUNT_HANDSHAKE_ERRORS<br>The number of errors detected at the wire protocol level.</li>
</ul>
<p>通过SUM_CONNECT_ERRORS(连接错误计数)描述，重点是红色部分：只计算协议握手过程的错误(Only protocol handshake errors are counted),也就是说max_connect_errors 可能记录的是协议(不确定是tcp协议还是应用协议，通过抓包以及COUNT_HANDSHAKE_ERRORS的” the wire protocol level”说明可能是指应用协议)的握手过程中出现的错误 ，也就是可以说网络不好(无法顺利握手)会导致该问题。</p>
<br>

<h2 id="第四节-继续测试max-connect-errors"><a href="#第四节-继续测试max-connect-errors" class="headerlink" title="第四节 继续测试max_connect_errors"></a>第四节 继续测试<a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fserver-system-variables.html%23sysvar_max_connect_errors" target="_blank" rel="noopener">max_connect_errors</a></h2><p>通过之前的说明，需要模拟应用协议握手失败的情况，最后考虑使用telnet一些来做测试</p>
<p>1,创建账号</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/40952e24f8244f9ca6e48b5c29a32de9.png" alt="image.png"></p>
<p>2,设置max_connect_errors为3：</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/d571db4eee624bbabaa2a362090121c1.png" alt="image.png"></p>
<p>3,先使用telnet 10.26.254.217 3306连接3次，第四次使用正确的账号密码尝试登陆：</p>
<p>telnet前查看performance_schema.host_cache的记录为空</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/949aead2e79c4bcd9bb585ee450b4126.png" alt="image.png"></p>
<p>第一次telnet 10.26.254.217 3306</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/84dbb96324234398b7b4d9b46016940f.png" alt="image.png"></p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/aa85fe91b1c14d3599d9529dc5116d8f.png" alt="image.png"></p>
<p>第二次 telnet 10.26.254.217 3306</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/38fa608ac69948328adbd4df1eb66fb1.png" alt="image.png"></p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/84e5ecbcd4954b81818a12f2800fabe9.png" alt="image.png"></p>
<p>第三次telnet 10.26.254.217 3306</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/9ebc5df826144464aa49705656b1a5a5.png" alt="image.png"></p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/f3c46a8b2bd54e46ba2d173a2879b4ee.png" alt="image.png"></p>
<p>第四次执行mysql -h10.26.254.217 -utestcon -p123 -P3306</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/81d064ae8f594d5aad095910872aefd6.png" alt="image.png"></p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/de855eea61c44cb0a6a9129b95c25728.png" alt="image.png"></p>
<p>问题复现了，出现了错误提示ERROR 1129 (HY000): Host ‘10.24.236.231’ is blocked because of many connection errors; unblock with ‘mysqladmin flush-hosts’</p>
<br>

<h2 id="第五节-ERROR-1129-HY000-问题延伸"><a href="#第五节-ERROR-1129-HY000-问题延伸" class="headerlink" title="第五节 ERROR 1129 (HY000)问题延伸"></a>第五节 ERROR 1129 (HY000)问题延伸</h2><p>解决ERROR 1129 (HY000)的方法是执行flush host或者<a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fmysqladmin.html" target="_blank" rel="noopener"> mysqladmin flush-hosts</a>，其目的是为了清空host cache里的信息，那是不是说不使用host cache就可以了？使host cache不生效的方式有如下两种：</p>
<p>1,设置 <a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fserver-system-variables.html%23sysvar_host_cache_size" target="_blank" rel="noopener">host_cache_size</a> 为0/ 打开<a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fserver-options.html%23option_mysqld_skip-host-cache" target="_blank" rel="noopener">skip-host-cache</a></p>
<p>2,打开<a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fserver-options.html%23option_mysqld_skip-name-resolve" target="_blank" rel="noopener">skip-name-resolve</a></p>
<p>需要通过测试看下推测是否生效</p>
<p>5.1 设置 <a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fserver-system-variables.html%23sysvar_host_cache_size" target="_blank" rel="noopener">host_cache_size 为0</a>/ 打开<a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fserver-options.html%23option_mysqld_skip-host-cache" target="_blank" rel="noopener">skip-host-cache</a><br>1,设置<a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fserver-system-variables.html%23sysvar_host_cache_size" target="_blank" rel="noopener">host_cache_size</a>为0</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/3d56c2d7717a4491a520da9d1feeac30.png" alt="image.png"></p>
<p>2,再次查询performance_schema.host_cache</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/89b5d7e6da314e3d8ed1a1555bcd3c33.png" alt="image.png"></p>
<p>3,继续之前的测试：先使用telnet 10.26.254.217 3306连接3次，第四次使用正确的账号密码尝试登陆</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/2d945a9ea18b484cb18867538c0fdd93.png" alt="image.png"></p>
<p>更改已经生效，<a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fserver-system-variables.html%23sysvar_max_connect_errors" target="_blank" rel="noopener">max_connect_errors</a>的作用无效了</p>
<p>5.2 打开<a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fserver-options.html%23option_mysqld_skip-name-resolve" target="_blank" rel="noopener">skip-name-resolve</a><br>1,在cnf配置文件里设置<a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fserver-options.html%23option_mysqld_skip-name-resolve" target="_blank" rel="noopener">skip-name-resolve </a>以此打开<a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fserver-options.html%23option_mysqld_skip-name-resolve" target="_blank" rel="noopener">skip-name-resolve</a></p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/533ea2abead949eca053687ae90b10c7.png" alt="image.png"></p>
<p>2,继续之前的测试：先使用telnet 10.26.254.217 3306连接3次，第四次使用正确的账号密码尝试登陆</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/633cfc564e104211b103eacc6a19c2c0.png" alt="image.png"></p>
<p>3,查询performance_schema.host_cache</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/d063f01a34474c3f97cb01eb8580536d.png" alt="image.png"></p>
<p>更改已经生效，<a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fserver-system-variables.html%23sysvar_max_connect_errors" target="_blank" rel="noopener">max_connect_errors</a>的作用无效了，RDS for mysql 的skip_name_resolve是on的状态，</p>
<p>所以很少会出现ERROR 1129 (HY000)的错误</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/computer-network/linux-srcode-epoll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Focus-1">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus-1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/computer-network/linux-srcode-epoll/" itemprop="url">理解epoll（基于linux2.6.12.1）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-25T00:00:00+08:00">
                2020-04-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computer-network/" itemprop="url" rel="index">
                    <span itemprop="name">computer-network</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computer-network/tcp/" itemprop="url" rel="index">
                    <span itemprop="name">tcp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <br>

<p>epoll在现在的软件中占据了很大的分量，nginx，libuv等单线程事件循环的软件都使用了epoll。之前分析过select，今天分析一下epoll。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>epoll与select</li>
<li>epoll_create</li>
<li>epoll_ctl</li>
<li>epoll_wait</li>
<li>ET、LT模式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;</span><br></pre></td></tr></table></figure>

<h3 id="epoll与select"><a href="#epoll与select" class="headerlink" title="epoll与select"></a>epoll与select</h3><ul>
<li>Epoll 没有最大并发连接的限制，上限是最大可以打开文件的数目</li>
<li>效率提升，epoll对于句柄事件的选择不是遍历的，是事件响应的，就是句柄上事件来就马上选择出来，不需要遍历整个句柄链表，因此效率非常高，内核将句柄用红黑树保存的，IO效率不随FD数目增加而线性下降。</li>
<li>内存拷贝， select让内核把 FD 消息通知给用户空间的时候使用了内存拷贝的方式，开销较大，但是Epoll 在这点上使用了共享内存的方式，这个内存拷贝也省略了。</li>
</ul>
<p>相比于select，epoll最大的好处在于它不会随着监听fd数目的增长而降低效率。因为在内核中的select实现中，它是采用轮询来处理的，轮询的fd数目越多，自然耗时越多。</p>
<p>并且，在linux/posix_types.h头文件有这样的声明：</p>
<p>#define __FD_SETSIZE 1024</p>
<p>表示select最多同时监听1024个fd，当然，可以通过修改头文件再重编译内核来扩大这个数目，但这似乎并不治本。</p>
<p>epoll_create</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size);</span><br></pre></td></tr></table></figure>

<p>创建一个epoll的句柄，</p>
<ul>
<li>size用来告诉内核这个监听的数目一共有多大。</li>
</ul>
<p>这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p>
<p>epoll_ctl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</span><br></pre></td></tr></table></figure>

<p>epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型</p>
<ul>
<li>EPOLL_CTL_ADD 注册新的fd到epfd中；</li>
<li>EPOLL_CTL_MOD 修改已经注册的fd的监听事件；</li>
<li>EPOLL_CTL_DEL 从epfd中删除一个fd；</li>
</ul>
<p>fd 是要监听的fd</p>
<p>event 是要监听什么样的事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef union epoll_data &#123;</span><br><span class="line"> void *ptr;</span><br><span class="line"> int fd;</span><br><span class="line"> uint32_t u32;</span><br><span class="line"> uint64_t u64;</span><br><span class="line">&#125; epoll_data_t;</span><br><span class="line">struct epoll_event &#123;</span><br><span class="line"> uint32_t events; /* Epoll events */</span><br><span class="line"> epoll_data_t data; /* User data variable */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>events可以是以下几个宏的集合：</p>
<ul>
<li>EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</li>
<li>EPOLLOUT：表示对应的文件描述符可以写；</li>
<li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</li>
<li>EPOLLERR：表示对应的文件描述符发生错误；</li>
<li>EPOLLHUP：表示对应的文件描述符被挂断；</li>
<li>EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</li>
<li>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</li>
</ul>
<p>epoll_wait</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int epoll_wait(int epfd, struct epoll_event *events,</span><br><span class="line"> int maxevents, int timeout);</span><br></pre></td></tr></table></figure>

<p>等待事件的产生，类似于select()调用。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个 maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p>
<h3 id="ET、LT两种工作模式"><a href="#ET、LT两种工作模式" class="headerlink" title="ET、LT两种工作模式"></a>ET、LT两种工作模式</h3><ul>
<li>EPOLLLT：完全靠Linux-kernel-epoll驱动，应用程序只需要处理从epoll_wait返回的fds， 这些fds我们认为它们处于就绪状态。此时epoll可以认为是更快速的poll。</li>
<li>EPOLLET：此模式下，系统仅仅通知应用程序哪些fds变成了就绪状态，一旦fd变成就绪状态，epoll将不再关注这个fd的任何状态信息(从epoll队列移除), 直到应用程序通过读写操作（非阻塞）触发EAGAIN状态，epoll认为这个fd又变为空闲状态，那么epoll又重新关注这个fd的状态变化(重新加入epoll队列)。 随着epoll_wait的返回，队列中的fds是在减少的，所以在大并发的系统中，EPOLLET更有优势，但是对程序员的要求也更高。</li>
</ul>
<p><strong>举例</strong></p>
<p>假设现在对方发送了2k的数据，而我们先读取了1k，然后这时调用了epoll_wait，如果是边沿触发ET，那么这个fd变成就绪状态就会从epoll 队列移除，则epoll_wait 会一直阻塞，忽略尚未读取的1k数据; 而如果是水平触发LT，那么epoll_wait 还会检测到可读事件而返回，我们可以继续读取剩下的1k 数据。</p>
<p><strong>总结:</strong> LT模式可能触发的次数更多, 一旦触发的次数多, 也就意味着效率会下降; 但这样也不能就说LT模式就比ET模式效率更低, 因为ET的使用对编程人员提出了更高更精细的要求,一旦使用者编程水平不够, 那ET模式还不如LT模式。</p>
<p>ET模式仅当状态发生变化的时候才获得通知,这里所谓的状态的变化并不包括缓冲区中还有未处理的数据,也就是说,如果要采用ET模式,需要一直read/write直到出错为止,很多人反映为什么采用ET模式只接收了一部分数据就再也得不到通知了,大多因为这样;而LT模式是只要有数据没有处理就会一直通知下去的.</p>
<h3 id="epoll-IO多路复用模型实现机制"><a href="#epoll-IO多路复用模型实现机制" class="headerlink" title="epoll IO多路复用模型实现机制"></a>epoll IO多路复用模型实现机制</h3><p>设想一下如下场景：有100万个客户端同时与一个服务器进程保持着TCP连接。而每一时刻，通常只有几百上千个TCP连接是活跃的(事实上大部分场景都是这种情况)。如何实现这样的高并发？</p>
<p>在select/poll时代，服务器进程每次都把这100万个连接告诉操作系统(从用户态复制句柄数据结构到内核态)，让操作系统内核去查询这些套接字上是否有事件发生，轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll一般只能处理几千的并发连接。</p>
<p>epoll的设计和实现与select完全不同。epoll通过在Linux内核中申请一个简易的文件系统，把原先的select/poll调用分成了3个部分：</p>
<ul>
<li>调用epoll_create()建立一个epoll对象(在epoll文件系统中为这个句柄对象分配资源)</li>
<li>调用epoll_ctl向epoll对象中添加这100万个连接的套接字</li>
<li>调用epoll_wait收集发生的事件的连接</li>
</ul>
<p>只需要在进程启动时建立一个epoll对象，然后在需要的时候向这个epoll对象中添加或者删除连接。同时，epoll_wait的效率也非常高，因为调用epoll_wait时，并没有一股脑的向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的连接。</p>
<p>Linux内核具体的epoll机制实现思路。</p>
<p>当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * This structure is stored inside the &quot;private_data&quot; member of the file</span><br><span class="line"> * structure and rapresent the main data sructure for the eventpoll</span><br><span class="line"> * interface.</span><br><span class="line"> */</span><br><span class="line">struct eventpoll &#123;</span><br><span class="line"> /* Protect the this structure access */</span><br><span class="line"> spinlock_t lock;</span><br><span class="line"> /*</span><br><span class="line"> * This mutex is used to ensure that files are not removed</span><br><span class="line"> * while epoll is using them. This is held during the event</span><br><span class="line"> * collection loop, the file cleanup path, the epoll file exit</span><br><span class="line"> * code and the ctl operations.</span><br><span class="line"> */</span><br><span class="line"> struct mutex mtx;</span><br><span class="line"> /* Wait queue used by sys_epoll_wait() */</span><br><span class="line"> wait_queue_head_t wq;</span><br><span class="line"> /* Wait queue used by file-&gt;poll() */</span><br><span class="line"> wait_queue_head_t poll_wait;</span><br><span class="line"> /* List of ready file descriptors */</span><br><span class="line">/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/ </span><br><span class="line"> struct list_head rdllist;</span><br><span class="line">/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span><br><span class="line"> /* RB tree root used to store monitored fd structs */</span><br><span class="line"> struct rb_root rbr;</span><br><span class="line"> /*</span><br><span class="line"> * This is a single linked list that chains all the &quot;struct epitem&quot; that</span><br><span class="line"> * happened while transfering ready events to userspace w/out</span><br><span class="line"> * holding -&gt;lock.</span><br><span class="line"> */</span><br><span class="line"> struct epitem *ovflist;</span><br><span class="line"> /* The user that created the eventpoll descriptor */</span><br><span class="line"> struct user_struct *user;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每一个epoll对象都有一个独立的eventpoll结构体，用于存放通过epoll_ctl方法向epoll对象中添加进来的事件。这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来(红黑树的插入时间效率是lgn，其中n为树的高度)。</p>
<p>而所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法。这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中。</p>
<p>在epoll中，对于每一个事件，都会建立一个epitem结构体，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Each file descriptor added to the eventpoll interface will</span><br><span class="line"> * have an entry of this type linked to the &quot;rbr&quot; RB tree.</span><br><span class="line"> */</span><br><span class="line">struct epitem &#123;</span><br><span class="line"> /* RB tree node used to link this structure to the eventpoll RB tree */</span><br><span class="line">//红黑树节点 </span><br><span class="line"> struct rb_node rbn;</span><br><span class="line"> /* List header used to link this structure to the eventpoll ready list */</span><br><span class="line">//双向链表节点 </span><br><span class="line"> struct list_head rdllink;</span><br><span class="line"> /*</span><br><span class="line"> * Works together &quot;struct eventpoll&quot;-&gt;ovflist in keeping the</span><br><span class="line"> * single linked chain of items.</span><br><span class="line"> */</span><br><span class="line"> struct epitem *next;</span><br><span class="line"> /* The file descriptor information this item refers to */</span><br><span class="line">//事件句柄信息</span><br><span class="line"> struct epoll_filefd ffd;</span><br><span class="line"> /* Number of active wait queue attached to poll operations */</span><br><span class="line"> int nwait;</span><br><span class="line"> /* List containing poll wait queues */</span><br><span class="line"> struct list_head pwqlist;</span><br><span class="line"> /* The &quot;container&quot; of this item */</span><br><span class="line">//指向其所属的eventpoll对象 </span><br><span class="line"> struct </span><br><span class="line">![Uploading EPOLL_663944.jpg . . .]</span><br><span class="line">eventpoll *ep;</span><br><span class="line"> /* List header used to link this item to the &quot;struct file&quot; items list */</span><br><span class="line"> struct list_head fllink;</span><br><span class="line"> /* The structure that describe the interested events and the source fd */</span><br><span class="line"> //期待发生的事件类型 </span><br><span class="line"> struct epoll_event event;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。</p>
<p><img src="https://pic1.zhimg.com/80/v2-47c2346f42a179a09c73d96df45eb510_720w.jpg" alt="img"></p>
<p>通过红黑树和双链表数据结构，并结合回调机制，造就了epoll的高效。</p>
<p>下面我们按照epoll三部曲的顺序进行分析。</p>
<h2 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage long sys_epoll_create(int size)</span><br><span class="line">&#123;</span><br><span class="line">    int error, fd;</span><br><span class="line">    struct inode *inode;</span><br><span class="line">    struct file *file;</span><br><span class="line"></span><br><span class="line">    error = ep_getfd(&amp;fd, &amp;inode, &amp;file);</span><br><span class="line">    error = ep_file_init(file);</span><br><span class="line"></span><br><span class="line">    return fd;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现create函数似乎很简单。</p>
<p>1、操作系统中，进程和文件系统是通过fd=&gt;file=&gt;node联系起来的。ep_getfd就是在建立这个联系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static int ep_getfd(int *efd, struct inode **einode, struct file **efile)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    // 获取一个file结构体</span><br><span class="line">    file = get_empty_filp();</span><br><span class="line">    // epoll在底层本身对应一个文件系统，从这个文件系统中获取一个inode</span><br><span class="line">    inode = ep_eventpoll_inode();</span><br><span class="line">    // 获取一个文件描述符</span><br><span class="line">    fd = get_unused_fd();</span><br><span class="line"></span><br><span class="line">    sprintf(name, &quot;[%lu]&quot;, inode-&gt;i_ino);</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.len = strlen(name);</span><br><span class="line">    this.hash = inode-&gt;i_ino;</span><br><span class="line">    // 申请一个entry</span><br><span class="line">    dentry = d_alloc(eventpoll_mnt-&gt;mnt_sb-&gt;s_root, &amp;this);</span><br><span class="line">    dentry-&gt;d_op = &amp;eventpollfs_dentry_operations;</span><br><span class="line">    file-&gt;f_dentry = dentry;</span><br><span class="line"></span><br><span class="line">    // 建立file和inode的联系</span><br><span class="line">    d_add(dentry, inode);</span><br><span class="line">    // 建立fd=&gt;file的关联</span><br><span class="line">    fd_install(fd, file);</span><br><span class="line"></span><br><span class="line">    *efd = fd;</span><br><span class="line">    *einode = inode;</span><br><span class="line">    *efile = file;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>形成一个这种的结构。</p>
<p>2、通过ep_file_init建立file和epoll的关联。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static int ep_file_init(struct file *file)</span><br><span class="line">&#123;</span><br><span class="line">    struct eventpoll *ep;</span><br><span class="line"></span><br><span class="line">    ep = kmalloc(sizeof(struct eventpoll), GFP_KERNEL)</span><br><span class="line">    memset(ep, 0, sizeof(*ep));</span><br><span class="line">    // 一系列初始化</span><br><span class="line">    file-&gt;private_data = ep;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>epoll_create函数主要是建立一个数据结构。并返回一个文件描述符供后面使用。</p>
<h2 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage long</span><br><span class="line">sys_epoll_ctl(int epfd, int op, int fd, struct epoll_event __user *event)</span><br><span class="line">&#123;</span><br><span class="line">    int error;</span><br><span class="line">    struct file *file, *tfile;</span><br><span class="line">    struct eventpoll *ep;</span><br><span class="line">    struct epitem *epi;</span><br><span class="line">    struct epoll_event epds;</span><br><span class="line"></span><br><span class="line">    error = -EFAULT;</span><br><span class="line">    // 不是删除操作则复制用户数据到内核</span><br><span class="line">    if (</span><br><span class="line">        EP_OP_HASH_EVENT(op) &amp;&amp;</span><br><span class="line">        copy_from_user(&amp;epds, event, sizeof(struct epoll_event))</span><br><span class="line">      )</span><br><span class="line">        goto eexit_1;</span><br><span class="line"></span><br><span class="line">    // 根据一种的图，拿到epoll对应的file结构体</span><br><span class="line">    file = fget(epfd);</span><br><span class="line"></span><br><span class="line">    // 拿到操作的文件的file结构体</span><br><span class="line">    tfile = fget(fd);</span><br><span class="line">    // 通过file拿到epoll_event结构体，见上面的图</span><br><span class="line">    ep = file-&gt;private_data;</span><br><span class="line">    // 看这个文件描述符是否已经存在，epoll用红黑树维护这个数据</span><br><span class="line">    epi = ep_find(ep, tfile, fd);</span><br><span class="line"></span><br><span class="line">    switch (op) &#123;</span><br><span class="line">    // 新增</span><br><span class="line">    case EPOLL_CTL_ADD:</span><br><span class="line">        // 还没有则新增，有则报错</span><br><span class="line">        if (!epi) &#123;</span><br><span class="line">            epds.events |= POLLERR | POLLHUP;</span><br><span class="line">            // 插入红黑树</span><br><span class="line">            error = ep_insert(ep, &amp;epds, tfile, fd);</span><br><span class="line">        &#125; else</span><br><span class="line">            error = -EEXIST;</span><br><span class="line">        break;</span><br><span class="line">    // 删除</span><br><span class="line">    case EPOLL_CTL_DEL:</span><br><span class="line">        // 存在则删除，否则报错</span><br><span class="line">        if (epi)</span><br><span class="line">            error = ep_remove(ep, epi);</span><br><span class="line">        else</span><br><span class="line">            error = -ENOENT;</span><br><span class="line">        break;</span><br><span class="line">    // 修改</span><br><span class="line">    case EPOLL_CTL_MOD:</span><br><span class="line">        // 存在则修改，否则报错</span><br><span class="line">        if (epi) &#123;</span><br><span class="line">            epds.events |= POLLERR | POLLHUP;</span><br><span class="line">            error = ep_modify(ep, epi, &amp;epds);</span><br><span class="line">        &#125; else</span><br><span class="line">            error = -ENOENT;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>epoll_ctl函数看起来也没有很复杂，就是根据用户传进来的信息去操作红黑树。对于红黑树的增删改查，查和删除就不分析了。就是去操作红黑树。增和改是类似的逻辑，所以我们只分析增操作就可以了。在此之前，我们先了解一些epoll中其他的数据结构。</p>
<p>当我们新增一个需要监听的文件描述符的时候，系统会申请一个epitem去表示。epitem是保存了文件描述符、事件等信息的结构体。然后把epitem插入到eventpoll结构体维护的红黑树中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static int ep_insert(struct eventpoll *ep, struct epoll_event *event,</span><br><span class="line">             struct file *tfile, int fd)</span><br><span class="line">&#123;</span><br><span class="line">    int error, revents, pwake = 0;</span><br><span class="line">    unsigned long flags;</span><br><span class="line">    struct epitem *epi;</span><br><span class="line">    struct ep_pqueue epq;</span><br><span class="line"></span><br><span class="line">    // 申请一个epitem</span><br><span class="line">    epi = EPI_MEM_ALLOC()</span><br><span class="line">    // 省略一系列初始化工作</span><br><span class="line">    // 记录所属的epoll</span><br><span class="line">    epi-&gt;ep = ep;</span><br><span class="line">    // 在epitem中保存文件描述符fd和file</span><br><span class="line">    EP_SET_FFD(&amp;epi-&gt;ffd, tfile, fd);</span><br><span class="line">    // 监听的事件</span><br><span class="line">    epi-&gt;event = *event;</span><br><span class="line">    epi-&gt;nwait = 0;</span><br><span class="line"></span><br><span class="line">    epq.epi = epi;</span><br><span class="line">    init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);</span><br><span class="line">    revents = tfile-&gt;f_op-&gt;poll(tfile, &amp;epq.pt);</span><br><span class="line"></span><br><span class="line">    // 把epitem插入红黑树</span><br><span class="line">    ep_rbtree_insert(ep, epi);</span><br><span class="line"></span><br><span class="line">    // 如果监听的事件在新增的时候就已经触发，则直接插入到epoll就绪队列</span><br><span class="line">    if ((revents &amp; event-&gt;events) &amp;&amp; !EP_IS_LINKED(&amp;epi-&gt;rdllink)) &#123;</span><br><span class="line">        // 把epitem插入就绪队列rdllist</span><br><span class="line">        list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">        //  有事件触发，唤醒阻塞在epoll_wait的进程队列</span><br><span class="line">        if (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">            wake_up(&amp;ep-&gt;wq);</span><br><span class="line">        if (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">            pwake++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增操作的大致流程是：</p>
<ol>
<li>申请了一个新的epitem表示待观察的实体。他保存了文件描述符、感兴趣的事件等信息。</li>
<li>插入红黑树</li>
<li>判断新增的节点中对应的文件描述符和事件是否已经触发了，是则加入到就绪队列（由eventpoll-&gt;rdllist维护的一个队列）</li>
</ol>
<p>下面具体看一下如何判断感兴趣的事件在对应的文件描述符中是否已经触发。相关代码在ep_insert中。下面单独拎出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    struct ep_pqueue &#123;</span><br><span class="line">        // 函数指针</span><br><span class="line">        poll_table pt;</span><br><span class="line">        // epitem</span><br><span class="line">        struct epitem *epi;</span><br><span class="line">    &#125;;</span><br><span class="line">*/</span><br><span class="line">struct ep_pqueue epq;</span><br><span class="line">epq.epi = epi;</span><br><span class="line">init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);</span><br><span class="line">revents = tfile-&gt;f_op-&gt;poll(tfile, &amp;epq.pt);</span><br><span class="line"></span><br><span class="line">static inline void init_poll_funcptr(poll_table *pt, poll_queue_proc qproc)</span><br><span class="line">&#123;</span><br><span class="line">    pt-&gt;qproc = qproc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是定义了一个struct ep_pqueue 结构体，然后设置他的一个字段为ep_ptable_queue_proc。然后执行tfile-&gt;f_op-&gt;poll。poll函数由各个文件系统或者网络协议实现。我们以管道为例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static unsigned int</span><br><span class="line">pipe_poll(struct file *filp, poll_table *wait)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int mask;</span><br><span class="line">    // 监听的文件描述符对应的inode</span><br><span class="line">    struct inode *inode = filp-&gt;f_dentry-&gt;d_inode;</span><br><span class="line">    struct pipe_inode_info *info = inode-&gt;i_pipe;</span><br><span class="line">    int nrbufs;</span><br><span class="line">    /*</span><br><span class="line">    static inline void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p)</span><br><span class="line">    &#123;</span><br><span class="line">        if (p &amp;&amp; wait_address)</span><br><span class="line">            p-&gt;qproc(filp, wait_address, p);</span><br><span class="line">    &#125;</span><br><span class="line">    */</span><br><span class="line">    poll_wait(filp, PIPE_WAIT(*inode), wait);</span><br><span class="line"></span><br><span class="line">    // 判断哪些事件触发了</span><br><span class="line">    nrbufs = info-&gt;nrbufs;</span><br><span class="line">    mask = 0;</span><br><span class="line">    if (filp-&gt;f_mode &amp; FMODE_READ) &#123;</span><br><span class="line">        mask = (nrbufs &gt; 0) ? POLLIN | POLLRDNORM : 0;</span><br><span class="line">        if (!PIPE_WRITERS(*inode) &amp;&amp; filp-&gt;f_version != PIPE_WCOUNTER(*inode))</span><br><span class="line">            mask |= POLLHUP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (filp-&gt;f_mode &amp; FMODE_WRITE) &#123;</span><br><span class="line">        mask |= (nrbufs &lt; PIPE_BUFFERS) ? POLLOUT | POLLWRNORM : 0;</span><br><span class="line">        if (!PIPE_READERS(*inode))</span><br><span class="line">            mask |= POLLERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到具体的poll函数里会首先执行poll_wait函数。这个函数只是简单执行struct ep_pqueue epq结构体中的函数，即刚才设置的ep_ptable_queue_proc。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//  监听的文件描述符对应的file结构体，whead是等待监听的文件描述符对应的inode可用的队列</span><br><span class="line">static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,</span><br><span class="line">                 poll_table *pt)</span><br><span class="line">&#123;</span><br><span class="line">    struct epitem *epi = EP_ITEM_FROM_EPQUEUE(pt);</span><br><span class="line">    struct eppoll_entry *pwq;</span><br><span class="line"></span><br><span class="line">    if (epi-&gt;nwait &gt;= 0 &amp;&amp; (pwq = PWQ_MEM_ALLOC())) &#123;</span><br><span class="line">        pwq-&gt;wait-&gt;flags = 0;</span><br><span class="line">        pwq-&gt;wait-&gt;task = NULL;</span><br><span class="line">        // 设置回调</span><br><span class="line">        pwq-&gt;wait-&gt;func = ep_poll_callback;</span><br><span class="line">        pwq-&gt;whead = whead;</span><br><span class="line">        pwq-&gt;base = epi;</span><br><span class="line">        // 插入等待监听的文件描述符的inode可用的队列，回调函数是ep_poll_callback</span><br><span class="line">        add_wait_queue(whead, &amp;pwq-&gt;wait);</span><br><span class="line">        list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);</span><br><span class="line">        epi-&gt;nwait++;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /* We have to signal that an error occurred */</span><br><span class="line">        epi-&gt;nwait = -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要的逻辑是把当前进程插入监听的文件的等待队列中，等待唤醒。</p>
<h2 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage long sys_epoll_wait(int epfd, struct epoll_event __user *events,</span><br><span class="line">                   int maxevents, int timeout)</span><br><span class="line">&#123;</span><br><span class="line">    int error;</span><br><span class="line">    struct file *file;</span><br><span class="line">    struct eventpoll *ep;</span><br><span class="line">    // 通过epoll的fd拿到对应的file结构体</span><br><span class="line">    file = fget(epfd);</span><br><span class="line">    // 通过file结构体拿到eventpoll结构体</span><br><span class="line">    ep = file-&gt;private_data;</span><br><span class="line">    error = ep_poll(ep, events, maxevents, timeout);</span><br><span class="line">    return error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,</span><br><span class="line">           int maxevents, long timeout)</span><br><span class="line">&#123;</span><br><span class="line">    int res, eavail;</span><br><span class="line">    unsigned long flags;</span><br><span class="line">    long jtimeout;</span><br><span class="line">    wait_queue_t wait;</span><br><span class="line"></span><br><span class="line">    // 计算超时时间</span><br><span class="line">    jtimeout = timeout == -1 || timeout &gt; (MAX_SCHEDULE_TIMEOUT - 1000) / HZ ?</span><br><span class="line">        MAX_SCHEDULE_TIMEOUT: (timeout * HZ + 999) / 1000;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line"></span><br><span class="line">    res = 0;</span><br><span class="line">    // 就绪队列为空</span><br><span class="line">    if (list_empty(&amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">        // 加入阻塞队列</span><br><span class="line">        init_waitqueue_entry(&amp;wait, current);</span><br><span class="line">        add_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line"></span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            // 挂起</span><br><span class="line">            set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">            // 超时或者有就绪事件了，则跳出返回</span><br><span class="line">            if (!list_empty(&amp;ep-&gt;rdllist) || !jtimeout)</span><br><span class="line">                break;</span><br><span class="line">            // 被信号唤醒返回EINTR</span><br><span class="line">            if (signal_pending(current)) &#123;</span><br><span class="line">                res = -EINTR;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 设置定时器，然后进程挂起，等待超时唤醒（超时或者信号唤醒）</span><br><span class="line">            jtimeout = schedule_timeout(jtimeout);</span><br><span class="line">        &#125;</span><br><span class="line">        // 移出阻塞队列</span><br><span class="line">        remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line">        // 设置就绪</span><br><span class="line">        set_current_state(TASK_RUNNING);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 是否有事件就绪，唤醒的原因有几个，被唤醒不代表就有就绪事件</span><br><span class="line">    eavail = !list_empty(&amp;ep-&gt;rdllist);</span><br><span class="line"></span><br><span class="line">    write_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line">    // 处理就绪事件返回</span><br><span class="line">    if (!res &amp;&amp; eavail &amp;&amp;</span><br><span class="line">        !(res = ep_events_transfer(ep, events, maxevents)) &amp;&amp; jtimeout)</span><br><span class="line">        goto retry;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说epoll_wait的逻辑主要是处理就绪队列的节点。</p>
<ol>
<li>如果就绪队列为空，则根据timeout做下一步处理，可能定时阻塞。</li>
<li>如果就绪队列非空则处理就绪队列，返回给用户。处理就绪队列的函数是ep_events_transfer。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static int ep_events_transfer(struct eventpoll *ep,</span><br><span class="line">                  struct epoll_event __user *events, int maxevents)</span><br><span class="line">&#123;</span><br><span class="line">    int eventcnt = 0;</span><br><span class="line">    struct list_head txlist;</span><br><span class="line"></span><br><span class="line">    INIT_LIST_HEAD(&amp;txlist);</span><br><span class="line"></span><br><span class="line">    if (ep_collect_ready_items(ep, &amp;txlist, maxevents) &gt; 0) &#123;</span><br><span class="line">        eventcnt = ep_send_events(ep, &amp;txlist, events);</span><br><span class="line">        ep_reinject_items(ep, &amp;txlist);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return eventcnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是三个函数，我们一个个看。</p>
<p>1、ep_collect_ready_items收集就绪事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static int ep_collect_ready_items(struct eventpoll *ep, struct list_head *txlist, int maxevents)</span><br><span class="line">&#123;</span><br><span class="line">    int nepi;</span><br><span class="line">    unsigned long flags;</span><br><span class="line">    // 就绪事件的队列</span><br><span class="line">    struct list_head *lsthead = &amp;ep-&gt;rdllist, *lnk;</span><br><span class="line">    struct epitem *epi;</span><br><span class="line"></span><br><span class="line">    for (nepi = 0, lnk = lsthead-&gt;next; lnk != lsthead &amp;&amp; nepi &lt; maxevents;) &#123;</span><br><span class="line">        // 通过结构体字段的地址拿到结构体首地址</span><br><span class="line">        epi = list_entry(lnk, struct epitem, rdllink);</span><br><span class="line"></span><br><span class="line">        lnk = lnk-&gt;next;</span><br><span class="line"></span><br><span class="line">        /* If this file is already in the ready list we exit soon */</span><br><span class="line">        if (!EP_IS_LINKED(&amp;epi-&gt;txlink)) &#123;</span><br><span class="line"></span><br><span class="line">            epi-&gt;revents = epi-&gt;event.events;</span><br><span class="line">            // 插入txlist队列，然后处理完再返回给用户</span><br><span class="line">            list_add(&amp;epi-&gt;txlink, txlist);</span><br><span class="line">            nepi++;</span><br><span class="line">            // 从就绪队列中删除</span><br><span class="line">            EP_LIST_DEL(&amp;epi-&gt;rdllink);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nepi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、ep_send_events判断哪些事件触发了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static int ep_send_events(struct eventpoll *ep, struct list_head *txlist,</span><br><span class="line">              struct epoll_event __user *events)</span><br><span class="line">&#123;</span><br><span class="line">    int eventcnt = 0;</span><br><span class="line">    unsigned int revents;</span><br><span class="line">    struct list_head *lnk;</span><br><span class="line">    struct epitem *epi;</span><br><span class="line">    // 遍历就绪队列，记录触发的事件</span><br><span class="line">    list_for_each(lnk, txlist) &#123;</span><br><span class="line">        epi = list_entry(lnk, struct epitem, txlink);</span><br><span class="line">        // 判断哪些事件触发了</span><br><span class="line">        revents = epi-&gt;ffd.file-&gt;f_op-&gt;poll(epi-&gt;ffd.file, NULL);</span><br><span class="line"></span><br><span class="line">        epi-&gt;revents = revents &amp; epi-&gt;event.events;</span><br><span class="line">        // 复制到用户空间</span><br><span class="line">        if (epi-&gt;revents) &#123;</span><br><span class="line">            if (__put_user(epi-&gt;revents,</span><br><span class="line">                       &amp;events[eventcnt].events) ||</span><br><span class="line">                __put_user(epi-&gt;event.data,</span><br><span class="line">                       &amp;events[eventcnt].data))</span><br><span class="line">                return -EFAULT;</span><br><span class="line">            // 只监听一次，触发完设置成对任何事件都不感兴趣</span><br><span class="line">            if (epi-&gt;event.events &amp; EPOLLONESHOT)</span><br><span class="line">                epi-&gt;event.events &amp;= EP_PRIVATE_BITS;</span><br><span class="line">            eventcnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return eventcnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、ep_reinject_items重新插入就绪队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static void ep_reinject_items(struct eventpoll *ep, struct list_head *txlist)</span><br><span class="line">&#123;</span><br><span class="line">    int ricnt = 0, pwake = 0;</span><br><span class="line">    unsigned long flags;</span><br><span class="line">    struct epitem *epi;</span><br><span class="line"></span><br><span class="line">    while (!list_empty(txlist)) &#123;</span><br><span class="line">        epi = list_entry(txlist-&gt;next, struct epitem, txlink);</span><br><span class="line">        EP_LIST_DEL(&amp;epi-&gt;txlink);</span><br><span class="line">        //  水平触发模式则一直通知，即重新加入就绪队列</span><br><span class="line">        if (EP_RB_LINKED(&amp;epi-&gt;rbn) &amp;&amp; !(epi-&gt;event.events &amp; EPOLLET) &amp;&amp;</span><br><span class="line">            (epi-&gt;revents &amp; epi-&gt;event.events) &amp;&amp; !EP_IS_LINKED(&amp;epi-&gt;rdllink)) &#123;</span><br><span class="line">            list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">            ricnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，并有没有在epoll_wait的时候去收集就绪事件，那么就绪队列是谁处理的呢？我们回顾一下插入红黑树的时候，做了一个事情，就是在文件对应的inode上注册一个回调。当文件满足条件的时候，就会唤醒因为epoll_wait而阻塞的进程。epoll_wait会收集事件返回给用户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static int ep_poll_callback(wait_queue_t *wait, unsigned mode, int sync, void *key)</span><br><span class="line">&#123;</span><br><span class="line">    int pwake = 0;</span><br><span class="line">    unsigned long flags;</span><br><span class="line">    struct epitem *epi = EP_ITEM_FROM_WAIT(wait);</span><br><span class="line">    struct eventpoll *ep = epi-&gt;ep;</span><br><span class="line">    // 插入就绪队列</span><br><span class="line">    list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">    // 唤醒因epoll_wait而阻塞的进程</span><br><span class="line">    if (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">        wake_up(&amp;ep-&gt;wq);</span><br><span class="line">    if (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">        pwake++;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>epoll的实现涉及的内容比较多，先分析一下大致的原理。有机会再深入分析。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/computer-network/linux-srcode-tcp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Focus-1">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus-1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/computer-network/linux-srcode-tcp/" itemprop="url">linux下深入理解TCP/IP协议的实现（基于linux1.2.13）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-25T00:00:00+08:00">
                2020-04-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computer-network/" itemprop="url" rel="index">
                    <span itemprop="name">computer-network</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computer-network/tcp/" itemprop="url" rel="index">
                    <span itemprop="name">tcp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <br>

<h1 id="bind实现"><a href="#bind实现" class="headerlink" title="bind实现"></a>bind实现</h1><p>按照socket网络编程的顺序，我们这一篇来分析bind函数。我们通过socket函数拿到了一个socket结构体。bind函数的逻辑其实比较简单，他就是给socket结构体绑定一个地址，简单来说，就是给他的某些字段赋值。talk is cheap。show me the code。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static int sock_bind(int fd, struct sockaddr *umyaddr, int addrlen)</span><br><span class="line">&#123;</span><br><span class="line">    struct socket *sock;</span><br><span class="line">    int i;</span><br><span class="line">    char address[MAX_SOCK_ADDR];</span><br><span class="line">    int err;</span><br><span class="line"></span><br><span class="line">    // 通过文件描述符找到对应的socket   </span><br><span class="line">    if (!(sock = sockfd_lookup(fd, NULL))) </span><br><span class="line">        return(-ENOTSOCK);</span><br><span class="line"></span><br><span class="line">    if((err=move_addr_to_kernel(umyaddr,addrlen,address))&lt;0)</span><br><span class="line">        return err;</span><br><span class="line"></span><br><span class="line">    if ((i = sock-&gt;ops-&gt;bind(sock, (struct sockaddr *)address, addrlen)) &lt; 0) </span><br><span class="line">    &#123;</span><br><span class="line">        return(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是两个函数，我们一个个来。</p>
<h3 id="1、sockfd-lookup"><a href="#1、sockfd-lookup" class="headerlink" title="1、sockfd_lookup"></a>1、sockfd_lookup</h3><p>通过之前一些文章的分析，我们应该数socket和文件的内存布局比较熟悉了。下面的代码不难理解。就是根据文件描述符从pcb中找到inode节点。因为inode节点里保存了socket结构体，所以最后返回fd对应的socke结构体就行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 通过fd找到file结构体，从而找到inode节点，最后找到socket结构体</span><br><span class="line">static inline struct socket *sockfd_lookup(int fd, struct file **pfile)</span><br><span class="line">&#123;</span><br><span class="line">    struct file *file;</span><br><span class="line">    struct inode *inode;</span><br><span class="line"></span><br><span class="line">    if (fd &lt; 0 || fd &gt;= NR_OPEN || !(file = current-&gt;files-&gt;fd[fd])) </span><br><span class="line">        return NULL;</span><br><span class="line"></span><br><span class="line">    inode = file-&gt;f_inode;</span><br><span class="line">    if (!inode || !inode-&gt;i_sock)</span><br><span class="line">        return NULL;</span><br><span class="line"></span><br><span class="line">    if (pfile) </span><br><span class="line">        *pfile = file;</span><br><span class="line"></span><br><span class="line">    return socki_lookup(inode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// inode和socket互相引用</span><br><span class="line">inline struct socket *socki_lookup(struct inode *inode)</span><br><span class="line">&#123;</span><br><span class="line">    return &amp;inode-&gt;u.socket_i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、sock-gt-ops-gt-bind"><a href="#2、sock-gt-ops-gt-bind" class="headerlink" title="2、sock-&gt;ops-&gt;bind"></a>2、sock-&gt;ops-&gt;bind</h3><p>我们回顾socket那篇文章可以知道socket结构体里保存了一些列的操作函数，假设是协议簇是ipv4，那么bind函数就是inet_bind函数（省略了部分代码）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">// 给socket绑定一个地址</span><br><span class="line">static int inet_bind(struct socket *sock, struct sockaddr *uaddr,</span><br><span class="line">           int addr_len)</span><br><span class="line">&#123;</span><br><span class="line">    struct sockaddr_in *addr=(struct sockaddr_in *)uaddr;</span><br><span class="line">    // 拿到底层的sock结构体</span><br><span class="line">    struct sock *sk=(struct sock *)sock-&gt;data, *sk2;</span><br><span class="line">    unsigned short snum = 0 /* Stoopid compiler.. this IS ok */;</span><br><span class="line">    int chk_addr_ret;</span><br><span class="line"></span><br><span class="line">    // raw协议的这些数据由用户填充  </span><br><span class="line">    if(sock-&gt;type != SOCK_RAW)</span><br><span class="line">    &#123;   // 已经绑定了端口</span><br><span class="line">        if (sk-&gt;num != 0) </span><br><span class="line">            return(-EINVAL);</span><br><span class="line"></span><br><span class="line">        snum = ntohs(addr-&gt;sin_port);</span><br><span class="line"></span><br><span class="line">        // 端口无效则随机获取一个非root才能使用的端口</span><br><span class="line">        if (snum == 0) </span><br><span class="line">        &#123;</span><br><span class="line">            snum = get_new_socknum(sk-&gt;prot, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        // 小于1024的端口需要超级用户权限</span><br><span class="line">        if (snum &lt; PROT_SOCK &amp;&amp; !suser()) </span><br><span class="line">            return(-EACCES);</span><br><span class="line">    &#125;</span><br><span class="line">    // 判断ip</span><br><span class="line">    chk_addr_ret = ip_chk_addr(addr-&gt;sin_addr.s_addr);</span><br><span class="line">    // 非法地址</span><br><span class="line">    if (addr-&gt;sin_addr.s_addr != 0 &amp;&amp; chk_addr_ret != IS_MYADDR &amp;&amp; chk_addr_ret != IS_MULTICAST)</span><br><span class="line">        return(-EADDRNOTAVAIL); /* Source address MUST be ours! */</span><br><span class="line">     // 记录ip    </span><br><span class="line">    if (chk_addr_ret || addr-&gt;sin_addr.s_addr == 0)</span><br><span class="line">        sk-&gt;saddr = addr-&gt;sin_addr.s_addr;</span><br><span class="line">    if(sock-&gt;type != SOCK_RAW)</span><br><span class="line">    &#123;</span><br><span class="line">        /* Make sure we are allowed to bind here. */</span><br><span class="line">        cli();</span><br><span class="line">        // 遍历哈希表，哈希表冲突解决法是链地址法，校验绑定的端口的合法性</span><br><span class="line">        for(sk2 = sk-&gt;prot-&gt;sock_array[snum &amp; (SOCK_ARRAY_SIZE -1)];</span><br><span class="line">                    sk2 != NULL; sk2 = sk2-&gt;next) </span><br><span class="line">        &#123;</span><br><span class="line">            // 端口还没有绑定过，直接校验下一个</span><br><span class="line">            if (sk2-&gt;num != snum) </span><br><span class="line">                continue;</span><br><span class="line">            // 端口已经被使用，没有设置可重用标记，比如断开连接后在2msl内是否可以重用，通过setsockopt函数设置</span><br><span class="line">            if (!sk-&gt;reuse)</span><br><span class="line">            &#123;</span><br><span class="line">                sti();</span><br><span class="line">                return(-EADDRINUSE);</span><br><span class="line">            &#125;</span><br><span class="line">            // 端口一样，但是ip不一样，ok，下一个</span><br><span class="line">            if (sk2-&gt;saddr != sk-&gt;saddr) </span><br><span class="line">                continue;   /* socket per slot ! -FB */</span><br><span class="line">            // 端口和ip都一样。被监听的端口不能同时被使用</span><br><span class="line">            if (!sk2-&gt;reuse || sk2-&gt;state==TCP_LISTEN) </span><br><span class="line">            &#123;</span><br><span class="line">                sti();</span><br><span class="line">                return(-EADDRINUSE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sti();</span><br><span class="line">        // 保证该sk不在sock_array队列里</span><br><span class="line">        remove_sock(sk);</span><br><span class="line">        // 挂载到sock_array里</span><br><span class="line">        put_sock(snum, sk);</span><br><span class="line">        // tcp头中的源端口</span><br><span class="line">        sk-&gt;dummy_th.source = ntohs(sk-&gt;num);</span><br><span class="line">        sk-&gt;daddr = 0;</span><br><span class="line">        sk-&gt;dummy_th.dest = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bind函数主要是对待绑定的ip和端口做一个校验，合法的时就记录在sock结构体中。并且把sock结构体挂载到一个全局的哈希表里。</p>
<br>

<h1 id="listen-实现"><a href="#listen-实现" class="headerlink" title="listen 实现"></a>listen 实现</h1><p>listen函数的逻辑比bind还简单。bind主要是校验和绑定ip、端口。listen则是修改socket的状态，并记录一些设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">static int sock_listen(int fd, int backlog)</span><br><span class="line">&#123;</span><br><span class="line">    struct socket *sock;</span><br><span class="line"></span><br><span class="line">    if (fd &lt; 0 || fd &gt;= NR_OPEN || current-&gt;files-&gt;fd[fd] == NULL)</span><br><span class="line">        return(-EBADF);</span><br><span class="line">    if (!(sock = sockfd_lookup(fd, NULL))) </span><br><span class="line">        return(-ENOTSOCK);</span><br><span class="line"></span><br><span class="line">    if (sock-&gt;state != SS_UNCONNECTED) </span><br><span class="line">    &#123;</span><br><span class="line">        return(-EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (sock-&gt;ops &amp;&amp; sock-&gt;ops-&gt;listen)</span><br><span class="line">        sock-&gt;ops-&gt;listen(sock, backlog);</span><br><span class="line">    // 设置socket的监听属性，accept函数时用到    </span><br><span class="line">    sock-&gt;flags |= SO_ACCEPTCON;</span><br><span class="line">    return(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int inet_listen(struct socket *sock, int backlog)</span><br><span class="line">&#123;</span><br><span class="line">    struct sock *sk = (struct sock *) sock-&gt;data;</span><br><span class="line">    // 如果没有绑定端口则绑定一个，并把sock加到sock_array中</span><br><span class="line">    if(inet_autobind(sk)!=0)</span><br><span class="line">        return -EAGAIN;</span><br><span class="line"></span><br><span class="line">    if ((unsigned) backlog &gt; 128)</span><br><span class="line">        backlog = 128;</span><br><span class="line">    // tcp接收队列的长度上限，不同系统实现不一样，具体参考tcp.c的使用</span><br><span class="line">    sk-&gt;max_ack_backlog = backlog;</span><br><span class="line">    // 修改socket状态，防止多次调用listen</span><br><span class="line">    if (sk-&gt;state != TCP_LISTEN)</span><br><span class="line">    &#123;   </span><br><span class="line">        sk-&gt;ack_backlog = 0;</span><br><span class="line">        sk-&gt;state = TCP_LISTEN;</span><br><span class="line">    &#125;</span><br><span class="line">    return(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 绑定一个随机的端口，更新sk的源端口字段，并把sk挂载到端口对应的队列中，见bind函数的分析</span><br><span class="line">static int inet_autobind(struct sock *sk)</span><br><span class="line">&#123;</span><br><span class="line">    /* We may need to bind the socket. */</span><br><span class="line">    if (sk-&gt;num == 0) </span><br><span class="line">    &#123;</span><br><span class="line">        sk-&gt;num = get_new_socknum(sk-&gt;prot, 0);</span><br><span class="line">        if (sk-&gt;num == 0) </span><br><span class="line">            return(-EAGAIN);</span><br><span class="line">        put_sock(sk-&gt;num, sk);</span><br><span class="line">        sk-&gt;dummy_th.source = ntohs(sk-&gt;num);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="accept-实现"><a href="#accept-实现" class="headerlink" title="accept 实现"></a>accept 实现</h1><p>我们继续分析tcp/ip协议的实现，这一篇讲一下accept，accept就是从已完成三次握手的连接队列里，摘下一个节点。我们可以了解到三次握手的实现和过程。很多同学都了解三次握手是什么，但是可能很少同学会深入思考或者看他的实现，众所周知，一个服务器启动的时候，会监听一个端口。其实就是新建了一个socket。那么如果有一个连接到来的时候，我们通过accept就能拿到这个新连接对应的socket。那么这个socket和监听的socket是不是同一个呢？其实socket分为监听型和通信型的。表面上，服务器用一个端口实现了多个连接，但是这个端口是用于监听的，底层用于和客户端通信的其实是另一个socket。所以每一个连接过来，负责监听的socket发现是一个建立连接的包（syn包），他就会生成一个新的socket与之通信（accept的时候返回的那个）。我们将会从代码中看到这个实现。<br>我们从accept函数开始，详细分析这个过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">static int sock_accept(int fd, struct sockaddr *upeer_sockaddr, int *upeer_addrlen)</span><br><span class="line">&#123;</span><br><span class="line">    struct file *file;</span><br><span class="line">    struct socket *sock, *newsock;</span><br><span class="line">    int i;</span><br><span class="line">    char address[MAX_SOCK_ADDR];</span><br><span class="line">    int len;</span><br><span class="line"></span><br><span class="line">    if (fd &lt; 0 || fd &gt;= NR_OPEN || ((file = current-&gt;files-&gt;fd[fd]) == NULL))</span><br><span class="line">        return(-EBADF);</span><br><span class="line">    // 根据文件描述符找到对应的file结构体和socket结构</span><br><span class="line">      if (!(sock = sockfd_lookup(fd, &amp;file))) </span><br><span class="line">        return(-ENOTSOCK);</span><br><span class="line">    if (sock-&gt;state != SS_UNCONNECTED) </span><br><span class="line">    &#123;</span><br><span class="line">        return(-EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line">    // socket没有调用过listen，报错，该标记位在listen中设置</span><br><span class="line">    if (!(sock-&gt;flags &amp; SO_ACCEPTCON)) </span><br><span class="line">    &#123;</span><br><span class="line">        return(-EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line">    // 分配一个新的socket结构体</span><br><span class="line">    if (!(newsock = sock_alloc())) </span><br><span class="line">    &#123;</span><br><span class="line">        printk(&quot;NET: sock_accept: no more sockets\n&quot;);</span><br><span class="line">        return(-ENOSR); /* Was: EAGAIN, but we are out of system</span><br><span class="line">                   resources! */</span><br><span class="line">    &#125;</span><br><span class="line">    newsock-&gt;type = sock-&gt;type;</span><br><span class="line">    newsock-&gt;ops = sock-&gt;ops;</span><br><span class="line">    // 创建一个底层的sock结构体和新的socket结构体互相关联</span><br><span class="line">    if ((i = sock-&gt;ops-&gt;dup(newsock, sock)) &lt; 0) </span><br><span class="line">    &#123;</span><br><span class="line">        sock_release(newsock);</span><br><span class="line">        return(i);</span><br><span class="line">    &#125;</span><br><span class="line">    // accept返回一个新的sock和socket关联</span><br><span class="line">    i = newsock-&gt;ops-&gt;accept(sock, newsock, file-&gt;f_flags);</span><br><span class="line">    if ( i &lt; 0) </span><br><span class="line">    &#123;</span><br><span class="line">        sock_release(newsock);</span><br><span class="line">        return(i);</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回一个新的文件描述符</span><br><span class="line">    if ((fd = get_fd(SOCK_INODE(newsock))) &lt; 0) </span><br><span class="line">    &#123;</span><br><span class="line">        sock_release(newsock);</span><br><span class="line">        return(-EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line">    // 是否需要获取socket对应的地址</span><br><span class="line">    if (upeer_sockaddr)</span><br><span class="line">    &#123;</span><br><span class="line">        newsock-&gt;ops-&gt;getname(newsock, (struct sockaddr *)address, &amp;len, 1);</span><br><span class="line">        move_addr_to_user(address,len, upeer_sockaddr, upeer_addrlen);</span><br><span class="line">    &#125;</span><br><span class="line">    return(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们一步步来分析这个函数。<br>1 通过fd找到对应的socket结构体，然后申请一个新的socket结构体和sock结构体，并且把他们两互相关联。这个在前面的文章分析过。<br>2 然后把监听的socket和准备用于通信的结构体作为参数，调用accept函数。<br>3 最后返回通信socket对应的文件描述符。</p>
<p>下面我们开始分析accept函数的真正实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static int inet_accept(struct socket *sock, struct socket *newsock, int flags)</span><br><span class="line">&#123;</span><br><span class="line">    struct sock *sk1, *sk2;</span><br><span class="line">    int err;</span><br><span class="line">    sk1 = (struct sock *) sock-&gt;data;</span><br><span class="line">    // 返回一个新的sock结构体</span><br><span class="line">    sk2 = sk1-&gt;prot-&gt;accept(sk1,flags);</span><br><span class="line">    // 互相关联</span><br><span class="line">    newsock-&gt;data = (void *)sk2;</span><br><span class="line">    sk2-&gt;socket = newsock;</span><br><span class="line">    newsock-&gt;conn = NULL;</span><br><span class="line">    // 设置sock为已经建立连接状态</span><br><span class="line">    newsock-&gt;state = SS_CONNECTED;</span><br><span class="line">    return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数主要是调底层的accept函数，底层accept函数会返回一个新的sock结构体，socket和sock结构体的区别和背景在之前的文章里已经分析过。总的来说，accept函数就是申请一个新的通信socket，这个socket关联了一个新的sock结构体。下面我们看看tcp层的accept函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static struct sock *tcp_accept(struct sock *sk, int flags)</span><br><span class="line">&#123;</span><br><span class="line">    struct sock *newsk;</span><br><span class="line">    struct sk_buff *skb;</span><br><span class="line"></span><br><span class="line">    // 是一个listen的套接字</span><br><span class="line">    if (sk-&gt;state != TCP_LISTEN) </span><br><span class="line">    &#123;</span><br><span class="line">        sk-&gt;err = EINVAL;</span><br><span class="line">        return(NULL); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cli();</span><br><span class="line">    // 从sock的receive_queue队列摘取已建立连接的节点，</span><br><span class="line">    while((skb = tcp_dequeue_established(sk)) == NULL) </span><br><span class="line">    &#123;   </span><br><span class="line">        // 没有已经建立连接的节点，但是设置了非阻塞模式，直接返回</span><br><span class="line">        if (flags &amp; O_NONBLOCK) </span><br><span class="line">        &#123;</span><br><span class="line">            sti();</span><br><span class="line">            release_sock(sk);</span><br><span class="line">            sk-&gt;err = EAGAIN;</span><br><span class="line">            return(NULL);</span><br><span class="line">        &#125;</span><br><span class="line">        release_sock(sk);</span><br><span class="line">        //阻塞进程，如果后续建立了连接，则进程被唤醒的时候，就会跳出while循环</span><br><span class="line">        interruptible_sleep_on(sk-&gt;sleep);</span><br><span class="line">      &#125;</span><br><span class="line">    sti();</span><br><span class="line"></span><br><span class="line">    // 拿到一个新的sock结构，由建立连接的时候创建的</span><br><span class="line">    newsk = skb-&gt;sk;</span><br><span class="line"></span><br><span class="line">    // 返回新的sock结构体</span><br><span class="line">    return(newsk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数主要的逻辑是从监听型socket的已完成三次握手的队列里摘下一个节点。这个节点是一个sk_buff结构体，sk_buff是一个表示网络数据包的数据结构。</p>
<p><img src="https://pic2.zhimg.com/80/v2-f3220906a0bf893d6a6c4b62d56c00d1_720w.jpg" alt="img"></p>
<p>accept函数就分析完了。下一篇我们分析三次握手。看看accept函数摘下的这个节点是如果生成的。</p>
<br>

<h1 id="connect-实现"><a href="#connect-实现" class="headerlink" title="connect 实现"></a>connect 实现</h1><p>分析完了服务器端，我们继续分析客户端，在socket编程中，客户端的流程是比较简单的，申请一个socket，然后调connect去发起连接就行。我们先看一下connect函数的定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    socket 通过socket函数申请的结构体</span><br><span class="line">    address 需要连接的目的地地址信息</span><br><span class="line">*/</span><br><span class="line">int connect(int socket, const struct sockaddr *address,socklen_t address_len);</span><br></pre></td></tr></table></figure>

<p>我们通过层层调用揭开connect的迷雾。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static int sock_connect(int fd, struct sockaddr *uservaddr, int addrlen)</span><br><span class="line">&#123;</span><br><span class="line">    struct socket *sock;</span><br><span class="line">    struct file *file;</span><br><span class="line">    int i;</span><br><span class="line">    char address[MAX_SOCK_ADDR];</span><br><span class="line">    int err;</span><br><span class="line"></span><br><span class="line">    if (fd &lt; 0 || fd &gt;= NR_OPEN || (file=current-&gt;files-&gt;fd[fd]) == NULL)</span><br><span class="line">        return(-EBADF);</span><br><span class="line">    if (!(sock = sockfd_lookup(fd, &amp;file)))</span><br><span class="line">        return(-ENOTSOCK);</span><br><span class="line"></span><br><span class="line">    i = sock-&gt;ops-&gt;connect(sock, (struct sockaddr *)address, addrlen, file-&gt;f_flags);</span><br><span class="line">    if (i &lt; 0) </span><br><span class="line">    &#123;</span><br><span class="line">        return(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有太多逻辑，通过fd找到关联的socket结构体。然后调底层函数。底层的函数是inet_connect，这个函数逻辑比较多，我们分开分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (sock-&gt;state == SS_CONNECTING &amp;&amp; sk-&gt;protocol == IPPROTO_TCP &amp;&amp; (flags &amp; O_NONBLOCK)) &#123;</span><br><span class="line">    if (sk-&gt;err != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        err=sk-&gt;err;</span><br><span class="line">        sk-&gt;err=0;</span><br><span class="line">        return -err;</span><br><span class="line">    &#125;</span><br><span class="line">    return -EALREADY;   /* Connecting is currently in progress */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正在连接，并且是非阻塞的，直接返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (sock-&gt;state != SS_CONNECTING) </span><br><span class="line">    &#123;</span><br><span class="line">        // 如果绑过就不需要绑了</span><br><span class="line">        if(inet_autobind(sk)!=0)</span><br><span class="line">            return(-EAGAIN);</span><br><span class="line">        // 调用底层的连接函数，发一个syn包</span><br><span class="line">        err = sk-&gt;prot-&gt;connect(sk, (struct sockaddr_in *)uaddr, addr_len);</span><br><span class="line">        if (err &lt; 0) </span><br><span class="line">            return(err);</span><br><span class="line">        // 发送成功设置状态为连接中</span><br><span class="line">          sock-&gt;state = SS_CONNECTING;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>继续调用底层的函数，这里是tcp，所以是发送一个sync包（一会分析）。然后把socket状态修改为连接中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (sk-&gt;state != TCP_ESTABLISHED &amp;&amp;(flags &amp; O_NONBLOCK)) </span><br><span class="line">    return(-EINPROGRESS);</span><br></pre></td></tr></table></figure>

<p>还没建立连接成功并且是非阻塞的方式，直接返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 连接建立中，阻塞当前进程</span><br><span class="line">while(sk-&gt;state == TCP_SYN_SENT || sk-&gt;state == TCP_SYN_RECV) </span><br><span class="line">&#123;   </span><br><span class="line">    // 可中断式睡眠，即可被信号唤醒</span><br><span class="line">    interruptible_sleep_on(sk-&gt;sleep);</span><br><span class="line">    // 被唤醒后，判断是因为被信号唤醒的还是因为建立建立了。</span><br><span class="line">    if (current-&gt;signal &amp; ~current-&gt;blocked) </span><br><span class="line">    &#123;</span><br><span class="line">        sti();</span><br><span class="line">        return(-ERESTARTSYS);</span><br><span class="line">    &#125;</span><br><span class="line">    // 连接失败</span><br><span class="line">    if(sk-&gt;err &amp;&amp; sk-&gt;protocol == IPPROTO_TCP)</span><br><span class="line">    &#123;</span><br><span class="line">        sti();</span><br><span class="line">        sock-&gt;state = SS_UNCONNECTED;</span><br><span class="line">        err = -sk-&gt;err;</span><br><span class="line">        sk-&gt;err=0;</span><br><span class="line">        return err; /* set by tcp_err() */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>connect的时候如果没有设置阻塞标记，则进程会被挂起。tcp层建立连接后会唤醒进程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 连接建立</span><br><span class="line">    sock-&gt;state = SS_CONNECTED;</span><br><span class="line"></span><br><span class="line">    if (sk-&gt;state != TCP_ESTABLISHED &amp;&amp; sk-&gt;err) </span><br><span class="line">    &#123;</span><br><span class="line">        sock-&gt;state = SS_UNCONNECTED;</span><br><span class="line">        err=sk-&gt;err;</span><br><span class="line">        sk-&gt;err=0;</span><br><span class="line">        return(-err);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最后被连接建立唤醒后，设置socket的状态。connect就完成了。</p>
<p>下面我们看一下tcp层的connect的实现，其实就是从客户端视角看三次握手的过程。代码比较多，只看一下核心的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">static int tcp_connect(struct sock *sk, struct sockaddr_in *usin, int addr_len)</span><br><span class="line">&#123;</span><br><span class="line">    struct sk_buff *buff;</span><br><span class="line">    struct device *dev=NULL;</span><br><span class="line">    unsigned char *ptr;</span><br><span class="line">    int tmp;</span><br><span class="line">    int atype;</span><br><span class="line">    struct tcphdr *t1;</span><br><span class="line">    struct rtable *rt;</span><br><span class="line"></span><br><span class="line">    if (usin-&gt;sin_family &amp;&amp; usin-&gt;sin_family != AF_INET) </span><br><span class="line">        return(-EAFNOSUPPORT);</span><br><span class="line"></span><br><span class="line">      // 不传ip则取本机ip</span><br><span class="line">      if(usin-&gt;sin_addr.s_addr==INADDR_ANY)</span><br><span class="line">        usin-&gt;sin_addr.s_addr=ip_my_addr();</span><br><span class="line">    // 禁止广播和多播</span><br><span class="line">    if ((atype=ip_chk_addr(usin-&gt;sin_addr.s_addr)) == IS_BROADCAST || atype==IS_MULTICAST) </span><br><span class="line">        return -ENETUNREACH;</span><br><span class="line"></span><br><span class="line">    sk-&gt;inuse = 1;</span><br><span class="line">    // 连接的远端地址</span><br><span class="line">    sk-&gt;daddr = usin-&gt;sin_addr.s_addr;</span><br><span class="line">    // 第一个字节的序列号</span><br><span class="line">    sk-&gt;write_seq = tcp_init_seq();</span><br><span class="line">    sk-&gt;window_seq = sk-&gt;write_seq;</span><br><span class="line">    sk-&gt;rcv_ack_seq = sk-&gt;write_seq -1;</span><br><span class="line">    sk-&gt;err = 0;</span><br><span class="line">    // 远端端口</span><br><span class="line">    sk-&gt;dummy_th.dest = usin-&gt;sin_port;</span><br><span class="line">    release_sock(sk);</span><br><span class="line">    // 分配一个skb</span><br><span class="line">    buff = sk-&gt;prot-&gt;wmalloc(sk,MAX_SYN_SIZE,0, GFP_KERNEL);</span><br><span class="line">    sk-&gt;inuse = 1;</span><br><span class="line">    // tcp头和选项，告诉对方自己的接收窗口大小1</span><br><span class="line">    buff-&gt;len = 24;</span><br><span class="line">    buff-&gt;sk = sk;</span><br><span class="line">    buff-&gt;free = 0;</span><br><span class="line">    buff-&gt;localroute = sk-&gt;localroute;</span><br><span class="line">    t1 = (struct tcphdr *) buff-&gt;data;</span><br><span class="line">    // 查找路由</span><br><span class="line">    rt=ip_rt_route(sk-&gt;daddr, NULL, NULL);</span><br><span class="line">    // 构建ip和mac头</span><br><span class="line">    tmp = sk-&gt;prot-&gt;build_header(buff, sk-&gt;saddr, sk-&gt;daddr, &amp;dev,</span><br><span class="line">                    IPPROTO_TCP, NULL, MAX_SYN_SIZE,sk-&gt;ip_tos,sk-&gt;ip_ttl);</span><br><span class="line">    buff-&gt;len += tmp;</span><br><span class="line">    t1 = (struct tcphdr *)((char *)t1 +tmp);</span><br><span class="line">    memcpy(t1,(void *)&amp;(sk-&gt;dummy_th), sizeof(*t1));</span><br><span class="line">    // 序列号为初始化的序列号</span><br><span class="line">    t1-&gt;seq = ntohl(sk-&gt;write_seq++);</span><br><span class="line">    // 下一个数据包中第一个字节的序列号 </span><br><span class="line">    sk-&gt;sent_seq = sk-&gt;write_seq;</span><br><span class="line">    buff-&gt;h.seq = sk-&gt;write_seq;</span><br><span class="line">    t1-&gt;ack = 0;</span><br><span class="line">    t1-&gt;window = 2;</span><br><span class="line">    t1-&gt;res1=0;</span><br><span class="line">    t1-&gt;res2=0;</span><br><span class="line">    t1-&gt;rst = 0;</span><br><span class="line">    t1-&gt;urg = 0;</span><br><span class="line">    t1-&gt;psh = 0;</span><br><span class="line">    // 是一个syn包</span><br><span class="line">    t1-&gt;syn = 1;</span><br><span class="line">    t1-&gt;urg_ptr = 0;</span><br><span class="line">    // TCP头包括24个字节，因为还有4个字节的选项</span><br><span class="line">    t1-&gt;doff = 6;</span><br><span class="line"></span><br><span class="line">    // 执行tcp头后面的第一个字节</span><br><span class="line">    ptr = (unsigned char *)(t1+1);</span><br><span class="line">    // 选项的类型是2，通知对方TCP报文中数据部分的最大值</span><br><span class="line">    ptr[0] = 2;</span><br><span class="line">    // 选项内容长度是4个字节</span><br><span class="line">    ptr[1] = 4;</span><br><span class="line">    // 组成MSS</span><br><span class="line">    ptr[2] = (sk-&gt;mtu) &gt;&gt; 8;</span><br><span class="line">    ptr[3] = (sk-&gt;mtu) &amp; 0xff;</span><br><span class="line">    // tcp头的校验和</span><br><span class="line">    tcp_send_check(t1, sk-&gt;saddr, sk-&gt;daddr,sizeof(struct tcphdr) + 4, sk);</span><br><span class="line"></span><br><span class="line">    // 设置套接字为syn_send状态</span><br><span class="line">    tcp_set_state(sk,TCP_SYN_SENT);</span><br><span class="line">    // 设置数据包往返时间需要的时间</span><br><span class="line">    sk-&gt;rto = TCP_TIMEOUT_INIT;</span><br><span class="line">    // 设置超时回调</span><br><span class="line">    sk-&gt;retransmit_timer.function=&amp;retransmit_timer;</span><br><span class="line">    sk-&gt;retransmit_timer.data = (unsigned long)sk;</span><br><span class="line">    // 设置超时时间</span><br><span class="line">    reset_xmit_timer(sk, TIME_WRITE, sk-&gt;rto);  </span><br><span class="line">    // 设置syn包的重试次数</span><br><span class="line">    sk-&gt;retransmits = TCP_SYN_RETRIES;</span><br><span class="line">    // 发送</span><br><span class="line">    sk-&gt;prot-&gt;queue_xmit(sk, dev, buff, 0);  </span><br><span class="line">    reset_xmit_timer(sk, TIME_WRITE, sk-&gt;rto);</span><br><span class="line">    release_sock(sk);</span><br><span class="line">    return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很长，主要是构建一个sync包发出去。在这个代码里我们大概能看到tcp协议的相关实现。上面的代码完成了第一次握手。下面再看一下第二次握手的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 发送了syn包</span><br><span class="line">if(sk-&gt;state==TCP_SYN_SENT)</span><br><span class="line">&#123;</span><br><span class="line">    // 发送了syn包，收到ack包说明可能是建立连接的ack包</span><br><span class="line">    if(th-&gt;ack)</span><br><span class="line">    &#123;</span><br><span class="line">        // 尝试连接但是对端回复了重置包</span><br><span class="line">        if(th-&gt;rst)</span><br><span class="line">            return tcp_std_reset(sk,skb);</span><br><span class="line">        // 建立连接的回包 </span><br><span class="line">        syn_ok=1;   </span><br><span class="line">        // 期待收到对端下一个的序列号</span><br><span class="line">        sk-&gt;acked_seq=th-&gt;seq+1;</span><br><span class="line">        sk-&gt;fin_seq=th-&gt;seq;</span><br><span class="line">        // 发送第三次握手的ack包，进入连接建立状态</span><br><span class="line">        tcp_send_ack(sk-&gt;sent_seq,sk-&gt;acked_seq,sk,th,sk-&gt;daddr);</span><br><span class="line">        tcp_set_state(sk, TCP_ESTABLISHED);</span><br><span class="line">        // 解析tcp选项</span><br><span class="line">        tcp_options(sk,th);</span><br><span class="line">        // 记录对端地址</span><br><span class="line">        sk-&gt;dummy_th.dest=th-&gt;source;</span><br><span class="line">        // 可以读取但是还没读取的序列号</span><br><span class="line">        sk-&gt;copied_seq = sk-&gt;acked_seq;</span><br><span class="line">        // 唤醒阻塞在connect函数的进程</span><br><span class="line">        if(!sk-&gt;dead)</span><br><span class="line">        &#123;</span><br><span class="line">            sk-&gt;state_change(sk);</span><br><span class="line">            sock_wake_async(sk-&gt;socket, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码完成了第二次握手。tcp_send_ack完成第三次握手。这里不打算深入分析tcp层的代码，后续再深入分析。</p>
<br>



<br>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/redis/redis-list-blpop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Focus-1">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus-1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/redis/redis-list-blpop/" itemprop="url">线上redis blpop连接超时引发的血案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-13T00:00:00+08:00">
                2020-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <br>

<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p><code>REDIS_LIST</code> （列表）是 <a href="http://redis.readthedocs.org/en/latest/list/lpush.html#lpush" target="_blank" rel="noopener">LPUSH</a> 、 <a href="http://redis.readthedocs.org/en/latest/list/lrange.html#lrange" target="_blank" rel="noopener">LRANGE</a> 等命令的操作对象， 它使用 <code>REDIS_ENCODING_ZIPLIST</code> 和 <code>REDIS_ENCODING_LINKEDLIST</code> 这两种方式编码：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200617134225.png" alt></p>
<br>

<h2 id="编码的选择"><a href="#编码的选择" class="headerlink" title="编码的选择"></a>编码的选择</h2><p>创建新列表时 Redis 默认使用 <code>REDIS_ENCODING_ZIPLIST</code> 编码， 当以下任意一个条件被满足时， 列表会被转换成 <code>REDIS_ENCODING_LINKEDLIST</code> 编码：</p>
<ul>
<li>试图往列表新添加一个字符串值，且这个字符串的长度超过 <code>server.list_max_ziplist_value</code> （默认值为 <code>64</code> ）。</li>
<li><code>ziplist</code> 包含的节点超过 <code>server.list_max_ziplist_entries</code> （默认值为 <code>512</code> ）。</li>
</ul>
<br>

<h2 id="列表命令的实现"><a href="#列表命令的实现" class="headerlink" title="列表命令的实现"></a>列表命令的实现</h2><p>因为两种底层实现的抽象方式和列表的抽象方式非常接近， 所以列表命令几乎就是通过一对一地映射到底层数据结构的操作来实现的。</p>
<p>既然这些映射都非常直观， 这里就不做赘述了， 在以下的内容中， 我们将焦点放在 <a href="http://redis.readthedocs.org/en/latest/list/blpop.html#blpop" target="_blank" rel="noopener">BLPOP</a> 、 <a href="http://redis.readthedocs.org/en/latest/list/brpop.html#brpop" target="_blank" rel="noopener">BRPOP</a> 和 <a href="http://redis.readthedocs.org/en/latest/list/brpoplpush.html#brpoplpush" target="_blank" rel="noopener">BRPOPLPUSH</a> 这个几个阻塞命令的实现原理上。</p>
<br>

<h2 id="阻塞的条件"><a href="#阻塞的条件" class="headerlink" title="阻塞的条件"></a>阻塞的条件</h2><p><a href="http://redis.readthedocs.org/en/latest/list/blpop.html#blpop" target="_blank" rel="noopener">BLPOP</a> 、 <a href="http://redis.readthedocs.org/en/latest/list/brpop.html#brpop" target="_blank" rel="noopener">BRPOP</a> 和 <a href="http://redis.readthedocs.org/en/latest/list/brpoplpush.html#brpoplpush" target="_blank" rel="noopener">BRPOPLPUSH</a> 三个命令都可能造成客户端被阻塞， 以下将这些命令统称为列表的阻塞原语。</p>
<p>阻塞原语并不是一定会造成客户端阻塞：</p>
<ul>
<li>只有当这些命令被用于空列表时， 它们才会阻塞客户端。</li>
<li>如果被处理的列表不为空的话， 它们就执行无阻塞版本的 <a href="http://redis.readthedocs.org/en/latest/list/lpop.html#lpop" target="_blank" rel="noopener">LPOP</a> 、 <a href="http://redis.readthedocs.org/en/latest/list/rpop.html#rpop" target="_blank" rel="noopener">RPOP</a> 或 <a href="http://redis.readthedocs.org/en/latest/list/rpoplpush.html#rpoplpush" target="_blank" rel="noopener">RPOPLPUSH</a> 命令。</li>
</ul>
<p>作为例子，以下流程图展示了 <a href="http://redis.readthedocs.org/en/latest/list/blpop.html#blpop" target="_blank" rel="noopener">BLPOP</a> 决定是否对客户端进行阻塞过程：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200617134244.png" alt></p>
<br>

<h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>当一个阻塞原语的处理目标为空键时， 执行该阻塞原语的客户端就会被阻塞。</p>
<p>阻塞一个客户端需要执行以下步骤：</p>
<ol>
<li>将客户端的状态设为“正在阻塞”，并记录阻塞这个客户端的各个键，以及阻塞的最长时限（timeout）等数据。</li>
<li>将客户端的信息记录到 <code>server.db[i]-&gt;blocking_keys</code> 中（其中 <code>i</code> 为客户端所使用的数据库号码）。</li>
<li>继续维持客户端和服务器之间的网络连接，但不再向客户端传送任何信息，造成客户端阻塞。</li>
</ol>
<p>步骤 2 是将来解除阻塞的关键， <code>server.db[i]-&gt;blocking_keys</code> 是一个字典， 字典的键是那些造成客户端阻塞的键， 而字典的值是一个链表， 链表里保存了所有因为这个键而被阻塞的客户端 （被同一个键所阻塞的客户端可能不止一个）：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200617134302.png" alt></p>
<p>在上图展示的 <code>blocking_keys</code> 例子中， <code>client2</code> 、 <code>client5</code> 和 <code>client1</code> 三个客户端就正被 <code>key1</code> 阻塞， 而其他几个客户端也正在被别的两个 key 阻塞。</p>
<p>当客户端被阻塞之后，脱离阻塞状态有以下三种方法：</p>
<ol>
<li>被动脱离：有其他客户端为造成阻塞的键推入了新元素。</li>
<li>主动脱离：到达执行阻塞原语时设定的最大阻塞时间。</li>
<li>强制脱离：客户端强制终止和服务器的连接，或者服务器停机。</li>
</ol>
<p>以下内容将分别介绍被动脱离和主动脱离的实现方式。</p>
<br>

<h2 id="阻塞因-LPUSH-、-RPUSH-、-LINSERT-等添加命令而被取消"><a href="#阻塞因-LPUSH-、-RPUSH-、-LINSERT-等添加命令而被取消" class="headerlink" title="阻塞因 LPUSH 、 RPUSH 、 LINSERT 等添加命令而被取消"></a>阻塞因 LPUSH 、 RPUSH 、 LINSERT 等添加命令而被取消</h2><p>通过将新元素推入造成客户端阻塞的某个键中， 可以让相应的客户端从阻塞状态中脱离出来 （取消阻塞的客户端数量取决于推入元素的数量）。</p>
<p><a href="http://redis.readthedocs.org/en/latest/list/lpush.html#lpush" target="_blank" rel="noopener">LPUSH</a> 、 <a href="http://redis.readthedocs.org/en/latest/list/rpush.html#rpush" target="_blank" rel="noopener">RPUSH</a> 和 <a href="http://redis.readthedocs.org/en/latest/list/linsert.html#linsert" target="_blank" rel="noopener">LINSERT</a> 这三个添加新元素到列表的命令， 在底层都由一个 <code>pushGenericCommand</code> 的函数实现， 这个函数的运作流程如下图：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200617134319.png" alt></p>
<p>当向一个空键推入新元素时， <code>pushGenericCommand</code> 函数执行以下两件事：</p>
<ol>
<li>检查这个键是否存在于前面提到的 <code>server.db[i]-&gt;blocking_keys</code> 字典里， 如果是的话， 那么说明有至少一个客户端因为这个 key 而被阻塞，程序会为这个键创建一个 <code>redis.h/readyList</code> 结构， 并将它添加到 <code>server.ready_keys</code> 链表中。</li>
<li>将给定的值添加到列表键中。</li>
</ol>
<p><code>readyList</code> 结构的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">readyList</span> &#123;</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">    robj *key;</span><br><span class="line">&#125; readyList;</span><br></pre></td></tr></table></figure>

<p><code>readyList</code> 结构的 <code>key</code> 属性指向造成阻塞的键，而 <code>db</code> 则指向该键所在的数据库。</p>
<p>举个例子， 假设某个非阻塞客户端正在使用 <code>0</code> 号数据库， 而这个数据库当前的 <code>blocking_keys</code> 属性的值如下：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200617134338.png" alt></p>
<p>如果这时客户端对该数据库执行 <code>PUSH key3 value</code> ， 那么 <code>pushGenericCommand</code> 将创建一个 <code>db</code> 属性指向 <code>0</code> 号数据库、 <code>key</code> 属性指向 <code>key3</code> 键对象的 <code>readyList</code> 结构 ， 并将它添加到服务器 <code>server.ready_keys</code> 属性的链表中：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200617134353.png" alt></p>
<p>在我们这个例子中， 到目前为止， <code>pushGenericCommand</code> 函数完成了以下两件事：</p>
<ol>
<li>将 <code>readyList</code> 添加到服务器。</li>
<li>将新元素 <code>value</code> 添加到键 <code>key3</code> 。</li>
</ol>
<p>虽然 <code>key3</code> 已经不再是空键， 但到目前为止， 被 <code>key3</code> 阻塞的客户端还没有任何一个被解除阻塞状态。</p>
<p>为了做到这一点， Redis 的主进程在执行完 <code>pushGenericCommand</code> 函数之后， 会继续调用 <code>handleClientsBlockedOnLists</code> 函数， 这个函数执行以下操作：</p>
<ol>
<li>如果 <code>server.ready_keys</code> 不为空，那么弹出该链表的表头元素，并取出元素中的 <code>readyList</code> 值。</li>
<li>根据 <code>readyList</code> 值所保存的 <code>key</code> 和 <code>db</code> ，在 <code>server.blocking_keys</code> 中查找所有因为 <code>key</code> 而被阻塞的客户端（以链表的形式保存）。</li>
<li>如果 <code>key</code> 不为空，那么从 <code>key</code> 中弹出一个元素，并弹出客户端链表的第一个客户端，然后将被弹出元素返回给被弹出客户端作为阻塞原语的返回值。</li>
<li>根据 <code>readyList</code> 结构的属性，删除 <code>server.blocking_keys</code> 中相应的客户端数据，取消客户端的阻塞状态。</li>
<li>继续执行步骤 3 和 4 ，直到 <code>key</code> 没有元素可弹出，或者所有因为 <code>key</code> 而阻塞的客户端都取消阻塞为止。</li>
<li>继续执行步骤 1 ，直到 <code>ready_keys</code> 链表里的所有 <code>readyList</code> 结构都被处理完为止。</li>
</ol>
<p>用一段伪代码描述以上操作可能会更直观一些：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def handleClientsBlockedOnLists():</span><br><span class="line"></span><br><span class="line">    # 执行直到 ready_keys 为空</span><br><span class="line">    <span class="keyword">while</span> server.ready_keys != <span class="literal">NULL</span>:</span><br><span class="line"></span><br><span class="line">        # 弹出链表中的第一个 readyList</span><br><span class="line">        rl = server.ready_keys.pop_first_node()</span><br><span class="line"></span><br><span class="line">        # 遍历所有因为这个键而被阻塞的客户端</span><br><span class="line">        <span class="keyword">for</span> client in all_client_blocking_by_key(rl.key, rl.db):</span><br><span class="line"></span><br><span class="line">            # 只要还有客户端被这个键阻塞，就一直从键中弹出元素</span><br><span class="line">            # 如果被阻塞客户端执行的是 BLPOP ，那么对键执行 LPOP</span><br><span class="line">            # 如果执行的是 BRPOP ，那么对键执行 RPOP</span><br><span class="line">            element = rl.key.pop_element()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> element == <span class="literal">NULL</span>:</span><br><span class="line">                # 键为空，跳出 <span class="keyword">for</span> 循环</span><br><span class="line">                # 余下的未解除阻塞的客户端只能等待下次新元素的进入了</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                # 清除客户端的阻塞信息</span><br><span class="line">                server.blocking_keys.remove_blocking_info(client)</span><br><span class="line">                # 将元素返回给客户端，脱离阻塞状态</span><br><span class="line">                client.reply_list_item(element)</span><br></pre></td></tr></table></figure>

<br>

<h2 id="先阻塞先服务（FBFS）策略"><a href="#先阻塞先服务（FBFS）策略" class="headerlink" title="先阻塞先服务（FBFS）策略"></a>先阻塞先服务（FBFS）策略</h2><p>值得一提的是， 当程序添加一个新的被阻塞客户端到 <code>server.blocking_keys</code> 字典的链表中时， 它将该客户端放在链表的最后， 而当 <code>handleClientsBlockedOnLists</code> 取消客户端的阻塞时， 它从链表的最前面开始取消阻塞： 这个链表形成了一个 FIFO 队列， 最先被阻塞的客户端总是最先脱离阻塞状态， Redis 文档称这种模式为先阻塞先服务（FBFS，first-block-first-serve）。</p>
<p>举个例子，在下图所示的阻塞状况中， 如果客户端对数据库执行 <code>PUSH key3 value</code> ， 那么只有 <code>client3</code> 会被取消阻塞， <code>client6</code> 和 <code>client4</code> 仍然阻塞； 如果客户端对数据库执行 <code>PUSH key3 value1 value2</code> ， 那么 <code>client3</code> 和 <code>client4</code> 的阻塞都会被取消， 而客户端 <code>client6</code> 依然处于阻塞状态：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200617134413.png" alt></p>
<br>

<h2 id="阻塞因超过最大等待时间而被取消"><a href="#阻塞因超过最大等待时间而被取消" class="headerlink" title="阻塞因超过最大等待时间而被取消"></a>阻塞因超过最大等待时间而被取消</h2><p>前面提到过， 当客户端被阻塞时， 所有造成它阻塞的键， 以及阻塞的最长时限会被记录在客户端里面， 并且该客户端的状态会被设置为“正在阻塞”。</p>
<p>每次 Redis 服务器常规操作函数（server cron job）执行时， 程序都会检查所有连接到服务器的客户端， 查看那些处于“正在阻塞”状态的客户端的最大阻塞时限是否已经过期， 如果是的话， 就给客户端返回一个空白回复， 然后撤销对客户端的阻塞。</p>
<p>可以用一段伪代码来描述这个过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def server_cron_job():</span><br><span class="line"></span><br><span class="line">    # 其他操作 ...</span><br><span class="line"></span><br><span class="line">    # 遍历所有已连接客户端</span><br><span class="line">    for client in server.all_connected_client:</span><br><span class="line"></span><br><span class="line">        # 如果客户端状态为“正在阻塞”，并且最大阻塞时限已到达</span><br><span class="line">        if client.state == BLOCKING and \</span><br><span class="line">           client.max_blocking_timestamp &lt; current_timestamp():</span><br><span class="line"></span><br><span class="line">            # 那么给客户端发送空回复,脱离阻塞状态</span><br><span class="line">            client.send_empty_reply()</span><br><span class="line"></span><br><span class="line">            # 并清除客户端在服务器上的阻塞信息</span><br><span class="line">            server.blocking_keys.remove_blocking_info(client)</span><br><span class="line"></span><br><span class="line">    # 其他操作 ...</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/flink/flink-on-k8s/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Focus-1">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus-1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/flink/flink-on-k8s/" itemprop="url">Flink on K8s 部署</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-05T00:00:00+08:00">
                2020-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flink/" itemprop="url" rel="index">
                    <span itemprop="name">flink</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <br>

<blockquote>
<p>参考文档：</p>
</blockquote>
<blockquote>
<p>官网文档：</p>
<p><a href="https://ci.apache.org/projects/flink/flink-docs-stable/zh/ops/deployment/kubernetes.html" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-stable/zh/ops/deployment/kubernetes.html</a></p>
<p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/zh/ops/deployment/native_kubernetes.html" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-release-1.11/zh/ops/deployment/native_kubernetes.html</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/computer-network/tcpdump-tcp-3-and-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Focus-1">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus-1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/computer-network/tcpdump-tcp-3-and-4/" itemprop="url">TCP三次握手与Tcpdump抓包分析过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-22T14:51:54+08:00">
                2020-03-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<br>

<h2 id="一、TCP连接建立（三次握手）"><a href="#一、TCP连接建立（三次握手）" class="headerlink" title="一、TCP连接建立（三次握手）"></a>一、TCP连接建立（三次握手）</h2><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a><em>过程</em></h4><p>客户端A，服务器B，初始序号seq，确认号ack</p>
<p>初始状态：B处于监听状态，A处于打开状态</p>
<ul>
<li>A -&gt; B : seq = x （A向B发送连接请求报文段，A进入同步发送状态SYN-SENT）</li>
<li>B -&gt; A : ack = x + 1,seq = y （B收到报文段，向A发送确认，B进入同步收到状态SYN-RCVD）</li>
<li>A -&gt; B : ack = y+1 （A收到B的确认后，再次确认，A进入连接状态ESTABLISHED）</li>
</ul>
<p>连接后的状态：B收到A的确认后，进入连接状态ESTABLISHED</p>
<h4 id="为什么要握手要三次"><a href="#为什么要握手要三次" class="headerlink" title="为什么要握手要三次"></a><em>为什么要握手要三次</em></h4><p>防止失效的连接请求突然传到服务器端，让服务器端误认为要建立连接。</p>
<h2 id="二、TCP连接释放（四次挥手）"><a href="#二、TCP连接释放（四次挥手）" class="headerlink" title="二、TCP连接释放（四次挥手）"></a>二、TCP连接释放（四次挥手）</h2><h4 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a><em>过程</em></h4><p>A -&gt; B : seq = u （A发出连接释放报文段，进入终止等待1状态FIN-WAIT-1）</p>
<p>B -&gt; A : ack = u + 1,seq = v （B收到报文段，发出确认，TCP处于半关闭，B还可向A发数据，B进入关闭等待状态WAIT）</p>
<p>B -&gt; A : ack = u + 1,seq = w （B重复发送确认号，进入最后确认状态LAST-ACK）</p>
<p>A -&gt; B : ack = w + 1,seq = u + 1 （A发出确认，进入时间等待状态TIME-WAIT）</p>
<p>经过时间等待计时器设置的时间2MSL后，A才进入CLOSED状态</p>
<h4 id="为什么A进入TIME-WAIT后必须等待2MSL"><a href="#为什么A进入TIME-WAIT后必须等待2MSL" class="headerlink" title="为什么A进入TIME-WAIT后必须等待2MSL"></a><em>为什么A进入TIME-WAIT后必须等待2MSL</em></h4><ul>
<li>保证A发送的最后一个ACK报文段能达到B</li>
<li>防止失效的报文段出现在连接中</li>
</ul>
<h2 id="三、需要思考的问题"><a href="#三、需要思考的问题" class="headerlink" title="三、需要思考的问题"></a>三、需要思考的问题</h2><p>问题1: 请详细描述三次握手和四次挥手的过程<br>要求熟悉三次握手和四次挥手的机制，要求画出状态图。</p>
<p>问题2: 四次挥手中TIME_WAIT状态存在的目的是什么?<br>这个问题是画出四次挥手状态图，会引申问你。不排除还会问为什么四次挥手是四次不是二次等问题。最好是把相关问题均掌握。</p>
<p>问题3: TCP是通过什么机制保障可靠性的?<br>从四个方面进行回答，ACK确认机制、超时重传、滑动窗口以及流量控制，深入的话要求详细讲出流量控制的机制。</p>
<h2 id="四、Tcpdump使用"><a href="#四、Tcpdump使用" class="headerlink" title="四、Tcpdump使用"></a>四、Tcpdump使用</h2><p>tcpdump是对网络上的数据包进行截获的包分析工具，它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来去掉无用的信息。</p>
<h4 id="监视指定主机的数据包"><a href="#监视指定主机的数据包" class="headerlink" title="监视指定主机的数据包"></a><em>监视指定主机的数据包</em></h4><p><code>tcpdump host</code>：截获该IP的主机收到的和发出的所有的数据包<br><code>tcpdump host  and</code>：截获两个IP对应主机之间的通信</p>
<h4 id="监视指定端口的数据包"><a href="#监视指定端口的数据包" class="headerlink" title="监视指定端口的数据包"></a><em>监视指定端口的数据包</em></h4><p><code>tcpdump port &lt;端口号&gt;</code>：截获本机80端口的数据包</p>
<h2 id="五、抓包分析握手过程"><a href="#五、抓包分析握手过程" class="headerlink" title="五、抓包分析握手过程"></a>五、抓包分析握手过程</h2><p>抓包方法：首先使用tcpdump命令截获本机与某远程主机的数据包，然后打开某远程主机对应的网站，这里用我的域名<code>www.fonxian.cn</code>来做试验。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyping www.fonxian.cn</span><br></pre></td></tr></table></figure>

<p>得到域名对应的ip：<code>151.101.100.133</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyifconfg</span><br></pre></td></tr></table></figure>

<p>得到本机内网ip：<code>192.168.0.108</code></p>
<p>-S 参数的目的是获得ack的绝对值，不加该参数，第三次握手的ack为相对值1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copysudo tcpdump -S host 192.168.0.108 and 151.101.100.133</span><br></pre></td></tr></table></figure>

<p>得到下图<br><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200322152925.png" alt></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Focus-1</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">228</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">57</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">98</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://gitee.com/carloz" title="repository - https://gitee.com/carloz" target="_blank">repository - https://gitee.com/carloz</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Focus-1</span>

  
</div>








  <div class="footer-custom">Hosted by <a target="_blank" href="https://gitee.com/carloz">Gitee Repo</a></div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
