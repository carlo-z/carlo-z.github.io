<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  
    
      
    

    
  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=consolas:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="keywords" content="Java Kafka Docker JVM NIO Netty">
<meta property="og:type" content="website">
<meta property="og:title" content="Focus-1">
<meta property="og:url" content="https://carlo-z.com/page/2/index.html">
<meta property="og:site_name" content="Focus-1">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Focus-1">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://carlo-z.com/page/2/">





  <title>Focus-1</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Focus-1</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/big-data/flink/flink-7-days/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Focus-1">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus-1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/big-data/flink/flink-7-days/" itemprop="url">Flink-1.11 7天训练营</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-13T00:00:00+08:00">
                2020-07-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flink/" itemprop="url" rel="index">
                    <span itemprop="name">flink</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200713200643.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200713200939.png" alt></p>
<blockquote>
<p><a href="https://flink-learning.org.cn/" target="_blank" rel="noopener">https://flink-learning.org.cn/</a></p>
</blockquote>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200713201233.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200713202324.png" alt></p>
<blockquote>
<p>CDC：在数据迁移场景非常实用</p>
<p>PyFink：提升对Pandas UDF的支持，扩展python在支持分布式上的能力</p>
</blockquote>
<h1 id="1-1、流批的本质"><a href="#1-1、流批的本质" class="headerlink" title="1.1、流批的本质"></a>1.1、流批的本质</h1><p>有界的数据是批，无界的数据是流</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200713203039.png" alt></p>
<p>海量数据处理三辆马车</p>
<blockquote>
<ul>
<li><p>GFS</p>
</li>
<li><p>BigTable</p>
</li>
<li><p>MapReduce</p>
</li>
</ul>
</blockquote>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200713203610.png" alt></p>
<p>对应的开源框架</p>
<blockquote>
<ul>
<li>Hadoop</li>
</ul>
</blockquote>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200713203816.png" alt></p>
<p>流与批的区别：业务延时的不同</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200713204053.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200713204121.png" alt></p>
<p>流是批的特例，Flink（Native-Streaming）</p>
<p>批是流的特例，Spark（Micro-Batching）</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200713204428.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200713204622.png" alt></p>
<h1 id="1-2、流计算的核心问题"><a href="#1-2、流计算的核心问题" class="headerlink" title="1.2、流计算的核心问题"></a>1.2、流计算的核心问题</h1><p>问题：</p>
<ul>
<li>延问题</li>
<li>更新撤回：</li>
<li>容错续跑：机器故障以后，可以继续跑</li>
<li>透明升级：某个Job升级以后，可以继续前面的任务跑</li>
<li>乱序问题：数据到达顺序问题</li>
<li>正确性问题：</li>
<li>部署问题</li>
<li>弹性扩容问题</li>
</ul>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200713210210.png" alt></p>
<h3 id="延时问题"><a href="#延时问题" class="headerlink" title="延时问题"></a>延时问题</h3><p>Native Stream + Early-Fire</p>
<h3 id="更新撤回"><a href="#更新撤回" class="headerlink" title="更新撤回"></a>更新撤回</h3><p>告诉下游节点上一次计算结果无效</p>
<p>使用”-“标记上一次计算结果失效</p>
<h3 id="容错续跑"><a href="#容错续跑" class="headerlink" title="容错续跑"></a>容错续跑</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200713205658.png" alt></p>
<h3 id="透明升级"><a href="#透明升级" class="headerlink" title="透明升级"></a>透明升级</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200713205820.png" alt></p>
<h3 id="乱序问题"><a href="#乱序问题" class="headerlink" title="乱序问题"></a>乱序问题</h3><p>数据产生时间 EventTime</p>
<p>数据进入流计算引擎的时间 Watermark</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200713205851.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200713210006.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200713210019.png" alt></p>
<h3 id="正确性问题"><a href="#正确性问题" class="headerlink" title="正确性问题"></a>正确性问题</h3><ul>
<li>数据是否有丢失</li>
<li>数据是否只参与了一次计算</li>
</ul>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200713210141.png" alt></p>
<h1 id="1-3、Flink应用场景"><a href="#1-3、Flink应用场景" class="headerlink" title="1.3、Flink应用场景"></a>1.3、Flink应用场景</h1><h3 id="事件驱动型应用"><a href="#事件驱动型应用" class="headerlink" title="事件驱动型应用"></a>事件驱动型应用</h3><p>社交：关注事件 引发的 后续操作</p>
<p>网购：恶意差评事件 -&gt; 封号</p>
<p>金融：欺诈 -&gt; 反欺诈</p>
<h3 id="数据分析型应用"><a href="#数据分析型应用" class="headerlink" title="数据分析型应用"></a>数据分析型应用</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200713210551.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200713210604.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200713210630.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200713210918.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200713211006.png" alt></p>
<h3 id="数据管道型应用"><a href="#数据管道型应用" class="headerlink" title="数据管道型应用"></a>数据管道型应用</h3><p>数据清洗</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200713211035.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200713211122.png" alt></p>
<h1 id="1-4、怎样理解流批一体融合？"><a href="#1-4、怎样理解流批一体融合？" class="headerlink" title="1.4、怎样理解流批一体融合？"></a>1.4、怎样理解流批一体融合？</h1><p>用户、运行、运维 三个维度看</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200713211428.png" alt></p>
<br>

<blockquote>
<p>第二章  Stream Process 在 Flink 的实现</p>
</blockquote>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200714200322.png" alt></p>
<h1 id="2-1、并行处理和编程范式"><a href="#2-1、并行处理和编程范式" class="headerlink" title="2.1、并行处理和编程范式"></a>2.1、并行处理和编程范式</h1><p>任务划分 类似 有向无环图（DAG）的</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200714200655.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200714200902.png" alt></p>
<br>

<h1 id="2-2、DataStream-API-概览"><a href="#2-2、DataStream-API-概览" class="headerlink" title="2.2、DataStream API 概览"></a>2.2、DataStream API 概览</h1><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200714201543.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200714201737.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200714202101.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200714202417.png" alt></p>
<p>批处理 的数据分区类似于洗牌，将相关的牌放在一起</p>
<p>流处理 分区是随着数据的到来 动态完成的</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200714202903.png" alt></p>
<br>

<h1 id="2-3、状态和时间"><a href="#2-3、状态和时间" class="headerlink" title="2.3、状态和时间"></a>2.3、状态和时间</h1><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200714203949.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200714204300.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200714204324.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200714205046.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200714205334.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200714205717.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200714205920.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200714210302.png" alt></p>
<p>时间的使用案例：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200714210618.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200714211126.png" alt></p>
<p>运行结果：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200714211150.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200714211323.png" alt></p>
<p>作业框架，基于框架进行开发</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200714211424.png" alt></p>
<blockquote>
<p>【Stream Processing with Apache Flink】<br>讲师：崔星灿，Apache Flink Committer<br>时间：7月14日 20:00-21:00（UTC+8）<br>【作业内容】<br>- 准备环境：能clone和运行源码中的streaming-examples<br>- 下载地址：<a href="https://github.com/flink-china/Flink-Geek-Training/blob/master/Training2.java" target="_blank" rel="noopener">https://github.com/flink-china/Flink-Geek-Training/blob/master/Training2.java</a></p>
</blockquote>
<blockquote>
<h1 id="第三章-运行时架构"><a href="#第三章-运行时架构" class="headerlink" title="第三章  运行时架构"></a>第三章  运行时架构</h1></blockquote>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200715200212.png" alt></p>
<h1 id="3-1-、Runtime-总览"><a href="#3-1-、Runtime-总览" class="headerlink" title="3.1 、Runtime 总览"></a>3.1 、Runtime 总览</h1><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200715200313.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200715200358.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200715200444.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200715200638.png" alt></p>
<p>三大核心组件</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200715200804.png" alt></p>
<h1 id="3-2、-JobMaster-—-作业的控制中心"><a href="#3-2、-JobMaster-—-作业的控制中心" class="headerlink" title="3.2、 JobMaster — 作业的控制中心"></a>3.2、 JobMaster — 作业的控制中心</h1><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200715200850.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200715200925.png" alt></p>
<p>Lost Leadership：JobMaster出问题了，异常终止</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200715201244.png" alt></p>
<ul>
<li>Eager：服务于流式处理作业，节省调度花费的时间；</li>
<li>Lazy from sources：服务于批处理作业，延迟下游资源的调度，避免空转浪费资源；</li>
<li>（WIP）Piplined region based：类似Lazy from sources，既能减少调度时间，又能避免空转浪费资源；</li>
</ul>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200715201707.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200715201828.png" alt></p>
<p>出错恢复策略 与 Pipiline 有关，出错后，会重新pipline里相关的任务</p>
<p>单点重启：只重启出错的节点，接下来的版本会牺牲数据一致性来实现</p>
<h1 id="3-3、TaskExecutor-—-任务的运行容器"><a href="#3-3、TaskExecutor-—-任务的运行容器" class="headerlink" title="3.3、TaskExecutor — 任务的运行容器"></a>3.3、TaskExecutor — 任务的运行容器</h1><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200715202303.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200715202437.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200715202658.png" alt></p>
<h1 id="3-4、ResourceManager-—-资源管理中心"><a href="#3-4、ResourceManager-—-资源管理中心" class="headerlink" title="3.4、ResourceManager — 资源管理中心"></a>3.4、ResourceManager — 资源管理中心</h1><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200715202945.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200715203107.png" alt></p>
<blockquote>
<h1 id="第四章-流计算的状态-和-容错机制"><a href="#第四章-流计算的状态-和-容错机制" class="headerlink" title="第四章 流计算的状态 和 容错机制"></a>第四章 流计算的状态 和 容错机制</h1></blockquote>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716200200932.png" alt="image-20200716200200932"></p>
<h1 id="4-1、流计算中的状态"><a href="#4-1、流计算中的状态" class="headerlink" title="4.1、流计算中的状态"></a>4.1、流计算中的状态</h1><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716200250682.png" alt="image-20200716200250682"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716200312772.png" alt="image-20200716200312772"></p>
<p>状态的种类</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716200409713.png" alt="image-20200716200409713"></p>
<h1 id="4-2、全局一致性快照"><a href="#4-2、全局一致性快照" class="headerlink" title="4.2、全局一致性快照"></a>4.2、全局一致性快照</h1><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716200607500.png" alt="image-20200716200607500"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716200646009.png" alt="image-20200716200646009"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716200750995.png" alt="image-20200716200750995"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716200802778.png" alt="image-20200716200802778"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716200820377.png" alt="image-20200716200820377"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716200841587.png" alt="image-20200716200841587"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716200853493.png" alt="image-20200716200853493"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716200917606.png" alt="image-20200716200917606"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716201129405.png" alt="image-20200716201129405"></p>
<p>第三张图，后发生的事件包含在快照中，而 先发生的事件没有包含在快照中，所以不是 全局一致性快照</p>
<h3 id="全局一致性快照的实现方法"><a href="#全局一致性快照的实现方法" class="headerlink" title="全局一致性快照的实现方法"></a>全局一致性快照的实现方法</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716201228005.png" alt="image-20200716201228005"></p>
<h3 id="异步全局一致性快照算法"><a href="#异步全局一致性快照算法" class="headerlink" title="异步全局一致性快照算法"></a>异步全局一致性快照算法</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716201340717.png" alt="image-20200716201340717"></p>
<h3 id="Chandy-Lamport-算法流程"><a href="#Chandy-Lamport-算法流程" class="headerlink" title="Chandy-Lamport 算法流程"></a>Chandy-Lamport 算法流程</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716201546854.png" alt="image-20200716201546854"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716201626532.png" alt="image-20200716201626532"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716201705995.png" alt="image-20200716201705995"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716201828963.png" alt="image-20200716201828963"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716201906814.png" alt="image-20200716201906814"></p>
<blockquote>
<ul>
<li><p>实线代表： 开始快照</p>
</li>
<li><p>虚线代表：结束快照</p>
</li>
</ul>
</blockquote>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716201951707.png" alt="image-20200716201951707"></p>
<blockquote>
<p>A 是自己内部发生的事件，与其他进程没有交互，我们认为是P1自己发给自己的消息</p>
</blockquote>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716202052420.png" alt="image-20200716202052420"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716202431456.png" alt="image-20200716202431456"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716202607990.png" alt="image-20200716202607990"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716202642596.png" alt="image-20200716202642596"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716202745563.png" alt="image-20200716202745563"></p>
<h1 id="4-3、Flink的容错机制"><a href="#4-3、Flink的容错机制" class="headerlink" title="4.3、Flink的容错机制"></a>4.3、Flink的容错机制</h1><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716202912845.png" alt="image-20200716202912845"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716203051341.png" alt="image-20200716203051341"></p>
<h3 id="如何保证-Exactly-once"><a href="#如何保证-Exactly-once" class="headerlink" title="如何保证 Exactly once"></a>如何保证 Exactly once</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716203210314.png" alt="image-20200716203210314"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716203253683.png" alt="image-20200716203253683"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716203333331.png" alt="image-20200716203333331"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716203420995.png" alt="image-20200716203420995"></p>
<p>需要一个可回退的 source</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716203552923.png" alt="image-20200716203552923"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716203613350.png" alt="image-20200716203613350"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716203644925.png" alt="image-20200716203644925"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716203724010.png" alt="image-20200716203724010"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716203736339.png" alt="image-20200716203736339"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716203820235.png" alt="image-20200716203820235"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716203833549.png" alt="image-20200716203833549"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716203903355.png" alt="image-20200716203903355"></p>
<h3 id="复杂场景-——-多流输入"><a href="#复杂场景-——-多流输入" class="headerlink" title="复杂场景 —— 多流输入"></a>复杂场景 —— 多流输入</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716203924914.png" alt="image-20200716203924914"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716204032401.png" alt="image-20200716204032401"></p>
<h3 id="降低一致性要求"><a href="#降低一致性要求" class="headerlink" title="降低一致性要求"></a>降低一致性要求</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716204129003.png" alt="image-20200716204129003"></p>
<h3 id="通过异步快照减少停顿"><a href="#通过异步快照减少停顿" class="headerlink" title="通过异步快照减少停顿"></a>通过异步快照减少停顿</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716204233398.png" alt="image-20200716204233398"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716204300765.png" alt="image-20200716204300765"></p>
<h1 id="4-4、Flink的状态管理"><a href="#4-4、Flink的状态管理" class="headerlink" title="4.4、Flink的状态管理"></a>4.4、Flink的状态管理</h1><p>定义一个状态</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716204431783.png" alt="image-20200716204431783"></p>
<h3 id="本地状态后端-JVM"><a href="#本地状态后端-JVM" class="headerlink" title="本地状态后端 JVM"></a>本地状态后端 JVM</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716204532637.png" alt="image-20200716204532637"></p>
<p>形成快照的过程需要序列化</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716204617562.png" alt="image-20200716204617562"></p>
<p>优点：</p>
<p>缺点：</p>
<h3 id="RocksDB-作为状态后端"><a href="#RocksDB-作为状态后端" class="headerlink" title="RocksDB 作为状态后端"></a>RocksDB 作为状态后端</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200716204650349.png" alt="image-20200716204650349"></p>
<blockquote>
<p>第5章 Flink SQL/Table API 介绍与实战</p>
</blockquote>
<h1 id="5-1、Flink-SQL"><a href="#5-1、Flink-SQL" class="headerlink" title="5.1、Flink SQL"></a>5.1、Flink SQL</h1><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200720200343349.png" alt="image-20200720200343349"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200720200452430.png" alt="image-20200720200452430"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200720200603307.png" alt="image-20200720200603307"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200720200637851.png" alt="image-20200720200637851"></p>
<blockquote>
<p>声明式：用户只需要表达他需要什么，不需要关心怎么计算的</p>
<p>批流统一：SQL很容易做批处理，不管输入是静态的批数据，还是动态的流数据，结果是相同的</p>
</blockquote>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200720201022093.png" alt="image-20200720201022093"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200720201053908.png" alt="image-20200720201053908"></p>
<p>sql/python/scala/java 的api 被翻译成 Logical Plan，Logical Plan 被优化器 优化成 Physical Plan，然后翻译成 Transformations 的DAG，再交给 JobGraph 执行</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200720201610387.png" alt="image-20200720201610387"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200720201632007.png" alt="image-20200720201632007"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200720201800339.png" alt="image-20200720201800339"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200720202012650.png" alt="image-20200720202012650"></p>
<ul>
<li>完整的类型系统：数据的精度</li>
<li>TopN：</li>
<li>高效流式去重：在明细层去重，交给汇总层的时候才会精确</li>
<li>维表关联：Mysql、hive、hbase</li>
<li>cdc：对接canal等 binlog的数据</li>
<li>内聚函数：超过230个内置函数</li>
<li>MiniBash：</li>
<li>多种解热点手段：</li>
<li>完整的批处理支持</li>
<li>Python Table API：多语言支持</li>
<li>Hive集成：读写hive，支持hive sql 语法</li>
</ul>
<h1 id="5-3-实战Demo"><a href="#5-3-实战Demo" class="headerlink" title="5.3 实战Demo"></a>5.3 实战Demo</h1><blockquote>
<ul>
<li>前提条件：需要基础的 SQL 知识</li>
<li>准备环境：你将需要一个至少 8 GB 内存和安装了 Docker 的笔记本电脑。</li>
<li>下载地址：<a href="https://www.docker.com/get-started" target="_blank" rel="noopener">https://www.docker.com/get-started</a></li>
<li>代码：<a href="https://github.com/wuchong/flink-sql-demo" target="_blank" rel="noopener">https://github.com/wuchong/flink-sql-demo</a></li>
</ul>
</blockquote>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200720202852081.png" alt="image-20200720202852081"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200720203132655.png" alt="image-20200720203132655"></p>
<blockquote>
<h1 id><a href="#" class="headerlink" title></a><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721200138591.png" alt="image-20200721200138591"></h1></blockquote>
<h1 id="6-1、PyFlink简介"><a href="#6-1、PyFlink简介" class="headerlink" title="6.1、PyFlink简介"></a>6.1、PyFlink简介</h1><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721200238230.png" alt="image-20200721200238230"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721200317347.png" alt="image-20200721200317347"></p>
<h1 id="6-2、PyFlink-功能介绍"><a href="#6-2、PyFlink-功能介绍" class="headerlink" title="6.2、PyFlink 功能介绍"></a>6.2、PyFlink 功能介绍</h1><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721200433960.png" alt="image-20200721200433960"></p>
<h3 id="Python-Table-API"><a href="#Python-Table-API" class="headerlink" title="Python Table API"></a>Python Table API</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721200528095.png" alt="image-20200721200528095"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721200555569.png" alt="image-20200721200555569"></p>
<h3 id="Python-UDF"><a href="#Python-UDF" class="headerlink" title="Python UDF"></a>Python UDF</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721200757824.png" alt="image-20200721200757824"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721200829706.png" alt="image-20200721200829706"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721200947562.png" alt="image-20200721200947562"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721201100801.png" alt="image-20200721201100801"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721201214906.png" alt="image-20200721201214906"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721201243319.png" alt="image-20200721201243319"></p>
<h3 id="Python-UDF-架构"><a href="#Python-UDF-架构" class="headerlink" title="Python UDF 架构"></a>Python UDF 架构</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721201303544.png" alt="image-20200721201303544"></p>
<h3 id="向量化-Python-UDF"><a href="#向量化-Python-UDF" class="headerlink" title="向量化 Python UDF"></a>向量化 Python UDF</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721201510167.png" alt="image-20200721201510167"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721201749289.png" alt="image-20200721201749289"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721201832130.png" alt="image-20200721201832130"></p>
<h3 id="Python-UDF-Metrics"><a href="#Python-UDF-Metrics" class="headerlink" title="Python UDF Metrics"></a>Python UDF Metrics</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721201924057.png" alt="image-20200721201924057"></p>
<h3 id="Python-UDF-执行优化"><a href="#Python-UDF-执行优化" class="headerlink" title="Python UDF 执行优化"></a>Python UDF 执行优化</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721202223408.png" alt="image-20200721202223408"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721202333290.png" alt="image-20200721202333290"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721202503852.png" alt="image-20200721202503852"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721202725547.png" alt="image-20200721202725547"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721203032114.png" alt="image-20200721203032114"></p>
<h1 id="6-4、PyFlink-下一步规划"><a href="#6-4、PyFlink-下一步规划" class="headerlink" title="6.4、PyFlink 下一步规划"></a>6.4、PyFlink 下一步规划</h1><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721204636836.png" alt="image-20200721204636836"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721204650121.png" alt="image-20200721204650121"></p>
<blockquote>
<h1 id="第七章-Flink-Ecosystems-连接外部生态系统"><a href="#第七章-Flink-Ecosystems-连接外部生态系统" class="headerlink" title="第七章 Flink Ecosystems 连接外部生态系统"></a>第七章 Flink Ecosystems 连接外部生态系统</h1></blockquote>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200722200114683.png" alt="image-20200722200114683"></p>
<h1 id="7-1、连接外部系统"><a href="#7-1、连接外部系统" class="headerlink" title="7.1、连接外部系统"></a>7.1、连接外部系统</h1><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200722200158643.png" alt="image-20200722200158643"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200722200413181.png" alt="image-20200722200413181"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200722200637803.png" alt="image-20200722200637803"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200722200820196.png" alt="image-20200722200820196"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200722201019059.png" alt="image-20200722201019059"></p>
<p>通过DDL创建的表是如何被使用的：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200722202915839.png" alt="image-20200722202915839"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200722203115852.png" alt="image-20200722203115852"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200722203306803.png" alt="image-20200722203306803"></p>
<h1 id="7-2、常用Connector"><a href="#7-2、常用Connector" class="headerlink" title="7.2、常用Connector"></a>7.2、常用Connector</h1><h3 id="Kafka-Connector"><a href="#Kafka-Connector" class="headerlink" title="Kafka Connector"></a>Kafka Connector</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200722203424868.png" alt="image-20200722203424868"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200722203532459.png" alt="image-20200722203532459"></p>
<h3 id="Elasticsearch-Connector"><a href="#Elasticsearch-Connector" class="headerlink" title="Elasticsearch Connector"></a>Elasticsearch Connector</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200722203615315.png" alt="image-20200722203615315"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200722203718720.png" alt="image-20200722203718720"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200722203848626.png" alt="image-20200722203848626"></p>
<h3 id="FileSystem-Connector"><a href="#FileSystem-Connector" class="headerlink" title="FileSystem Connector"></a>FileSystem Connector</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200722203905251.png" alt="image-20200722203905251"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200722204138417.png" alt="image-20200722204138417"></p>
<h3 id="Hive-Connector"><a href="#Hive-Connector" class="headerlink" title="Hive Connector"></a>Hive Connector</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200722204243916.png" alt="image-20200722204243916"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200722204529258.png" alt="image-20200722204529258"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200722204547859.png" alt="image-20200722204547859"></p>
<h3 id="DataGen-Connector"><a href="#DataGen-Connector" class="headerlink" title="DataGen Connector"></a>DataGen Connector</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200722204616306.png" alt="image-20200722204616306"></p>
<h3 id="Print-Connector"><a href="#Print-Connector" class="headerlink" title="Print Connector"></a>Print Connector</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200722204830315.png" alt="image-20200722204830315"></p>
<h3 id="BlackHole-Connector"><a href="#BlackHole-Connector" class="headerlink" title="BlackHole Connector"></a>BlackHole Connector</h3><p>可以做性能测试，数据来了以后不做任何处理，直接丢弃</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200722204913818.png" alt="image-20200722204913818"></p>
<h1 id="7-3、示例-amp-Demo"><a href="#7-3、示例-amp-Demo" class="headerlink" title="7.3、示例 &amp; Demo"></a>7.3、示例 &amp; Demo</h1><h3 id="kafka交互"><a href="#kafka交互" class="headerlink" title="kafka交互"></a>kafka交互</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200722205008282.png" alt="image-20200722205008282"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200722205137877.png" alt="image-20200722205137877"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200722205242179.png" alt="image-20200722205242179"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200722205300363.png" alt="image-20200722205300363"></p>
<h3 id="写入es"><a href="#写入es" class="headerlink" title="写入es"></a>写入es</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200722205658180.png" alt="image-20200722205658180"></p>
<h3 id="hive交互"><a href="#hive交互" class="headerlink" title="hive交互"></a>hive交互</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200722205900220.png" alt="image-20200722205900220"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200722210205209.png" alt="image-20200722210205209"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/devops/k8s/k8s-yunxi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Focus-1">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus-1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/devops/k8s/k8s-yunxi/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-12T20:05:45+08:00">
                2020-07-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<ol>
<li>k8s简介和安装</li>
<li>k8s核心概念：Pod、控制器、Services、网络通信</li>
<li>k8s 资源清单及编写、Pod生命周期</li>
<li>k8s 存储类型</li>
<li>k8s 调度器及HELM</li>
<li>k8s 集群安全机制</li>
</ol>
</blockquote>
<h1 id="k8s简介和安装"><a href="#k8s简介和安装" class="headerlink" title="k8s简介和安装"></a>k8s简介和安装</h1><h2 id="1、k8s简介"><a href="#1、k8s简介" class="headerlink" title="1、k8s简介"></a>1、k8s简介</h2><p>IaaS：Infrastructure as a Service</p>
<p>PaaS：Platform as a Service（类似：阿里云、腾讯云）</p>
<p>SaaS：Software as a Service（类似：腾讯文档、有道云笔记等产品）</p>
<p>软件部署演进路线</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200712201733.png" alt></p>
<h2 id="3、基础知识"><a href="#3、基础知识" class="headerlink" title="3、基础知识"></a>3、基础知识</h2><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200712204223.png" alt></p>
<h2 id="4、安装配置"><a href="#4、安装配置" class="headerlink" title="4、安装配置"></a>4、安装配置</h2><p>系统要求：</p>
<blockquote>
<ol>
<li>64位操作系统 lInux 内核3.10以上，建立4.4以上内核 （Ubuntu/Centos7+），3台</li>
<li>cpu至少2核，最好4核</li>
<li>内存最少2G，推荐8G</li>
<li>etcd 3.0版本</li>
<li>docker 18.03 版本及以上</li>
<li>Flannel</li>
<li>Kubernetes 1.18.5</li>
</ol>
</blockquote>
<h3 id="内核升级"><a href="#内核升级" class="headerlink" title="内核升级"></a>内核升级</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/redhat-release</span><br><span class="line">uname -r</span><br></pre></td></tr></table></figure>

<h1 id="k8s核心概念：Pod、控制器、Services、网络通信"><a href="#k8s核心概念：Pod、控制器、Services、网络通信" class="headerlink" title="k8s核心概念：Pod、控制器、Services、网络通信"></a>k8s核心概念：Pod、控制器、Services、网络通信</h1><h3 id="kubernetes-对象"><a href="#kubernetes-对象" class="headerlink" title="kubernetes 对象"></a>kubernetes 对象</h3><h3 id="基本对象"><a href="#基本对象" class="headerlink" title="基本对象"></a>基本对象</h3><h4 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h4><h5 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h5><h5 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h5><h3 id="高级对象"><a href="#高级对象" class="headerlink" title="高级对象"></a>高级对象</h3><p>扩容缩容</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale deployment nginx-deploy  --replicas=5</span><br></pre></td></tr></table></figure>

<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200717203447927.png" alt="image-20200717203447927"></p>
<p>查看节点分布</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get po -o wide</span><br></pre></td></tr></table></figure>

<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200717203632940.png" alt="image-20200717203632940"></p>
<p>自动扩容缩容</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl autoscale deployment nginx-deploy --min=3 --max=7 --cpu-percent=60</span><br></pre></td></tr></table></figure>

<p>滚动升级</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx:1.18.0</span><br><span class="line">docker pull nginx:1.19.1</span><br></pre></td></tr></table></figure>

<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200717204501134.png" alt="image-20200717204501134"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete deployment nginx-deploy</span><br><span class="line">kubectl get deployment</span><br><span class="line">kubectl get pod</span><br><span class="line">kubectl create -f nginx-deploy.yaml</span><br><span class="line">kubectl describe deployment nginx-deploy</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl set image deployment/nginx-deploy nginx=docker.io/nginx:1.19.1</span><br><span class="line">kubectl get rs</span><br></pre></td></tr></table></figure>

<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200717204919912.png" alt="image-20200717204919912"></p>
<p>回滚</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout undo deployment/nginx-depoly</span><br><span class="line"><span class="meta">#</span><span class="bash"> 回滚到某个版本</span></span><br><span class="line">kubectl rollout undo deployment/nginx-depoly --to-reversion=2</span><br></pre></td></tr></table></figure>

<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200717210134304.png" alt="image-20200717210134304"></p>
<p>AB测试</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200717210458496.png" alt="image-20200717210458496"></p>
<h5 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h5><p>确保集群中的每个pod有且只有一个副本</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200717211904111.png" alt="image-20200717211904111"></p>
<blockquote>
<p>Filebeat、Logstash、Flume （agent）</p>
<p>Promethues node Exporter 监控每台机器的CPU、内存指标</p>
</blockquote>
<h1 id="k8s-资源清单及编写、Pod生命周期"><a href="#k8s-资源清单及编写、Pod生命周期" class="headerlink" title="k8s 资源清单及编写、Pod生命周期"></a>k8s 资源清单及编写、Pod生命周期</h1><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200717202457991.png" alt="image-20200717202457991"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl api-versions</span><br><span class="line">kubectl api-resouces</span><br></pre></td></tr></table></figure>

<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200717212821456.png" alt="image-20200717212821456"></p>
<p>查看label</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200717212914661.png" alt="image-20200717212914661"></p>
<p>修改label（修改后，又重新创建了一个新pod，补齐3个nginx）</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200717213303026.png" alt="image-20200717213303026"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200717214100302.png" alt="image-20200717214100302"></p>
<p>查看每个对象有哪些属性</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubectl explain deployment</span><br><span class="line">kubectl explain deployment.status</span><br><span class="line">kubectl explain pod</span><br><span class="line">kubectl explain kind</span><br><span class="line">kubectl explain apiVersion</span><br><span class="line">kubectl explain metadata</span><br></pre></td></tr></table></figure>

<p>编写yaml文件 nginx-daemon.yaml</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-daemon</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">job-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">job-demo</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">job-demo</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">docker.io/busybox:latest</span></span><br><span class="line"><span class="attr">        command:</span> <span class="string">["echo",</span> <span class="string">"'scale=10; 4*a(1)'"</span><span class="string">,</span> <span class="string">"|"</span><span class="string">,</span> <span class="string">"bc"</span><span class="string">,</span> <span class="string">"-l"</span><span class="string">]</span></span><br><span class="line"><span class="attr">      restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure>

<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200717220235870.png" alt="image-20200717220235870"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721200932996.png" alt="image-20200721200932996"></p>
<ul>
<li>Pause 是根容器</li>
<li></li>
</ul>
<h3 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h3><h2 id="Pod的生命周期"><a href="#Pod的生命周期" class="headerlink" title="Pod的生命周期"></a>Pod的生命周期</h2><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721201359564.png" alt="image-20200721201359564"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721201619270.png" alt="image-20200721201619270"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721202029004.png" alt="image-20200721202029004"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721202126748.png" alt="image-20200721202126748"></p>
<p>ImagePullBackOff ， 镜像拉取失败，采用退避算法重新拉取镜像</p>
<ul>
<li>pending</li>
<li>running</li>
<li>succeeded</li>
<li>failed</li>
<li>unknown</li>
</ul>
<p>Init Container 按顺序执行</p>
<p>Main Container</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721204046028.png" alt="image-20200721204046028"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721205000220.png" alt="image-20200721205000220"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721205616483.png" alt="image-20200721205616483"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721205339221.png" alt="image-20200721205339221"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721205018680.png" alt="image-20200721205018680"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721205700360.png" alt="image-20200721205700360"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721205745887.png" alt="image-20200721205745887"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721205852363.png" alt="image-20200721205852363"></p>
<h4 id="探针：存活检测"><a href="#探针：存活检测" class="headerlink" title="探针：存活检测"></a>探针：存活检测</h4><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721210254286.png" alt="image-20200721210254286"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721210529407.png" alt="image-20200721210529407"></p>
<p>启动延迟5秒，检测周期3秒</p>
<p>nginx 一般都是80端口，去检测8008端口，是不存在的，会认为容器启动失败，会再启动一个容器</p>
<p>第二个例子：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721212430275.png" alt="image-20200721212430275"></p>
<p>启动后先休眠60秒，移除a文件，再休眠</p>
<p>检测a文件是否存在，不存在则删除pod，再创建新的Pod</p>
<h4 id="postStart"><a href="#postStart" class="headerlink" title="postStart"></a>postStart</h4><h4 id="preStop"><a href="#preStop" class="headerlink" title="preStop"></a>preStop</h4><h4 id="探针：读取检测"><a href="#探针：读取检测" class="headerlink" title="探针：读取检测"></a>探针：读取检测</h4><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721211359742.png" alt="image-20200721211359742"></p>
<p>读取检测，如果能读取到，则代表容器达到了ready状态，可以供外界访问，否则就被认为不可访问</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721211733546.png" alt="image-20200721211733546"></p>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>暴露固定的ip，端口，供外界访问</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721214042284.png" alt="image-20200721214042284"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f nginx-deploy.yaml</span><br><span class="line">kubectl get deploy</span><br><span class="line">kubectl expose deploy nginx-deploy --port=8000 --target-port=80</span><br></pre></td></tr></table></figure>

<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721214352533.png" alt="image-20200721214352533"></p>
<p>删除暴露</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete</span><br></pre></td></tr></table></figure>

<p>域名格式 </p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721215346837.png" alt="image-20200721215346837"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721215430586.png" alt="image-20200721215430586"></p>
<p>k8s 转发模式</p>
<p>linux 内核态，用户态</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200724201832504.png" alt="image-20200724201832504"></p>
<p>userspace</p>
<p>k8s 1.4 之前 使用 iptables</p>
<p>ipvs（ipv server） 虚拟ip地址服务 VIP 在1.8-beta版本里加入使用，在1.14版本里成为正式的转发协议</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200721220829050.png" alt="image-20200721220829050"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200724203048934.png" alt="image-20200724203048934"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200724203345123.png" alt="image-20200724203345123"></p>
<p>iptables 协助维护内核netfilter中的各种路由</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200724203804993.png" alt="image-20200724203804993"></p>
<h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>做资源隔离</p>
<p>6种命名空间</p>
<ol>
<li>挂载文件系统：mount</li>
<li>进程：pid</li>
<li>网络Network：不同namespace之间的网络是不通的</li>
<li>IPC 进程间通信</li>
<li>UTS： 隔离主机名 和 NIS域名</li>
<li>User：</li>
</ol>
<h3 id="Cgroup"><a href="#Cgroup" class="headerlink" title="Cgroup"></a>Cgroup</h3><p>cgroup：linux 2.6以后出现的，google工程师导入linux内核的</p>
<p>基于 cpuset 开发</p>
<p>作用：做资源管控</p>
<h4 id="cpuset"><a href="#cpuset" class="headerlink" title="cpuset"></a>cpuset</h4><p>linux操作系统启动以后，会mount一个cpu的子系统，我们可以对cpu的子系统做各种各样的操作和定制。这样我们就可以管控每个应用程序使用资源的多少了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装工具管理 cgroup</span></span><br><span class="line">yum install -y libcgroup-tools</span><br><span class="line">cgcreate -g cpu:/test</span><br><span class="line">cgget</span><br><span class="line">cgset</span><br></pre></td></tr></table></figure>

<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200724205038988.png" alt="image-20200724205038988"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200724205105451.png" alt="image-20200724205105451"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200724211455990.png" alt="image-20200724211455990"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200724211519041.png" alt="image-20200724211519041"></p>
<p>虚拟设备对 就相当于 虚拟网卡之间的桥</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有网络命名空间</span></span><br><span class="line">ip netns list</span><br><span class="line">ip netns add test1</span><br><span class="line">ip a</span><br><span class="line"><span class="meta">#</span><span class="bash"> 定义虚拟设备对</span></span><br><span class="line">ip link add veth0 type veth peer name veth1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将veth1转给test1</span></span><br><span class="line">ip link set veth1 netns test1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定test1 的网段</span></span><br><span class="line">ip netns exec test1 ip addr add 10.0.5.5/24 dev veth1</span><br><span class="line">ip netns exec test1 ip link set veth1 up</span><br><span class="line">ip netns exec test1 ip link set lo up</span><br><span class="line">ip netns exec test1 ip addr show</span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line">ip addr add 10.0.5.6/24 dev veth0</span><br><span class="line">ip link set veth0 up</span><br></pre></td></tr></table></figure>

<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200724212031275.png" alt="image-20200724212031275"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200724213155070.png" alt="image-20200724213155070"></p>
<p>k8s 各个节点之所以能互相访问是因为每个节点上都部署了 kube-proxy</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200724213252839.png" alt="image-20200724213252839"></p>
<p>上图中的架构，kube-proxy 太繁忙了，所以可以优化成iptables转发</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200724213404820.png" alt="image-20200724213404820"></p>
<p>但iptables转发规则太多的时候又不利于维护，所以又引入了ipvs （VIP server）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum search ipvs</span><br><span class="line">yum install -y ipvsadm.x86_64</span><br><span class="line">ipvsadm -Ln</span><br><span class="line">ipvsadm --clear</span><br></pre></td></tr></table></figure>

<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200724214332452.png" alt="image-20200724214332452"></p>
<blockquote>
<p>cm -  ConfigMap 配置中心，涉及k8s的很多配置，都是用configMap来做的</p>
<p>通过配置 可以 选择使用 iptables 还是 ipvs</p>
</blockquote>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200724214418390.png" alt="image-20200724214418390"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200724215025073.png" alt="image-20200724215025073"></p>
<h3 id="服务类型"><a href="#服务类型" class="headerlink" title="服务类型"></a>服务类型</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200724215456247.png" alt="image-20200724215456247"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200724215522003.png" alt="image-20200724215522003"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200724215717140.png" alt="image-20200724215717140"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200724215704461.png" alt="image-20200724215704461"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200724215821221.png" alt="image-20200724215821221"></p>
<blockquote>
<p>32659 是宿主机ip，指向容器的8000端口</p>
</blockquote>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200724215926221.png" alt="image-20200724215926221"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200724215944494.png" alt="image-20200724215944494"></p>
<p>在yaml文件中可指定端口</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200724220348401.png" alt="image-20200724220348401"></p>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><h3 id="ingress"><a href="#ingress" class="headerlink" title="ingress"></a>ingress</h3><h1 id="k8s-存储类型"><a href="#k8s-存储类型" class="headerlink" title="k8s 存储类型"></a>k8s 存储类型</h1><h3 id="configMap"><a href="#configMap" class="headerlink" title="configMap"></a>configMap</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200728203419455.png" alt="image-20200728203419455"></p>
<h3 id="pv-pvc"><a href="#pv-pvc" class="headerlink" title="pv/pvc"></a>pv/pvc</h3><p>pv：Persistence Volume</p>
<p>pvc：Persistence Volume Claim（声明）</p>
<p>pv 支持 filesystem 和 blockDevice</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pv -n devops</span><br></pre></td></tr></table></figure>

<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200728221059607.png" alt="image-20200728221059607"></p>
<p>如果pvc没有指定pv，则按照最小匹配原则 匹配PV</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200728221135855.png" alt="image-20200728221135855"></p>
<h4 id="访问模式"><a href="#访问模式" class="headerlink" title="访问模式"></a>访问模式</h4><ul>
<li>NFS：以linux方式搭建</li>
<li>RWO (Read-Write-Once)：单个节点读写</li>
<li>ROX (Read-Only-Many)：多个节点只读</li>
<li>RWX（Read-Write-Many）：多个节点读写</li>
</ul>
<h4 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h4><ul>
<li>Retain：手动回收</li>
<li>Recycle：基本擦除（rm -rf /somevolume/*）</li>
<li>Delete： 和 会提供商有关</li>
</ul>
<h4 id="PV生命周期"><a href="#PV生命周期" class="headerlink" title="PV生命周期"></a>PV生命周期</h4><ul>
<li>Avaliable：空闲没有被绑定</li>
<li>Bound：已经被绑定</li>
<li>Release：已经被释放，但没有重新声明</li>
<li>Failed：回收失败</li>
</ul>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200731203239975.png" alt="image-20200731203239975"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200728220139919.png" alt="image-20200728220139919"></p>
<h3 id="k8s-生命周期"><a href="#k8s-生命周期" class="headerlink" title="k8s 生命周期"></a>k8s 生命周期</h3><ul>
<li>Pending</li>
<li>ContainerCreating</li>
<li>Running</li>
<li></li>
</ul>
<h1 id="k8s-调度器及HELM"><a href="#k8s-调度器及HELM" class="headerlink" title="k8s 调度器及HELM"></a>k8s 调度器及HELM</h1><h3 id="亲和力"><a href="#亲和力" class="headerlink" title="亲和力"></a>亲和力</h3><h4 id="节点亲和力"><a href="#节点亲和力" class="headerlink" title="节点亲和力"></a>节点亲和力</h4><p>硬亲和：requiredDuringSchedulingIgnoredDuringExecution。如果节点label改了，服务会被驱逐</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200731211448916.png" alt="image-20200731211448916"></p>
<p>软亲和：perferredDuringSchedulingIgnoredDuringExecution。如果节点label改了，服务还能迁移到其他节点</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200731212040097.png" alt="image-20200731212040097"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200731212408234.png" alt="image-20200731212408234"></p>
<h4 id="pod-亲和力"><a href="#pod-亲和力" class="headerlink" title="pod 亲和力"></a>pod 亲和力</h4><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200731212542351.png" alt="image-20200731212542351"></p>
<h3 id="驱逐（排除）"><a href="#驱逐（排除）" class="headerlink" title="驱逐（排除）"></a>驱逐（排除）</h3><h3 id="污点节点taint"><a href="#污点节点taint" class="headerlink" title="污点节点taint"></a>污点节点taint</h3><p>让pod部署不到这个节点上</p>
<ul>
<li><p>NoSchedule：Pod 不会被分配到该节点</p>
</li>
<li><p>PerferNoSchedule：尝试不要将pod分配到该节点</p>
</li>
<li><p>NoExecute：Pod肯定不会被分配到该节点，部署在该节点的pod会被驱逐</p>
</li>
</ul>
<p><img src="C:%5CUsers%5CCarloZ%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200731214656698.png" alt="image-20200731214656698"></p>
<p>加污点</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200731213938727.png" alt="image-20200731213938727"></p>
<p>去除污点</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200731214208090.png" alt="image-20200731214208090"></p>
<h3 id="容忍tolerations"><a href="#容忍tolerations" class="headerlink" title="容忍tolerations"></a>容忍tolerations</h3><p>容忍是对于pod来说的</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200731214531002.png" alt="image-20200731214531002"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200731214738005.png" alt="image-20200731214738005"></p>
<h1 id="k8s-集群安全机制"><a href="#k8s-集群安全机制" class="headerlink" title="k8s 集群安全机制"></a>k8s 集群安全机制</h1><p>configMap 配置k8s 程序配置 非加密</p>
<p>secret</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200731220718131.png" alt="image-20200731220718131"></p>
<p>ServiceAccount token</p>
<p>opaque passwork 密钥</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/micro-service/microserv-command-and-event-model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Focus-1">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus-1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/micro-service/microserv-command-and-event-model/" itemprop="url">走出微服务误区：避免从单体到分布式单体</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-08T00:00:00+08:00">
                2020-07-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/micro-service/" itemprop="url" rel="index">
                    <span itemprop="name">micro-service</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <br>

<p>作者 | 敖小剑</p>
<p>最近，社区频繁出现各种对微服务的质疑和反思声音，甚至放弃微服务回归单体。鉴于此，本文从“分布式单体”问题出发，介绍通过引入非侵入式方案和引入 Event/EDA 来走出微服务实践误区——从单体到微服务，最后却沦为分布式单体。</p>
<h1 id="1、回顾：从单体到微服务到-Function"><a href="#1、回顾：从单体到微服务到-Function" class="headerlink" title="1、回顾：从单体到微服务到 Function"></a>1、回顾：从单体到微服务到 Function</h1><p>在过去几年间，微服务架构成为业界主流，很多公司开始采用微服务，并将原有的单体应用迁移到微服务架构。从架构上说，微服务和单体之间最大的变化在于微服务架构下应用的粒度被“拆小”：将所有业务逻辑都集中在一起的单体应用，按照领域模型拆分为多个内聚而自治的“更小”应用。而 Function 则在拆分上更进一步，拆分粒度变成“单个操作”，基于 Function 逐渐演进出现了 FaaS 形态和 Serverless 架构。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200708124527.png" alt></p>
<p>在微服务和 Serverless 喧嚣中，业界逐渐出现很多质疑和反对的声音：越来越多的人发现，当他们兴冲冲的迁移单体应用到微服务和 Serverless 架构后，收益却并没有期望中的那么理想。而最近，也出现了一些对微服务的各种质疑、反思的声音，甚至放弃微服务回归单体。举例，我在Infoq 中国网站简单搜索关键字“微服务”，前三页中就出现了如下内容：</p>
<p>我们为什么停用微服务？</p>
<p>这些公司为什么放弃微服务？</p>
<p><a href="https://www.infoq.cn/article/KSzctluch2ijbRbKYBgO" target="_blank" rel="noopener">https://www.infoq.cn/article/KSzctluch2ijbRbKYBgO</a></p>
<p>致传统企业朋友：不够痛就别微服务，有坑</p>
<p><a href="https://www.infoq.cn/article/Nd0RofAUp0WtlvlQArbu" target="_blank" rel="noopener">https://www.infoq.cn/article/Nd0RofAUp0WtlvlQArbu</a></p>
<p>微服务带来的心理阴影</p>
<p>Uber 团队放弃微服务改用宏服务，网友评论炸锅了</p>
<p>为什么 Segment 从微服务回归单体</p>
<p>无论是支持还是反对微服务的声音，大多都是着眼于组织架构（康威定律，对应用和代码的 ownership）、微服务拆分（粒度大小，如何识别领域模型和业务边界）、分布式事务（跨多个微服务调用时维持一致性），工具（自动化构建、部署、可测试性、监控、分布式链路跟踪、CI/CD），数据库分离（避免多个微服务，尤其是领域模型外的微服务共享数据库）等方面进行合理性分析和观点阐述，相信大家都对这些问题都有了解。</p>
<p>而我今天的文章，将从另外一个角度来看待微服务（也包括 Serverless）实践中存在的误区——辛辛苦苦从单体走到微服务，却最后沦为分布式单体。</p>
<h1 id="2、分布式单体"><a href="#2、分布式单体" class="headerlink" title="2、分布式单体"></a>2、分布式单体</h1><p>“Distributed Monolith”，分布式单体，这真是一个悲伤的技术术语。而这偏偏是企业采用微服务后通常最容易掉进去的一个“陷阱”。事实上，我看到的很多微服务落地最终都是以”分布式单体”收场，无法获得微服务的完整收益。</p>
<p>问题源于微服务实施的方式 —— 按照业务逻辑拆解单体，划分为多个微服务，定义 API 接口，然后通过 REST 或者 RPC 进行远程调用，最终把这些微服务组合起来提供各种业务功能。简单说，就是在业务拆分的基础上，用进程间的远程调用简单替代原来进程内的方法调用。期间，对于原来使用的各种分布式能力，继续采用之前的方式。简单说：方式不变，只是粒度变小。</p>
<p>从方法论说，这样做无可厚非，这也是微服务采用过程中非常标准的做法。但问题在于，止步于此是不够的 —— 至少存在两个有待继续努力改进的地方。</p>
<h3 id="分布式单体起因之一：通过共享库和网络客户端访问分布式能力"><a href="#分布式单体起因之一：通过共享库和网络客户端访问分布式能力" class="headerlink" title="分布式单体起因之一：通过共享库和网络客户端访问分布式能力"></a>分布式单体起因之一：通过共享库和网络客户端访问分布式能力</h3><p>分布式能力的共享库和网络客户端是造成分布式单体问题的原因之一，关于这一点，来自 verizon 的 Mohamad Byan 在他的名为 Avoid the Distributed Monolith!! 的演讲中有详细阐述，我这里援引他的图片和观点：</p>
<p><a href="https://www.slideshare.net/DevOpsDaysDFW/avoid-the-distributed-monolith" target="_blank" rel="noopener">https://www.slideshare.net/DevOpsDaysDFW/avoid-the-distributed-monolith</a></p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200708124559.png" alt></p>
<p>上图是微服务体系的逻辑架构，由两部分组成：</p>
<ul>
<li>内层架构（图上浅蓝色部分），是每个微服务的实现架构；</li>
<li>外层架构 (图上黄色部分)，是构建强大微服务架构所需要的各种能力。这里通常有大家熟悉的各种分布式能力。</li>
</ul>
<blockquote>
<p>特别提示：这里说的“网络客户端”是各种分布式能力的客户端，如服务注册发现 /MQ 中间件 /Redis 等 key-value 存储 / 数据库 / 监控日志追踪系统 / 安全体系等，不是服务间通讯如 RPC 的客户端。</p>
</blockquote>
<p>而内层的微服务是通过共享类库和网络客户端来访问外层架构提供的分布式能力：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200708124629.png" alt></p>
<p>分布式能力的共享类库和网络客户端会迫使内层微服务和外层架构的各种分布式能力之间产生强耦合，增加运维的复杂性（如升级困难造成版本碎片化），多语言受限于类库和网络客户端支持的语言，各种组件（如消息中间件）往往使用自定义数据格式和通讯协议 —— 所有这些迫使内层微服务不得不实质性受限于外层架构的技术选型。</p>
<p>对于 Function，这个问题就更加明显：Function 的粒度更小，更专注业务逻辑。某些简短的 Function 可能只有几百行代码，但是，为了让这几百行代码运转起来而需要引入的共享类库和网络客户端可能相比之下就规模惊人了。援引一张网上图片作为示意：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200708124654.png" alt></p>
<h3 id="分布式单体起因之二：简单用远程调用替代进程内方法调用"><a href="#分布式单体起因之二：简单用远程调用替代进程内方法调用" class="headerlink" title="分布式单体起因之二：简单用远程调用替代进程内方法调用"></a>分布式单体起因之二：简单用远程调用替代进程内方法调用</h3><p>在微服务架构改造过程中，熟悉单体系统和架构的开发人员，习惯性的会将这些单体时代的知识和经验重用到新的微服务架构之中。其中最典型的做法就是：在遵循领域模型将现有单体应用按照业务边界拆分为多个微服务时，往往选择用 REST 或者 RPC 等远程调用方式简单替代原有的进程内方法调用。</p>
<p>当两个逻辑上的业务模块存在协作需求时：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200708124717.png" alt></p>
<p>从单体到微服务，直接方法调用被替换为远程调用（REST 或者 RPC），即使采用 Service Mesh 也只是在链路中多增加了 sidecar 节点，并未改变远程调用的性质：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200708124739.png" alt></p>
<p>这导致了前面所说的 “分布式单体”：</p>
<ul>
<li>在微服务之前：应用程序由多个耦合在一起的模块组成，这些模块通过内存空间进行方法调用…..</li>
<li>在微服务之后：应用程序由多个耦合在一起的微服务组成，这些微服务通过网络进行远程调用…..</li>
</ul>
<p>抛开调用方式的差异来看采用微服务前后的系统架构，会发现：<strong>两者几乎是完全一样的！！</strong></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200708124806.png" alt></p>
<p>而微服务版本在某些情况下可能表现的更糟糕：因为调用方式更脆弱，因为网络远比内存不可靠。而我们将网络当成 “胶水” 来使用，试图把分散的业务逻辑模块（已经拆分为微服务）按照单体时代的同样方式简单粘在一起，这当然比单体在同一个进程内直接方法调用更加的不可靠。</p>
<p>关于这一点，在”The Eight Fallacies of Distributed Computing/ 分布式计算的 8 个谬论”一文中有详细阐述。</p>
<p><a href="https://www.red-gate.com/simple-talk/blogs/the-eight-fallacies-of-distributed-computing/" target="_blank" rel="noopener">https://www.red-gate.com/simple-talk/blogs/the-eight-fallacies-of-distributed-computing/</a></p>
<p>类似的，在采用 Function 时，如果依然沿用上面的方式，以单体或微服务架构的思维方式和设计模式来创建 FaaS/Serverless 架构：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200708124859.png" alt></p>
<p>其本质不会发生变化 —— 不过是将微服务变成粒度更小的函数，导致系统中的远程调用数量大为增加：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200708124924.png" alt></p>
<p>系统内的耦合并没有发生变化，Serverless 并不能改变微服务中存在的这个内部耦合问题：调用在哪里，则耦合就在哪里！只是把将组件的粒度从 “微服务“换成了 “Function/ 函数”。</p>
<p>耦合的存在是源于系统不同组件之间的通讯模式，而不是实现通讯的技术。</p>
<p>如果让两个组件通过“<strong>调用</strong>”（后面再展开讲何为调用）进行远程通信，那么不管调用是如何实现的，这两个组件都是紧密耦合。因此，当系统从单体到微服务到 Serverless，如果止步于简单的用远程调用替代进程内方法调用，那么系统依然是高度耦合的，从这个角度来说：</p>
<p><strong>单体应用 ≈ 分布式单体 ≈ Serverless 单体</strong></p>
<h3 id="分布式单体起因小结"><a href="#分布式单体起因小结" class="headerlink" title="分布式单体起因小结"></a>分布式单体起因小结</h3><p>上面，我们列出了微服务和 Serverless 实践中容易形成“分布式单体”的两个主要原因：</p>
<ol>
<li>通过共享库和网络客户端访问分布式能力；</li>
<li>简单用远程调用替代进程内方法调用。</li>
</ol>
<p>下面我们针对这两个问题探讨解决的思路和对策。</p>
<h1 id="3、引入非侵入式方案：物理隔离-逻辑抽象"><a href="#3、引入非侵入式方案：物理隔离-逻辑抽象" class="headerlink" title="3、引入非侵入式方案：物理隔离 + 逻辑抽象"></a>3、引入非侵入式方案：物理隔离 + 逻辑抽象</h1><p>前面谈到分布式单体产生的一个原因是“<strong>通过共享库和网络客户端访问分布式能力</strong>”，造成微服务和 Lambda 函数和分布式能力强耦合。以 Service Mesh 为典型代表的非侵入式方案是解决这一问题的有效手段，其他类似方案有 RSocket / Multiple Runtime Architecture，以及数据库和消息的 Mesh 化产品，其基本思路有两点：</p>
<ol>
<li><strong>委托</strong>：通过 Sidecar 或者 Runtime 来进行对分布式能力的访问，避免应用和提供分布式能力的组件直接通讯造成强绑定 —— <strong>通过物理隔离进行解耦。</strong></li>
<li><strong>抽象</strong>：对内层微服务隐藏实现细节，只暴露网络协议和数据契约，将外围架构的各种分布式能力以 API 的方式暴露出来，而屏蔽提供这些能力的具体实现 —— <strong>通过逻辑抽象进行解耦。</strong></li>
</ol>
<p>以 Service Mesh 的 Sidecar 为例，在植入 Sidecar 之后，业务应用需要直接对接的分布式能力就大为减少（物理隔离）：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200708125044.png" alt></p>
<p>最近出现的 Multiple Runtime / Mecha 架构，以及遵循这一架构思想的微软开源产品 Dapr ，则将这个做法推进到服务间通讯之外更多的分布式能力。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200708125101.png" alt></p>
<p>此外在委托之外，还提供对分布式能力的抽象。比如在 Dapr 中，业务应用只需要使用 Dapr 提供的标准 API，就可以使用这些分布式能力而无法关注提供这些能力的具体产品（逻辑抽象）：</p>
<p>以 pub-sub 模型中的发消息为例，这是 Dapr 提供的 Java 客户端 SDK API：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DaprClient</span> </span>&#123;</span><br><span class="line">    <span class="function">Mono&lt;Void&gt; <span class="title">publishEvent</span><span class="params">(String topic, Object event)</span></span>;</span><br><span class="line">   <span class="function">Mono&lt;Void&gt; <span class="title">publishEvent</span><span class="params">(String topic, Object event, Map&lt;String, String&gt; metadata)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见在发送事件时，Dapr 完全屏蔽了底层消息机制的具体实现，通过客户端 SDK 为应用提供发送消息的高层抽象，在 Dapr Runtime 中对接底层 MQ 实现——完全解耦应用和 MQ：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200708125239.png" alt></p>
<p>关于 Multiple Runtime / Mecha 架构的介绍不在这里深入展开，有兴趣的同学可以浏览我之前的博客文章——“Mecha：将 Mesh 进行到底”。</p>
<p><a href="https://skyao.io/talk/202004-mecha-mesh-through-to-the-end/" target="_blank" rel="noopener">https://skyao.io/talk/202004-mecha-mesh-through-to-the-end/</a></p>
<p>稍后我会有一篇深度文章针对上面这个话题，详细介绍在消息通讯领域和 EDA 架构下如何实现消息通讯和事件驱动的抽象和标准化，以避免业务应用和底层消息产品绑定和强耦合，敬请关注。</p>
<h1 id="4-引入-Event：解除不必要的强耦合"><a href="#4-引入-Event：解除不必要的强耦合" class="headerlink" title="4 引入 Event：解除不必要的强耦合"></a>4 引入 Event：解除不必要的强耦合</h1><p>在解决了微服务 /Serverless 系统和外部分布式能力之间紧耦合的问题后，我们继续看微服务 /Serverless 系统内部紧耦合的问题。前面讨论到，从单体到微服务到 Function/Serverless，如果只是简单的将直接方法调用替换为远程调用（REST 或者 RPC），那么两个通讯的模块之间会因为这个紧密耦合的调用而形成依赖，而且依赖关系会伴随调用链继续传递，导致形成一个树形的依赖关系网络，表现为系统间的高度耦合：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200708125349.png" alt></p>
<p>要解决这个问题，基本思路在于审视两个组件之间通讯行为的业务语义，然后据此决定两者之间究竟是应该采用 Command/ 命令模式还是 Event/ 事件模式。</p>
<h3 id="温故而知新：Event-和-Command"><a href="#温故而知新：Event-和-Command" class="headerlink" title="温故而知新：Event 和 Command"></a>温故而知新：Event 和 Command</h3><p>首先，我们来温习一下 Event 和 Command 的概念和差别，借用一张图片，总结的非常到位：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200708125408.png" alt></p>
<p>什么是 Event？</p>
<blockquote>
<p>Event: “A significant change in state” — K. Mani Chandy</p>
</blockquote>
<p>Event 代表领域中已经发生的事情：通常意味着有行为（Action）已经发生，有状态（Status）已经改变。</p>
<p>因为是已经发生的事情，因此：</p>
<ul>
<li>Event 可以被理解为是对已经发生的事实的客观陈述；</li>
<li>这意味着 Event 通常是不可变的：Event 的信息（代表着客观事实）不能被篡改，Event 的产生不能逆转；</li>
<li>命名：Event 通常以动词的完成时态命名，如 UserRegistredEvent。</li>
</ul>
<p>产生 Event 的目标是为了接下来的 Event 传播：</p>
<ul>
<li>将已经发生的 Event 通知给对此感兴趣的观察者；</li>
<li>收到 Event 的观察者将根据 Event 的内容进行判断和决策：可能会有接下来的动作（Action），有些动作可能需要和其他模块通讯而触发命令（Command），这些动作执行完毕可能会造成领域状态的改变从而继续触发新的事件（Event）。</li>
</ul>
<p>Event 传播的方式：</p>
<ul>
<li>Event 有明确的“源 /source”，即 Event 产生（或者说状态改变）的发生地；</li>
<li>但由于生产者并不知道（不愿意 / 不关心）会有哪些观察者对 Event 感兴趣，因此 Event 中并不包含“目的地 /Destination”信息；</li>
<li>Event 通常是通过 MessageQueue 机制，以 pub-sub 的方式传播；</li>
<li>Event 通常不需要回复（ reply）或者应答（response）；</li>
<li>Event 通常用 发布（publish）。</li>
</ul>
<p>什么是 Command？</p>
<p>Command 用于传递一个要求执行某个动作（Action）的请求。</p>
<p>Command 代表将要发生的事情：</p>
<ul>
<li>通常意味着行为（Action）还未发生但即将发生（如果请求被接受和执行）；</li>
<li>存在被拒绝的可能：不愿意执行（参数校验失败，权限不足），不能执行（接收者故障或者资源无法访问）；</li>
<li>命名：Command 通常以动词的普通形态命名，如 UserRegisterCommand。</li>
</ul>
<p>产生 Command 的目标是为了接下来的 Command 执行：</p>
<ul>
<li>将 Command 发送给期望的执行者；</li>
<li>收到 Command 的执行者将根据 Command 的要求进行执行：在执行的过程中内部可能有多个动作（Action），有些动作可能需要和其他模块通讯而触发命令（Command），这些动作执行完毕可能会造成领域状态的改变从而继续触发新的事件（Event）。</li>
</ul>
<p>Command 的传播方式：</p>
<ul>
<li>Command 有明确的源（Source），即 Command 的发起者；</li>
<li>Command 也有非常明确的执行者（而且通常是一个），因此命名通常包含“目的地 /Destination”信息；</li>
<li>Command 通常是通过 HTTP / RPC 这样的点对点远程通讯机制，通常是同步；</li>
<li>Command 通常需要应答（Response）：回应 Command 是否被执行（因为可能被拒绝），执行结果（因为可能执行失败）；</li>
<li>Command 通常用 发送（Send）。</li>
</ul>
<p>Command 和 Event 总结</p>
<p>总结 —— Command 和 Event 的本质区别在于他们的意图：</p>
<ul>
<li>Command 的意图是告知希望发生的事情；</li>
<li>Event 的意图是告知已经发生的事情。</li>
</ul>
<p>意图上的差异最终会在服务间依赖关系上有特别的体现：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200708125437.png" alt></p>
<ul>
<li>Command 的发起者必须明确知晓 Command 的接收者并明确指示需要做什么（所谓的命令、指示、操纵、编排），尤其当发起者连续发出多个 Command 时，通常这些 Command 会有非常明确的顺序和逻辑关系，以组合为特定的业务逻辑。</li>
</ul>
<p>Command 的依赖关系简单明确: 发起者 “显式依赖” 接收者</p>
<ul>
<li>Event 的发起者只需负责发布 Event，而无需关注 Event 的接收者，包括接收者是谁（一个还是多个）以及会做什么（所谓的通知、驱动、协调）。即使 Event 实际有多个接收者，这些接受者之间往往没有明确的顺序关系，其处理过程中的业务逻辑也往往是彼此独立的。</li>
</ul>
<p>Event 的依赖关系稍微复杂一些：发起者明确不依赖接收者，接收者则存在对发起者 “隐式的反向依赖” ——反向是指和 Command 的依赖关系相比方向调转，是接受者反过来依赖发起者；隐式则是指这种依赖只体现于 “接受者依赖 Event，而 Event 是由发起者发布” 的间接关系中，接受者和发起者之间并不存在直接依赖关系。</p>
<h3 id="从业务视角出发：关系模型决定通讯行为"><a href="#从业务视角出发：关系模型决定通讯行为" class="headerlink" title="从业务视角出发：关系模型决定通讯行为"></a>从业务视角出发：关系模型决定通讯行为</h3><p>在温习完 Command 和 Event 之后，我们再来看我们前面的问题：<strong>为什么简单的将直接方法调用替换为远程调用（REST 或者 RPC）会出问题？</strong>主要原因是在这个替换过程中，所谓简单是指不假思索直接选择远程调用，也就是选择全程 Command 方式：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200708125503.png" alt></p>
<p>真实业务场景下各个组件（微服务或者 Function）的业务逻辑关系，通常不会像上图这么夸张，不应该全是 Command （后面会谈到也不应该全是 Event） ，而应该是类似下图描述的两者结合，以微服务为例（Function 类推）：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200708125521.png" alt></p>
<p>业务输入：图上微服务 A 接收到业务请求的输入（可能是 Command 方式，也可能是 Event 方式）</p>
<p>业务逻辑 “实现” 的执行过程：</p>
<ul>
<li>微服务 A 在执行 Command（或者被 Event 触发）的过程中，会有很多动作（Action）；</li>
<li>有些是微服务 A 内部的动作，比如操作数据库，操作 key-value 存储，内存中的业务逻辑处理等；</li>
<li>有些是和外部微服务进行通讯，如执行查询或要求对方进行某些操作，这些通讯方式是以 Command 的形式，如图上和微服务 B 的通讯；</li>
<li>在这些内部和外部动作完成之后，执行过程完成；</li>
<li>如果是 Command，则需要以应答的形式给回 Command 操作的结果。</li>
</ul>
<p>业务状态变更触发的后续行为：</p>
<ul>
<li>在上面的执行过程完成后，如果涉及到业务状态的变更，则需要为此发布事件；</li>
<li>事件通过 event bus 分发给对该事件感兴趣的其他微服务：注意这个过程是解耦的，微服务 A 不清楚也不关心哪些微服务对此事件感兴趣，事件也不需要应答。</li>
</ul>
<p>上面微服务 A 的业务逻辑执行处理过程中，需要以 Command 或者 Event 方式和其他微服务通讯，如图中的微服务 B/C/D/E。而对于这些微服务 B/C/D/E（视为微服务 A 的下游服务），他们在接受到业务请求后的处理流程和微服务 A 的处理流程是类似的。</p>
<p>因此我们可以简单推导一下，当业务处理逻辑从微服务 A 延展到微服务 A 的下游服务（图中的微服务 B/C/D/E）时的场景：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200708125536.png" alt></p>
<p>将图中涉及的微服务 A/B/C/D/E 在处理业务逻辑的行为总结下来，通讯行为大体是一样的：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200708125604.png" alt></p>
<p>抽象起来，一个典型的微服务在业务处理流程中的通讯行为可以概括为以下四点：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200708125642.png" alt></p>
<ol>
<li>输入：以一个 Command 请求或者一个 Event 通知为输入，这是业务处理流程的起点。</li>
<li>内部 Action：微服务的内部逻辑，典型如数据库操作，访问 Redis 等 key-value 存储（对应于 Multiple Runtime/Mecha 架构中的各种分布式能力）。可选，通常为 0-N 个。</li>
<li>外部访问：以 Command 形式访问外部的其他微服务。可选，通常为 0-N 个。</li>
<li>通告变更：以 Event 形式对外发布事件，通告上述操作产生的业务状态的变更。可选，通常为 0-1 个。</li>
</ol>
<p>在这个行为模式中，2 和 3 是没有顺序的，而且可能交错执行，而 4 通常都是在流程的最后：只有当各种内部 Action 和外部 Command 都完成，业务逻辑实现结束，状态变更完成，“木已成舟”，才能以 Event 的方式对外发布：“操作已完成，状态已变更，望周知”。</p>
<p>这里我们回顾一下前面的总结 —— Event 和 Command 的本质区别在于他们的意图：</p>
<ul>
<li>Event 的意图是告知已经发生的事情；</li>
<li>Command 的意图是告知希望发生的事情。</li>
</ul>
<p>从业务逻辑处理的角度来看，外部访问的 Command 和内部操作的 Action 是业务逻辑的 “实现” 部分：这些操作组成了完整的业务逻辑——如果这些操作失败，则业务处理将会直接影响（失败或者部分失败）。而发布事件则是业务逻辑完成之后的后续 “通知” 部分：当业务逻辑处理完毕，状态变更完成后，以事件的方式驱动后续的进一步处理。注意是驱动，而不是直接操纵。</p>
<p>从时间线的角度来看整个业务处理流程如下图所示：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200708125658.png" alt></p>
<h3 id="全程-Command-带来的问题：不必要的强耦合"><a href="#全程-Command-带来的问题：不必要的强耦合" class="headerlink" title="全程 Command 带来的问题：不必要的强耦合"></a>全程 Command 带来的问题：不必要的强耦合</h3><p>全程 Command 的微服务系统，存在的问题就是在上述最后阶段的“状态变更通知”环节，没有采用 Event 和 pub-sub 模型，而是继续使用 Command 逐个调用下游相关的其他微服务：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200708125719.png" alt></p>
<p>Event 可以解耦生产者和消费者，因此图中的微服务 A 和微服务 C/D/E 之间没有强烈的依赖关系，彼此无需锁定对方的存在。但是 Command 不同，在采用 Command 方式后微服务 A 和下游相关微服务 C/D/E 会形成强依赖，而且这种依赖关系会蔓延，最终导致形成一颗巨大而深层次的依赖树，而 Function 由于粒度更细，问题往往更严重：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200708125751.png" alt></p>
<p>而如果在“状态变更通知”环节引入 Event，则可以解耦微服务和下游被通知的微服务，从而将依赖关系解除，避免无限制的蔓延。如下图所示，左边图形是使用 Event 代替 Command 来进行状态变更通知之后的依赖关系，考虑到 Event 对生产者和消费者的解耦作用，我们“斩断”绿色的 Event 箭头，这样就得到了右边这样一个被分解为多个小范围依赖树的系统依赖关系图：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200708125805.png" alt></p>
<p>对 Event 和 Command 使用的建议：</p>
<ul>
<li>在单体应用拆分为微服务时，不应该简单的将原有的方法调用替换为 Command；</li>
<li>应该审视每个调用在业务逻辑上的语义：是业务逻辑执行的组成部分？还是执行完成之后的状态通知？</li>
<li>然后据此决定采用 Command 还是 Event。</li>
</ul>
<h3 id="编排和协调"><a href="#编排和协调" class="headerlink" title="编排和协调"></a>编排和协调</h3><p>在 Command 和 Event 的使用上，还有两个概念：<strong>编排和协调。</strong></p>
<p>这里强烈推荐一篇博客文章， Microservices Choreography vs Orchestration: The Benefits of Choreography，作者 Jonathan Schabowsky ，Solace 的 CTO。他在这边博客中总结了让微服务协同工作的两种模式，并做了一个生动的比喻：</p>
<p><a href="https://solace.com/blog/microservices-choreography-vs-orchestration/" target="_blank" rel="noopener">https://solace.com/blog/microservices-choreography-vs-orchestration/</a></p>
<p><strong>编排</strong>（Orchestration）：需要主动控制所有的元素和交互，就像指挥家指挥乐团的乐手一样——对应 Command。</p>
<p><strong>协调</strong>（Choreography）：需要建立一个模式，微服务会跟随音乐起舞，不需要监督和指令——对应 Event。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200708125835.png" alt></p>
<p>也曾看到很多持类似观点的文章，其中有一张图片印象深刻，我摘录过来：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200708125849.png" alt></p>
<p>左边是期望通过编排（Orchestration）方式得到的整齐划一的理想目标，右边是实际得到的大型翻车现场。</p>
<h3 id="全程-Event-带来的问题：开发困难和业务边界不清晰"><a href="#全程-Event-带来的问题：开发困难和业务边界不清晰" class="headerlink" title="全程 Event 带来的问题：开发困难和业务边界不清晰"></a>全程 Event 带来的问题：开发困难和业务边界不清晰</h3><p>在 Command 和 Event 的使用上，除了全程使用 Command 之外，还有一个极端是全程使用 Event，这一点在 Lambda（FaaS）中更常见一些：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200708125913.png" alt></p>
<p>这个方式首当其冲的问题就是在适用 Command 语义的地方采用了 Event 来替代，而由于 Command 和 Event 在使用语义上的差异，这个替代会显得别扭：</p>
<ul>
<li><p>Command 是一对一的，替代它的 Event 也不得不从 “1:N” 退化为 “1:1”，pub-sub 模型不再存在。</p>
</li>
<li><p>Command 是需要返回结果的，尤其是 Query 类的 Command 必须要有查询结果，使用 Event 替代之后，就不得不实现 “支持 Response 的 Event”，典型如在消息机制中实现 Request-Reply 模型的。</p>
</li>
<li><p>或者引入另外一个 Event 来反向通知结果，即用两个异步 Event 来替代一个同步的 Command —— 这需要让发起者进行额外的订阅和处理，开发复杂性远远超过使用简单的 Command。</p>
</li>
<li><p>而且还引入了一个非常麻烦的状态问题：即服务间通讯的上下文中通常是有状态的，Reply Event 必须准确的发送给 Request Event 的发起者的实例，而不能任意选择一个。这使得 Reply Event 不仅仅要 1:1 的绑定订阅者服务，还必须绑定这个服务的特定实例 —— 这样的 Reply Event 已经没法称为 Event 了。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200708125925.png" alt></p>
</li>
<li><p>绕开这个状态问题的常见方案是选择无状态的场景，如果处理 Reply Event 时无需考虑状态，那么 Event Reply 才能简单的发送给任意的实例。</p>
</li>
</ul>
<p>对于粒度较大的微服务系统，通常很难实现无状态，所以在微服务中全程采用 Event 通常会比较别扭的，事实上也很少有人这样做。而在粒度非常小的 Function/FaaS 系统中，全程采用 Event 方式比较常见。</p>
<p>关于全程使用 Event，我个人持保留态度，我倾向于即使是在 FaaS 中，也适当保留 Command 的用法：如果某个操作是“业务逻辑”执行中不可或缺的一部分，那么 Command 方式的紧耦合反而更能体现出这个“业务逻辑”的存在：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200708125941.png" alt></p>
<p>如果完全采用 Event 方式，“彻底”解耦，则产生新的问题（且不论在编码方面额外带来的复杂度） —— 在海量细粒度的 Event 调用下，业务逻辑已经很难体现，领域模型（Domain Modeling）和 有界上下文（Bounded Context）则淹没在这些 Event 调用下，难于识别：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200708130010.png" alt></p>
<blockquote>
<p>备注：这个问题被称为“Lambda Pinball”，这里不深入展开，后续计划会有一篇文章单独详细探讨“Lambda Pinball”的由来和解决的思路。</p>
</blockquote>
<h3 id="Command-和-Event-的选择：实事求是不偏不倚"><a href="#Command-和-Event-的选择：实事求是不偏不倚" class="headerlink" title="Command 和 Event 的选择：实事求是不偏不倚"></a>Command 和 Event 的选择：实事求是不偏不倚</h3><p>总结一下 Command 和 Event 的选择，我个人的建议是不要一刀切：全程 Command 方式的缺点容易理解，但简单替换为全程 Event 也未必合适。</p>
<p>我的个人观点是倾向于从实际“业务逻辑”处理的语义出发，判断：</p>
<ul>
<li>如果是业务逻辑的 “实现” 部分：倾向于选择使用 Command；</li>
<li>如果是业务逻辑完成之后的后续 “通知” 部分：强烈建议选择使用 Event。</li>
</ul>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200708130038.png" alt></p>
<h1 id="5、总结与反思"><a href="#5、总结与反思" class="headerlink" title="5、总结与反思"></a>5、总结与反思</h1><h3 id="警惕：不要沦为分布式单体"><a href="#警惕：不要沦为分布式单体" class="headerlink" title="警惕：不要沦为分布式单体"></a>警惕：不要沦为分布式单体</h3><p>上面我们列出了微服务和 Serverless 实践中容易形成 “分布式单体” 的两个主要原因和对策：</p>
<ul>
<li>通过共享库和网络客户端访问分布式能力：引入非侵入方案解耦应用和各种分布式能力；</li>
<li>简单用远程调用替代进程内方法调用：区分 Command 和 Event，引入 Event 来解除微服务间不必要的强耦合。</li>
</ul>
<p>前者在技术上目前还不太成熟，典型如 Istio/Dapr 项目都还有待加强，暂时在落地上阻力比较大。但后者已经是业界多年的成熟实践，甚至在微服务和 Serverless 兴起之前就广泛使用，因此建议可以立即着手改进。</p>
<p>关于如何更方便的将 Event 和 Event Driven Architecture 引入到微服务和 Serverless 中，同时又不与提供 Message Queue 分布式能力的具体实现耦合，我将在稍后文章中详细展开，敬请期待。</p>
<h3 id="反思：喧闹和谩骂之外的冷静思考"><a href="#反思：喧闹和谩骂之外的冷静思考" class="headerlink" title="反思：喧闹和谩骂之外的冷静思考"></a>反思：喧闹和谩骂之外的冷静思考</h3><p>如果我们在微服务和 Serverless 实践中，始终停留在“用远程调用简单替代进程内方法调用”的程度，并固守单体时代的习惯引入各种 SDK，那么分布式单体问题就必然不可避免。我们的微服务转型、Serverless 实践最后得到的往往是：</p>
<h4 id="把单体变成…更糟糕的分布式单体"><a href="#把单体变成…更糟糕的分布式单体" class="headerlink" title="把单体变成…更糟糕的分布式单体"></a>把单体变成…更糟糕的分布式单体</h4><p>当然，微服务可能成为分布式单体，但这并不意味着微服务架构是个谎言，也不意味着比单体架构更差。Serverless 可能同样遭遇分布式单体（还有后续要深入探讨的 Lambda Pinball），但这也不意味着 Serverless 不可取 —— 微服务和 Serverless 都是解决特定问题的工具，和所有的工具一样，在使用工具之前，我们需要先研究和了解它们，学习如何正确的使用它们：</p>
<ul>
<li>需要为微服务创建正确的架构，和单体架构必然会有很大的不同：一定不是“原封不动”的将方法调替换为远程调用，最好不要用共享类库和网络客户端的方式直接使用各种分布式能力；</li>
<li>Serverless 更是需要我们对架构进行彻底的反思，需要改变思维方式，才能保证收益大于弊端。</li>
</ul>
<p>参考资料和推荐阅读：</p>
<ol>
<li>《Avoid the Distributed Monolith!!》：Verizon 的 Mohamad Byan 在 2018 年 9 月的一个演讲，描述微服务实践中的分布式单体陷阱和解决的方式。——<a href="https://www.slideshare.net/DevOpsDaysDFW/avoid-the-distributed-monolith" target="_blank" rel="noopener">https://www.slideshare.net/DevOpsDaysDFW/avoid-the-distributed-monolith</a></li>
<li>《Mecha：将 Mesh 进行到底》：详细介绍 Multiple Runtime / Macha 架构，将更多的分布式能力进行 Mesh 化——<a href="https://skyao.io/talk/202004-mecha-mesh-through-to-the-end/" target="_blank" rel="noopener">https://skyao.io/talk/202004-mecha-mesh-through-to-the-end/</a></li>
<li>《The Eight Fallacies of Distributed Computing》：分布式计算领域的经典文章，中文翻译如下——<a href="http://www.xumenger.com/the-eight-fallacies-of-distributed-computing-20180817/" target="_blank" rel="noopener">http://www.xumenger.com/the-eight-fallacies-of-distributed-computing-20180817/</a></li>
<li>《Opportunities and Pitfalls of Event-driven Utopia》：Bernd Rücker 在 QCon 上的一个演讲，讲述“事件驱动乌托邦的机遇与陷阱”，本文部分图片来自这份 PPT——<a href="https://www.youtube.com/watch?v=jjYAZ0DPLNM" target="_blank" rel="noopener">https://www.youtube.com/watch?v=jjYAZ0DPLNM</a></li>
<li>《Practical DDD: Bounded Contexts + Events =&gt; Microservices》：Indu Alagarsamy 的一个演讲，介绍领域驱动开发（DDD）和 Messaging 的交集。推荐使用消息技术在干净、定义良好的有界上下文之间进行通信，以去除时空耦合。——<a href="https://www.infoq.com/presentations/microservices-ddd-bounded-contexts/" target="_blank" rel="noopener">https://www.infoq.com/presentations/microservices-ddd-bounded-contexts/</a></li>
<li>《Building Event-Driven Cloud Applications and Services》：讨论构建事件驱动的应用和服务的通用实践和技术，是一个序列教程——<a href="https://medium.com/@ratrosy/building-event-driven-cloud-applications-and-services-ad0b5b970036。" target="_blank" rel="noopener">https://medium.com/@ratrosy/building-event-driven-cloud-applications-and-services-ad0b5b970036。</a></li>
<li>《The Architect’s Guide to Event-Driven Microservices》：Solace 公司网站上的一份 PDF 格式的小册子——<a href="https://go.solace.com/wp-download-eventdrivenmicroservices.html" target="_blank" rel="noopener">https://go.solace.com/wp-download-eventdrivenmicroservices.html</a></li>
<li>《致传统企业朋友：不够痛就别微服务，有坑》：网易云刘超刘老师的超级好文章，极其实在而全面的讲述微服务落地需要考虑的方方面面以及各种问题，强烈推荐阅读。——<a href="https://www.infoq.cn/article/Nd0RofAUp0WtlvlQArbu" target="_blank" rel="noopener">https://www.infoq.cn/article/Nd0RofAUp0WtlvlQArbu</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/flink/flink-sql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Focus-1">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus-1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/flink/flink-sql/" itemprop="url">深入分析Flink SQL的工作机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-11T00:00:00+08:00">
                2020-06-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flink/" itemprop="url" rel="index">
                    <span itemprop="name">flink</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <br>



<blockquote>
<p>摘要：本文整理自 Flink Forward 2020 全球在线会议中文精华版，由 Apache Flink PMC 伍翀（云邪）分享，社区志愿者陈婧敏（清樾）整理。旨在帮助大家更好地理解 Flink SQL 引擎的工作原理。文章主要分为以下四部分：</p>
<ol>
<li>Flink SQL Architecture</li>
<li>How Flink SQL Works?</li>
<li>Flink SQL Optimizations</li>
<li>Summary and Futures</li>
</ol>
<p><strong>Tips：</strong>点击下方链接可查看作者分享的原版视频～<br><a href="https://ververica.cn/developers/flink-forward-virtual-conference/" target="_blank" rel="noopener">https://ververica.cn/developers/flink-forward-virtual-conference/</a></p>
</blockquote>
<p>Apache Flink 社区在最近的两个版本（1.9 &amp; 1.10 ）中为面向未来的统一流批处理在架构层面做了很多优化，其中一个重大改造是引入了 Blink Planner，开始支持 SQL &amp; Table API 使用不同的 SQL Planner 进行编译（Planner 的插件化）。</p>
<p>本文首先会介绍推动这些优化背后的思考，展示统一的架构如何更好地处理流式和批式查询，其次将深入剖析 Flink SQL 的编译及优化过程，包括：</p>
<ol>
<li>Flink SQL 利用 Apache Calcite 将 SQL 翻译为关系代数表达式，使用表达式折叠（Expression Reduce），下推优化（Predicate / Projection Pushdown ）等优化技术生成物理执行计划（Physical Plan），利用 Codegen 技术生成高效执行代码。</li>
<li>Flink SQL 使用高效的二进制数据存储结构 BinaryRow 加速计算性能；使用 Mini-batch 攒批提高吞吐，降低两层聚合时由 Retraction 引起的数据抖动；聚合场景下数据倾斜处理和 Top-N 排序的优化原理。</li>
</ol>
<h1 id="Flink-SQL-架构-amp-Blink-Planner（1-9-）"><a href="#Flink-SQL-架构-amp-Blink-Planner（1-9-）" class="headerlink" title="Flink SQL 架构 &amp; Blink Planner（1.9+ ）"></a>Flink SQL 架构 &amp; Blink Planner（1.9+ ）</h1><h3 id="1-1-Old-Planner-的限制"><a href="#1-1-Old-Planner-的限制" class="headerlink" title="1.1 Old Planner 的限制"></a>1.1 Old Planner 的限制</h3><p>要想了解 Flink SQL 在1.9 版本引入新架构的动机，我们首先看下 1.9 版本之前的架构设计</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200611121152.gif" alt></p>
<p>从图中可以看出，虽然面向用户的 Table API &amp; SQL 是统一的，但是流式和批式任务在翻译层分别对应了 DataStreamAPI 和 DataSetAPI，在 Runtime 层面也要根据不同的 API 获取执行计划，两层的设计使得整个架构能够复用的模块有限，不易扩展。</p>
<h3 id="1-2-统一的-Blink-Planner"><a href="#1-2-统一的-Blink-Planner" class="headerlink" title="1.2 统一的 Blink Planner"></a>1.2 统一的 Blink Planner</h3><p>Flink 在设计之初就遵循“批是流的特例”的理念，在架构上做到流批统一是大势所趋。在社区和阿里巴巴的共同努力下，1.9 版本引入了新的 Blink Planner，将批 SQL 处理作为流 SQL 处理的特例，尽量对通用的处理和优化逻辑进行抽象和复用，通过 Flink 内部的 Stream Transformation API 实现流 &amp; 批的统一处理，替代原 Flink Planner 将流 &amp; 批区分处理的方式。</p>
<p>此外，新架构通过灵活的插件化方式兼容老版本 Planner，用户可自行选择。不过在 1.11 版本 Blink Planner 会代替 Old Planner 成为默认的 Planner 来支持流 &amp; 批进一步融合统一（ Old Planner 将在之后逐步退出历史舞台）。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611121414.gif" alt></p>
<br>

<br>

<h1 id="Flink-SQL-工作流"><a href="#Flink-SQL-工作流" class="headerlink" title="Flink SQL 工作流"></a>Flink SQL 工作流</h1><p> Flink SQL 引擎的工作流总结如图所示。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611121557.png" alt></p>
<p>从图中可以看出，一段查询 SQL / 使用TableAPI 编写的程序（以下简称 TableAPI 代码）从输入到编译为可执行的 JobGraph 主要经历如下几个阶段</p>
<ol>
<li>将 SQL文本 / TableAPI 代码转化为逻辑执行计划（Logical Plan）</li>
<li>Logical Plan 通过优化器优化为物理执行计划（Physical Plan）</li>
<li>通过代码生成技术生成 Transformations 后进一步编译为可执行的 JobGraph 提交运行</li>
</ol>
<p>本节将重点对 Flink SQL 优化器的常用优化方法和 CodeGen 生成 Transformations 进行介绍。</p>
<h3 id="2-1-Logical-Planning"><a href="#2-1-Logical-Planning" class="headerlink" title="2.1 Logical Planning"></a>2.1 Logical Planning</h3><p>Flink SQL 引擎使用 Apache Calcite SQL Parser 将 SQL 文本解析为词法树，SQL Validator 获取 Catalog 中元数据的信息进行语法分析和验证，转化为关系代数表达式（RelNode），再由 Optimizer 将关系代数表达式转换为初始状态的逻辑执行计划。</p>
<p>备注：TableAPI 代码使用 TableAPI Validator 对接 Catalog 后生成逻辑执行计划。</p>
<p>E.g.1 考虑如下表达 JOIN 操作的一段 SQL。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  t1.id, <span class="number">1</span> + <span class="number">2</span> + t1.value <span class="keyword">AS</span> v </span><br><span class="line"><span class="keyword">FROM</span> t1, t2 </span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">  t1.id = t2.id <span class="keyword">AND</span> </span><br><span class="line">  t2.id &lt; <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p>经过上述操作后得到了一个树状结构的逻辑执行计划，根节点对应最上层的 Select 语句，叶子节点对应输入表 t1 和 t2 的 TableScan 操作，Join 和 Where 条件过滤 分别对应了 Join 和 Filter 节点。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LogicalProject</span>(id=[$<span class="number">0</span>], v=[+(+(<span class="number">1</span>, <span class="number">2</span>), $<span class="number">1</span>)])</span><br><span class="line">+- <span class="type">LogicalFilter</span>(condition=[<span class="type">AND</span>(=($<span class="number">0</span>, $<span class="number">3</span>), &lt;($<span class="number">3</span>, <span class="number">1000</span>))])</span><br><span class="line">   +- <span class="type">LogicalJoin</span>(condition=[<span class="literal">true</span>], joinType=[inner])</span><br><span class="line">      :- <span class="type">LogicalTableScan</span>(table=[[default_catalog, <span class="keyword">default</span>, t1]])</span><br><span class="line">      +- <span class="type">LogicalTableScan</span>(table=[[default_catalog, <span class="keyword">default</span>, t2]])</span><br></pre></td></tr></table></figure>

<p>可视化后如图所示，这是优化器开始工作的初始状态。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611121906.png" alt></p>
<p>下面开始介绍 Flink SQL 优化器常见的几种优化方式。</p>
<p><strong>■ 2.1.1 Expression Reduce</strong></p>
<p>表达式（Expression） 是 SQL 中最常见的语法。比如 t1.id 是一个表达式， 1 + 2 + t1.value 也是一个表达式。优化器在优化过程中会递归遍历树上节点，尽可能预计算出每个表达式的值，这个过程就称为表达式折叠。这种转换在逻辑上等价，通过优化后，真正执行时不再需要为每一条记录都计算一遍 1 + 2。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611122001.png" alt></p>
<p><strong>■ 2.1.2 PushDown Optimization</strong></p>
<p>下推优化是指在保持关系代数语义不变的前提下将 SQL 语句中的变换操作尽可能下推到靠近数据源的位置以获得更优的性能，常见的下推优化有谓词下推（Predicate Pushdown），投影下推（Projection Pushdown，有时也译作列裁剪）等。</p>
<ul>
<li>Predicate Pushdown</li>
</ul>
<p>回顾 E.g.1，我们发现 WHERE 条件表达式中 t2.id &lt; 1000 这个过滤条件描述的是对表 t2 的约束，跟表 t1 无关，完全可以下推到 JOIN 操作之前完成。假设表 t2 中有一百万行数据，但是满足 id &lt; 1000 的数据只有 1,000 条，则通过谓词下推优化后到达 JOIN 节点的数据量降低了1,000 倍，极大地节省了 I / O 开销，提升了 JOIN 性能。</p>
<p>谓词下推（Predicate Pushdown）是优化 SQL 查询的一项基本技术，谓词一词来源于数学，指能推导出一个布尔返回值（TRUE / FALSE）的函数或表达式，通过判断布尔值可以进行数据过滤。谓词下推是指保持关系代数语义不变的前提下将 Filter 尽可能移至靠近数据源的位置（比如读取数据的 SCAN 阶段）来降低查询和传递的数据量（记录数）。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611122053.png" alt></p>
<ul>
<li>Projection Pushdown</li>
</ul>
<p>列裁剪是 Projection Pushdown 更直观的描述方式，指在优化过程中去掉没有使用的列来降低 I / O 开销，提升性能。但与谓词下推只移动节点位置不同，投影下推可能会增加节点个数。比如最后计算出的投影组合应该放在 TableScan 操作之上，而 TableScan 节点之上没有 Projection 节点，优化器就会显式地新增 Projection 节点来完成优化。另外如果输入表是基于列式存储的（如 Parquet 或 ORC 等），优化还会继续下推到 Scan 操作中进行。</p>
<p>回顾 E.g.1，我们发现整个查询中只用到了表 t1 的 id 和 value 字段，表 t2 的 id 字段，在 TableScan 节点之上分别增加 Projection 节点去掉多余字段，极大地节省了 I / O 开销</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611122150.png" alt></p>
<p>简要总结一下，谓词下推和投影下推分别通过避免处理不必要的记录数和字段数来降低 I / O 开销提升性能。</p>
<h3 id="2-2-Physical-Planning-on-Batch"><a href="#2-2-Physical-Planning-on-Batch" class="headerlink" title="2.2 Physical Planning on Batch"></a>2.2 Physical Planning on Batch</h3><p>通过上述一系列操作后，我们得到了优化后的逻辑执行计划。逻辑执行计划描述了执行步骤和每一步需要完成的操作，但没有描述操作的具体实现方式。而物理执行计划会考虑物理实现的特性，生成每一个操作的具体实现方式。比如 Join 是使用 SortMergeJoin、HashJoin 或 BroadcastHashJoin 等。优化器在生成逻辑执行计划时会计算整棵树上每一个节点的 Cost，对于有多种实现方式的节点（比如 Join 节点），优化器会展开所有可能的 Join 方式分别计算。最终整条路径上 Cost 最小的实现方式就被选中成为 Final Physical Plan。</p>
<p>回顾 E.g.1，当它以批模式执行，同时我们可以拿到输入表的 Statistics 信息。在经过前述优化后，表 t2 到达 Join 节点时只有 1,000 条数据，使用 BroadcastJoin 的开销相对最低，则最终的 Physical Plan 如下图所示。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611122251.png" alt></p>
<h3 id="2-3-Translation-amp-Code-Generation"><a href="#2-3-Translation-amp-Code-Generation" class="headerlink" title="2.3 Translation &amp; Code Generation"></a>2.3 Translation &amp; Code Generation</h3><p>代码生成（Code Generation） 在计算机领域是一种广泛使用的技术。在 Physical Plan 到生成 Transformation Tree 过程中就使用了 Code Generation。</p>
<p>回顾 E.g.1，以 表 t2 之上的 Calc 节点 t2.id &lt; 1000 表达式为例，通过 Code Generation 后生成了描述 Transformation Operator 的一段 Java 代码，将接收到的 Row 中 id &lt; 1000 的 Row 发送到下一个 Operator。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611122339.png" alt></p>
<p>Flink SQL 引擎会将 Physical Plan 通过 Code Generation 翻译为 Transformations，再进一步编译为可执行的 JobGraph。</p>
<h3 id="2-4-Physical-Planning-on-Stream"><a href="#2-4-Physical-Planning-on-Stream" class="headerlink" title="2.4 Physical Planning on Stream"></a>2.4 Physical Planning on Stream</h3><p>以上介绍了 Flink SQL 引擎的整体工作流，上述例子是假定以批模式编译的，下面我们来介绍一下以流模式编译时，在生成 Physical Plan 过程中的一个重要机制：Retraction Mechanism （aka. Changelog Mechanism）。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611122438.png" alt></p>
<p>■ <strong>2.4.1 Retraction Mechanism</strong></p>
<p>Retraction 是流式数据处理中撤回过早下发（Early Firing）数据的一种机制，类似于传统数据库的 Update 操作。级联的聚合等复杂 SQL 中如果没有 Retraction 机制，就会导致最终的计算结果与批处理不同，这也是目前业界很多流计算引擎的缺陷。</p>
<p>E.g.2 考虑如下统计词频分布的 SQL。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT cnt, COUNT(cnt) as freq</span><br><span class="line">FROM (</span><br><span class="line">  SELECT word, COUNT(*) as cnt</span><br><span class="line">  FROM words</span><br><span class="line">  GROUP BY word)</span><br><span class="line">GROUP BY cnt</span><br></pre></td></tr></table></figure>

<p> 假设输入数据是：</p>
<table>
<thead>
<tr>
<th><strong>word</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Hello</td>
</tr>
<tr>
<td>World</td>
</tr>
<tr>
<td>Hello</td>
</tr>
</tbody></table>
<p>则经过上面的计算后，预期的输出结果应该是：</p>
<table>
<thead>
<tr>
<th><strong>cnt</strong></th>
<th><strong>freq</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
</tr>
</tbody></table>
<p>但与批处理不同，流处理的数据是一条条到达的，理论上每一条数据都会触发一次计算，所以在处理了第一个 Hello 和第一个 World 之后，词频为 1 的单词数已经变成了 2，此时再处理第二个 Hello 时，如果不能修正之前的结果，Hello 就会在词频等于 1 和词频等于 2 这两个窗口下被同时统计，显然这个结果是错误的，这就是没有 Retraction 机制带来的问题。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611122614.gif" alt></p>
<p>Flink SQL 在流计算领域中的一个重大贡献就是首次提出了这个机制的具体实现方案。Retraction 机制又名 Changelog 机制，因为某种程度上 Flink 将输入的流数据看作是数据库的 Changelog，每条输入数据都可以看作是对数据库的一次变更操作，比如 Insert，Delete 或者 Update。以 MySQL 数据库为例，其Binlog 信息以二进制形式存储，其中 Update_rows_log_event 会对应 2 条标记 Before Image （BI） 和 After Image （AI），分别表示某一行在更新前后的信息。</p>
<p>在 Flink SQL 优化器生成流作业的 Physical Plan 时会判断当前节点是否是更新操作，如果是则会同时发出 2 条消息 update_before 和 update_after 到下游节点，update_before 表示之前“错误”下发的数据，需要被撤回，update_after 表示当前下发的“正确”数据。下游收到后，会在结果上先减去 update_before，再加上 update_after。</p>
<p>回顾 E.g.2，下面的动图演示了加入 Retraction 机制后正确结果的计算过程。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611122658.gif" alt></p>
<p>update_before 是一条非常关键的信息，相当于标记出了导致当前结果不正确的那个“元凶”。不过额外操作会带来额外的开销，有些情况下不需要发送 update_before 也可以获得正确的结果，比如下游节点接的是 UpsertSink（MySQL 或者 HBase的情况下，数据库可以按主键用 update_after 消息覆盖结果）。是否发送 update_before 由优化器决定，用户不需要关心。</p>
<p>■ <strong>2.4.2 Update_before Decision</strong></p>
<p>前面介绍了 Retraction 机制和 update_before，那优化器是怎样决定是否需要发送update_before 呢？本节将介绍这一部分的工作。</p>
<p><strong>Step1：确定每个节点对应的 Changelog 变更类型</strong></p>
<p>数据库中最常见的三种操作类型分别是 Insert （记为 [I]），Delete（记为 [D]），Update（记为 [U]）。优化器首先会自底向上检查每个节点，判断它属于哪（几）种类型，分别打上对应标记。</p>
<p>回顾 E.g.2，第一个 Source 节点由于只产生新数据，所以属于 Insert，记为 [I]；第二个节点计算内层的聚合，所以会发出更新的消息，记为 [I，U]；第三个节点裁掉 word 字段，属于简单计算，传递了上游的变更类型，记为 [I，U]；第四个节点是外层的聚合计算，由于它收到了来自上游的 Update 消息，所以额外需要 Delete 操作来保证更新成功，记为 [I，U，D]。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611122745.gif" alt></p>
<p><strong>Step2：确定每个节点发送的消息类型</strong></p>
<p>在介绍 Step2 之前，我们先介绍下 Flink 中 Update 消息类型的表示形式。在 Flink 中 Update 由两条 update_before（简称 UB）和 update_after （简称 UA）来表示，其中 UB 消息在某些情况下可以不发送，从而提高性能。</p>
<p>在 Step1 中优化器自底向上推导出了每个节点对应的 Changelog 变更操作，这一步里会先自顶向下推断当前节点需要父节点提供的消息类型，直到遇到第一个不需要父节点提供任何消息类型的节点，再往上回推每个节点最终的实现方式和需要的消息类型。</p>
<p>回顾 E.g.2，由于最上层节点是 UpsertSink 节点，只需要它的父节点提供 [UA] 即可。到了外层聚合的 Aggregate 节点，由于 Aggregate 节点的输入有 Update 操作，所以需要父节点需要提供 [UB，UA]，这样才能正确更新自己的计算状态。</p>
<p>再往下到 Calc 节点，它需要传递 [UB，UA] 的需求给它的父节点，也就是内层的 Aggregate 节点。而到了内层 Aggregation 节点，它的父节点是 Source 节点，不会产生 Update 操作，所以它不需要 Source 节点额外发送任何 [UB / UA ]。当优化器遍历到 Source 节点，便开始进行回溯，如果当前节点能满足子节点的 requirement，则将对应的标签更新到节点上，否则便无法生成 plan。首先内层的 Aggregate 能产生 UB，所以能满足子节点的 requirement，所以优化器会给内层的 Aggregate 节点打上 [UB，UA] 的标签，然后向上传递到 Calc 节点，同样打上 [UB，UA] ，再到外层的 Aggregate 节点，由于它的下游只需要接受更新后的消息，所以打上 [UA] 标签，表示它只需要向下游发送 update_after 即可。</p>
<p>这些标签最终会影响算子的物理实现，比如外层的 Aggregate 节点，由于它会接收到来自上游的 [UB]，所以物理实现会使用带 Retract 的 Count，同时它只会向 Sink 发送 update_after。而内层的 Aggregate 节点，由于上游发送过来的数据没有 [UB]，所以可以采用不带 Retract 的 Count 实现，同时由于带有 [UB] 标签，所以需要往下游发送 update_before。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611122835.gif" alt></p>
<br>

<br>

<h1 id="Flink-SQL-Internal-Optimization"><a href="#Flink-SQL-Internal-Optimization" class="headerlink" title="Flink SQL Internal Optimization"></a>Flink SQL Internal Optimization</h1><p>前面介绍了 Flink SQL 引擎的工作原理，接下来会简要概括一下 Flink SQL 内部的一些优化，更多资料可以在 Flink Forward Asia 2019 查看。</p>
<h3 id="3-1-BinaryRow"><a href="#3-1-BinaryRow" class="headerlink" title="3.1 BinaryRow"></a>3.1 BinaryRow</h3><p>在 Flink 1.9+ 前， Flink Runtime 层各算子间传递的数据结构是 Row，其内部实现是 Object[]。这种数据结构的问题在于不但需要额外开销存 Object Metadata，计算过程中还涉及到大量序列化 / 反序列 （特别是只需要处理某几个字段时需要反序列化整个 Row），primitive 类型的拆 / 装箱等，都会带来大量额外的性能开销。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611122929.png" alt></p>
<p>Flink 1.9 开始引入了 Blink Planner，使用二进制数据结构的 BinaryRow 来表示 Record。BinaryRow 作用于默认大小为 32K 的 Memory Segment，直接映射到内存。BinaryRow 内部分为 Header，定长区和变长区。Header 用于存储 Retraction 消息的标识，定长区使用 8 个 bytes 来记录字段的 Nullable 信息及所有 primitive 和可以在 8 个 bytes 内表示的类型。其它类型会按照基于起始位置的 offset 存放在变长区。</p>
<p>BinaryRow 作为 Blink Planner 的基础数据结构，带来的好处是显而易见的：首先存储上更为紧凑，去掉了额外开销；其次在序列化和反序列化上带来的显著性能提升，可根据 offset 只反序列化需要的字段，在开启 Object Reuse 后，序列化可以直接通过内存拷贝完成。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611122950.png" alt></p>
<h3 id="3-2-Mini-batch-Processing"><a href="#3-2-Mini-batch-Processing" class="headerlink" title="3.2 Mini-batch Processing"></a>3.2 Mini-batch Processing</h3><p>Flink 是纯流式处理框架，在理论上每一条新到的数据都会触发一次计算。然而在实现层面，这样做会导致聚合场景下每处理一条数据都需要读写 State 及序列化 / 反序列化。如果能够在内存中 buffer 一定量的数据，预先做一次聚合后再更新 State，则不但会降低操作 State 的开销，还会有效减少发送到下游的数据量，提升 throughput，降低两层聚合时由 Retraction 引起的数据抖动, 这就是 Mini-batch 攒批优化的核心思想。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611123052.gif" alt></p>
<h3 id="3-3-Skew-Processing"><a href="#3-3-Skew-Processing" class="headerlink" title="3.3 Skew Processing"></a>3.3 Skew Processing</h3><p>对于数据倾斜的优化，主要分为是否带 DISTINCT 去重语义的两种方式。对于普通聚合的数据倾斜，Flink 引入了 Local-Global 两阶段优化，类似于 MapReduce 增加 Local Combiner 的处理模式。而对于带有去重的聚合，Flink 则会将用户的 SQL 按原有聚合的 key 组合再加上 DISTINCT key 做 Hash 取模后改写为两层聚合来进行打散。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611123127.gif" alt></p>
<h3 id="3-4-Top-N-Rewrite"><a href="#3-4-Top-N-Rewrite" class="headerlink" title="3.4 Top-N Rewrite"></a>3.4 Top-N Rewrite</h3><p>全局排序在流式的场景是很难实现的，但如果只需要计算到目前的 Top-N 极值，问题就变得可解。不过传统数据库求排序的 SQL 语法是通过 ORDER BY 加 LIMIT 限制条数，背后实现的机制也是通过扫描全表排序后再返回 LIMIT 条数的记录。另外如果按照某些字段开窗排序，ORDER BY 也无法满足要求。Flink SQL 借鉴了批场景下开窗求 Top-N 的语法，使用 ROW_NUMBER 语法来做流场景下的 Top-N 排序。</p>
<p>E.g.3 下面这段 SQL 计算了每个类目下销量 Top3 的店铺</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>*</span><br><span class="line"><span class="keyword">FROM</span>(</span><br><span class="line">  <span class="keyword">SELECT</span> *, <span class="comment">-- you can get like shopId or other information from this</span></span><br><span class="line">    ROW_NUMBER() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">category</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> sales <span class="keyword">DESC</span>) <span class="keyword">AS</span> <span class="keyword">rowNum</span></span><br><span class="line">  <span class="keyword">FROM</span> shop_sales ) </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">rowNum</span> &lt;= <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611123233.png" alt></p>
<p>在生成 Plan 方面，ROW_NUMBER 语义对应 OverAggregate 窗口节点和一个过滤行数的 Calc 节点，而这个窗口节点在实现层面需要为每一个到达的数据重新将 State 中的历史数据拿出来排序，这显然不是最优解。</p>
<p>我们知道流式场景求解极大 / 小值的最优操作是通过维护一个 size 为 N 的 minHeap / maxHeap。由实现反推出我们需要在优化器上新增一条规则，在遇到 ROW_NUMBER 生成的逻辑节点后，将其优化为一个特殊的 Rank 节点，对应上述的最优实现方式（当然这只是特殊 Rank 对应的其中一种实现）。这便是 Top-N Rewrite 的核心思想。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200611123313.gif" alt></p>
<br>

<br>

<h1 id="Summary-amp-Futures"><a href="#Summary-amp-Futures" class="headerlink" title="Summary &amp; Futures"></a>Summary &amp; Futures</h1><p><strong>本文内容回顾</strong></p>
<ol>
<li><p>简要介绍 Flink 1.9 + 在 SQL &amp; TableAPI 上引入新架构，统一技术栈，朝着流 &amp; 批一体的方向迈进了一大步。</p>
</li>
<li><p>深入介绍 Flink SQL 引擎的内部运行机制，以及在对用户透明的同时，Flink SQL 在优化方面做的许多工作。</p>
</li>
</ol>
<p><strong>未来工作计划</strong></p>
<ol>
<li>在 Flink 1.11+ 后的版本，Blink Planner 将作为默认的 Planner 提供生产级别的支持。</li>
<li>FLIP-95：重构 TableSource &amp; TableSink 的接口设计，面向流批一体化，在 Source 端支持 changelog 消息流，从而支持 FLIP-105 的 CDC 数据源。</li>
<li>FLIP-105：Flink TableAPI &amp; SQL 对 CDC 的支持。</li>
<li>FLIP-115：扩展目前只支持 CSV 的 FileSystem Connector，使其成为流批统一的 Generalized FileSystem Connector。</li>
<li>FLIP-123：对 Hive DDL 和 DML 的兼容，支持用户在 Flink 中运行 Hive DDL。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/micro-service/istio/istio-doc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Focus-1">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus-1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/micro-service/istio/istio-doc/" itemprop="url">Istio 介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-05T21:17:51+08:00">
                2020-06-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <br>

<blockquote>
<p>官方文档：<a href="https://istio.io/zh/docs/" target="_blank" rel="noopener">https://istio.io/zh/docs/</a></p>
</blockquote>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="Istio-是什么？"><a href="#Istio-是什么？" class="headerlink" title="Istio 是什么？"></a>Istio 是什么？</h2><p>云平台令使用它们的公司受益匪浅。但不可否认的是，上云会给 DevOps 团队带来压力。为了可移植性，开发人员必须使用微服务来构建应用，同时运维人员也正在管理着极端庞大的混合云和多云的部署环境。 Istio 允许您连接、保护、控制和观察服务。</p>
<p>从较高的层面来说，Istio 有助于降低这些部署的复杂性，并减轻开发团队的压力。它是一个完全开源的服务网格，作为透明的一层接入到现有的分布式应用程序里。它也是一个平台，拥有可以集成任何日志、遥测和策略系统的 API 接口。Istio 多样化的特性使您能够成功且高效地运行分布式微服务架构，并提供保护、连接和监控微服务的统一方法。</p>
<h2 id="服务网格是什么？"><a href="#服务网格是什么？" class="headerlink" title="服务网格是什么？"></a>服务网格是什么？</h2><p>Istio 解决了开发人员和运维人员所面临的从单体应用向分布式微服务架构转变的挑战。了解它是如何做到这一点的可以让我们更详细地理解 Istio 的服务网格。</p>
<p>术语<strong>服务网格</strong>用来描述组成这些应用程序的微服务网络以及它们之间的交互。随着服务网格的规模和复杂性不断的增长，它将会变得越来越难以理解和管理。它的需求包括服务发现、负载均衡、故障恢复、度量和监控等。服务网格通常还有更复杂的运维需求，比如 A/B 测试、金丝雀发布、速率限制、访问控制和端到端认证。</p>
<p>Istio 提供了对整个服务网格的行为洞察和操作控制的能力，以及一个完整的满足微服务应用各种需求的解决方案。</p>
<h2 id="为什么使用-Istio？"><a href="#为什么使用-Istio？" class="headerlink" title="为什么使用 Istio？"></a>为什么使用 Istio？</h2><p>通过负载均衡、服务间的身份验证、监控等方法，Istio 可以轻松地创建一个已经部署了服务的网络，而服务的代码只需<a href="https://istio.io/zh/docs/tasks/observability/distributed-tracing/overview/#trace-context-propagation" target="_blank" rel="noopener">很少</a>更改甚至无需更改。通过在整个环境中部署一个特殊的 sidecar 代理为服务添加 Istio 的支持，而代理会拦截微服务之间的所有网络通信，然后使用其控制平面的功能来配置和管理 Istio，这包括：</p>
<ul>
<li>为 HTTP、gRPC、WebSocket 和 TCP 流量自动负载均衡。</li>
<li>通过丰富的路由规则、重试、故障转移和故障注入对流量行为进行细粒度控制。</li>
<li>可插拔的策略层和配置 API，支持访问控制、速率限制和配额。</li>
<li>集群内（包括集群的入口和出口）所有流量的自动化度量、日志记录和追踪。</li>
<li>在具有强大的基于身份验证和授权的集群中实现安全的服务间通信。</li>
</ul>
<p>Istio 为可扩展性而设计，可以满足不同的部署需求。</p>
<h2 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h2><p>Istio 以统一的方式提供了许多跨服务网络的关键功能：</p>
<h3 id="流量管理"><a href="#流量管理" class="headerlink" title="流量管理"></a>流量管理</h3><p>Istio 简单的规则配置和流量路由允许您控制服务之间的流量和 API 调用过程。Istio 简化了服务级属性（如熔断器、超时和重试）的配置，并且让它轻而易举的执行重要的任务（如 A/B 测试、金丝雀发布和按流量百分比划分的分阶段发布）。</p>
<p>有了更好的对流量的可视性和开箱即用的故障恢复特性，您就可以在问题产生之前捕获它们，无论面对什么情况都可以使调用更可靠，网络更健壮。</p>
<p>请参考<a href="https://istio.io/zh/docs/concepts/traffic-management/" target="_blank" rel="noopener">流量管理文档</a>获取更多细节。</p>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>Istio 的安全特性解放了开发人员，使其只需要专注于应用程序级别的安全。Istio 提供了底层的安全通信通道，并为大规模的服务通信管理认证、授权和加密。有了 Istio，服务通信在默认情况下就是受保护的，可以让您在跨不同协议和运行时的情况下实施一致的策略——而所有这些都只需要很少甚至不需要修改应用程序。</p>
<p>Istio 是独立于平台的，可以与 Kubernetes（或基础设施）的网络策略一起使用。但它更强大，能够在网络和应用层面保护pod到 pod 或者服务到服务之间的通信。</p>
<p>请参考<a href="https://istio.io/zh/docs/concepts/security/" target="_blank" rel="noopener">安全文档</a>获取更多细节。</p>
<h3 id="可观察性"><a href="#可观察性" class="headerlink" title="可观察性"></a>可观察性</h3><p>Istio 健壮的追踪、监控和日志特性让您能够深入的了解服务网格部署。通过 Istio 的监控能力，可以真正的了解到服务的性能是如何影响上游和下游的；而它的定制 Dashboard 提供了对所有服务性能的可视化能力，并让您看到它如何影响其他进程。</p>
<p>Istio 的 Mixer 组件负责策略控制和遥测数据收集。它提供了后端抽象和中介，将一部分 Istio 与后端的基础设施实现细节隔离开来，并为运维人员提供了对网格与后端基础实施之间交互的细粒度控制。</p>
<p>所有这些特性都使您能够更有效地设置、监控和加强服务的 SLO。当然，底线是您可以快速有效地检测到并修复出现的问题。</p>
<p>请参考<a href="https://istio.io/zh/docs/concepts/observability/" target="_blank" rel="noopener">可观察性文档</a>获取更多细节。</p>
<h2 id="平台支持"><a href="#平台支持" class="headerlink" title="平台支持"></a>平台支持</h2><p>Istio 独立于平台，被设计为可以在各种环境中运行，包括跨云、内部环境、Kubernetes、Mesos 等等。您可以在 Kubernetes 或是装有 Consul 的 Nomad 环境上部署 Istio。Istio 目前支持：</p>
<ul>
<li>Kubernetes 上的服务部署</li>
<li>基于 Consul 的服务注册</li>
<li>服务运行在独立的虚拟机上</li>
</ul>
<h2 id="整合和定制"><a href="#整合和定制" class="headerlink" title="整合和定制"></a>整合和定制</h2><p>Istio 的策略实施组件可以扩展和定制，与现有的 ACL、日志、监控、配额、审查等解决方案集成。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>要开始使用 Istio，只需遵循以下三个步骤：</p>
<ol>
<li><a href="https://istio.io/zh/docs/setup/getting-started/#platform" target="_blank" rel="noopener">搭建平台</a></li>
<li><a href="https://istio.io/zh/docs/setup/getting-started/#download" target="_blank" rel="noopener">下载 Istio</a></li>
<li><a href="https://istio.io/zh/docs/setup/getting-started/#install" target="_blank" rel="noopener">安装 Istio</a></li>
</ol>
<h2 id="搭建平台"><a href="#搭建平台" class="headerlink" title="搭建平台"></a>搭建平台</h2><p>在安装 Istio 之前，需要一个运行着 Kubernetes 的兼容版本的 cluster。</p>
<p>Istio 1.6 已经在 Kubernetes 版本 1.15, 1.16, 1.17, 1.18 中测试过。</p>
<ul>
<li>通过选择合适的 <a href="https://istio.io/zh/docs/setup/platform-setup/" target="_blank" rel="noopener">platform-specific setup instructions</a> 来创建一个集群。</li>
</ul>
<p>有些平台提供了 managed control plane，您可以使用它来代替手动安装 Istio。如果您选择的平台支持这种方式，并且您选择使用它，那么，在创建完集群后，您将完成 Istio 的安装。因此，可以跳过以下说明。</p>
<h2 id="下载-Istio"><a href="#下载-Istio" class="headerlink" title="下载 Istio"></a>下载 Istio</h2><p>下载 Istio，下载内容将包含：安装文件、示例和 <a href="https://istio.io/zh/docs/reference/commands/istioctl/" target="_blank" rel="noopener">istioctl</a> 命令行工具。</p>
<ol>
<li><p>访问 <a href="https://github.com/istio/istio/releases/tag/1.6.0" target="_blank" rel="noopener">Istio release</a> 页面下载与您操作系统对应的安装文件。在 macOS 或 Linux 系统中，也可以通过以下命令下载最新版本的 Istio：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L https://istio.io/downloadIstio | sh -</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>切换到 Istio 包所在目录下。例如：Istio 包名为 <code>istio-1.6.0</code>，则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd istio-1.6.0</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>   安装目录包含如下内容：</p>
<ul>
<li><code>install/kubernetes</code> 目录下，有 Kubernetes 相关的 YAML 安装文件</li>
<li><code>samples/</code> 目录下，有示例应用程序</li>
<li><code>bin/</code> 目录下，包含 <a href="https://istio.io/zh/docs/reference/commands/istioctl" target="_blank" rel="noopener"><code>istioctl</code></a> 的客户端文件。<code>istioctl</code> 工具用于手动注入 Envoy sidecar 代理。</li>
</ul>
<ol start="3">
<li><p>将 <code>istioctl</code> 客户端路径增加到 path 环境变量中，macOS 或 Linux 系统的增加方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export PATH=$PWD/bin:$PATH</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li>在使用 bash 或 ZSH 控制台时，可以选择启动 <a href="https://istio.io/zh/docs/ops/diagnostic-tools/istioctl#enabling-auto-completion" target="_blank" rel="noopener">auto-completion option</a>。</li>
</ol>
<h2 id="安装-Istio"><a href="#安装-Istio" class="headerlink" title="安装 Istio"></a>安装 Istio</h2><p>请按照以下步骤在您所选的平台上使用 <code>demo</code> 配置文件安装 Istio。</p>
<ol>
<li><p>安装 <code>demo</code> 配置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> istioctl manifest apply --<span class="built_in">set</span> profile=demo</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>为了验证是否安装成功，需要先确保以下 Kubernetes 服务正确部署，然后验证除 <code>jaeger-agent</code> 服务外的其他服务，是否均有正确的 <code>CLUSTER-IP</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get svc -n istio-system</span></span><br><span class="line">NAME                     TYPE           CLUSTER-IP       EXTERNAL-IP     PORT(S)                                                                                                                                      AGE</span><br><span class="line">grafana                  ClusterIP      172.21.211.123   &lt;none&gt;          3000/TCP                                                                                                                                     2m</span><br><span class="line">istio-citadel            ClusterIP      172.21.177.222   &lt;none&gt;          8060/TCP,15014/TCP                                                                                                                           2m</span><br><span class="line">istio-egressgateway      ClusterIP      172.21.113.24    &lt;none&gt;          80/TCP,443/TCP,15443/TCP                                                                                                                     2m</span><br><span class="line">istio-galley             ClusterIP      172.21.132.247   &lt;none&gt;          443/TCP,15014/TCP,9901/TCP                                                                                                                   2m</span><br><span class="line">istio-ingressgateway     LoadBalancer   172.21.144.254   52.116.22.242   15020:31831/TCP,80:31380/TCP,443:31390/TCP,31400:31400/TCP,15029:30318/TCP,15030:32645/TCP,15031:31933/TCP,15032:31188/TCP,15443:30838/TCP   2m</span><br><span class="line">istio-pilot              ClusterIP      172.21.105.205   &lt;none&gt;          15010/TCP,15011/TCP,8080/TCP,15014/TCP                                                                                                       2m</span><br><span class="line">istio-policy             ClusterIP      172.21.14.236    &lt;none&gt;          9091/TCP,15004/TCP,15014/TCP                                                                                                                 2m</span><br><span class="line">istio-sidecar-injector   ClusterIP      172.21.155.47    &lt;none&gt;          443/TCP,15014/TCP                                                                                                                            2m</span><br><span class="line">istio-telemetry          ClusterIP      172.21.196.79    &lt;none&gt;          9091/TCP,15004/TCP,15014/TCP,42422/TCP                                                                                                       2m</span><br><span class="line">jaeger-agent             ClusterIP      None             &lt;none&gt;          5775/UDP,6831/UDP,6832/UDP                                                                                                                   2m</span><br><span class="line">jaeger-collector         ClusterIP      172.21.135.51    &lt;none&gt;          14267/TCP,14268/TCP                                                                                                                          2m</span><br><span class="line">jaeger-query             ClusterIP      172.21.26.187    &lt;none&gt;          16686/TCP                                                                                                                                    2m</span><br><span class="line">kiali                    ClusterIP      172.21.155.201   &lt;none&gt;          20001/TCP                                                                                                                                    2m</span><br><span class="line">prometheus               ClusterIP      172.21.63.159    &lt;none&gt;          9090/TCP                                                                                                                                     2m</span><br><span class="line">tracing                  ClusterIP      172.21.2.245     &lt;none&gt;          80/TCP                                                                                                                                       2m</span><br><span class="line">zipkin                   ClusterIP      172.21.182.245   &lt;none&gt;          9411/TCP                                                                                                                                     2m</span><br></pre></td></tr></table></figure>





</li>
</ol>
<p>   如果集群运行在一个不支持外部负载均衡器的环境中（例如：minikube），<code>istio-ingressgateway</code> 的 <code>EXTERNAL-IP</code> 将显示为 `` 状态。请使用服务的 <code>NodePort</code> 或 端口转发来访问网关。</p>
<p>   请确保关联的 Kubernetes pod 已经部署，并且 <code>STATUS</code> 为 <code>Running</code>：</p>
   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -n istio-system</span></span><br><span class="line">NAME                                                           READY   STATUS      RESTARTS   AGE</span><br><span class="line">grafana-f8467cc6-rbjlg                                         1/1     Running     0          1m</span><br><span class="line">istio-citadel-78df5b548f-g5cpw                                 1/1     Running     0          1m</span><br><span class="line">istio-egressgateway-78569df5c4-zwtb5                           1/1     Running     0          1m</span><br><span class="line">istio-galley-74d5f764fc-q7nrk                                  1/1     Running     0          1m</span><br><span class="line">istio-ingressgateway-7ddcfd665c-dmtqz                          1/1     Running     0          1m</span><br><span class="line">istio-pilot-f479bbf5c-qwr28                                    1/1     Running     0          1m</span><br><span class="line">istio-policy-6fccc5c868-xhblv                                  1/1     Running     2          1m</span><br><span class="line">istio-sidecar-injector-78499d85b8-x44m6                        1/1     Running     0          1m</span><br><span class="line">istio-telemetry-78b96c6cb6-ldm9q                               1/1     Running     2          1m</span><br><span class="line">istio-tracing-69b5f778b7-s2zvw                                 1/1     Running     0          1m</span><br><span class="line">kiali-99f7467dc-6rvwp                                          1/1     Running     0          1m</span><br><span class="line">prometheus-67cdb66cbb-9w2hm                                    1/1     Running     0          1m</span><br></pre></td></tr></table></figure>



<h2 id="后续步骤"><a href="#后续步骤" class="headerlink" title="后续步骤"></a>后续步骤</h2><p>安装 Istio 后，就可以部署您自己的服务，或部署安装程序中系统的任意一个示例应用。</p>
<p>应用程序必须使用 HTTP/1.1 或 HTTP/2.0 协议用于 HTTP 通信；HTTP/1.0 不支持。</p>
<p>当使用 <code>kubectl apply</code> 来部署应用时，如果 pod 启动在标有 <code>istio-injection=enabled</code> 的命名空间中，那么，<a href="https://istio.io/zh/docs/setup/additional-setup/sidecar-injection/#automatic-sidecar-injection" target="_blank" rel="noopener">Istio sidecar 注入器</a>将自动注入 Envoy 容器到应用的 pod 中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl label namespace &lt;namespace&gt; istio-injection=enabled</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl create -n &lt;namespace&gt; -f &lt;your-app-spec&gt;.yaml</span></span><br></pre></td></tr></table></figure>

<p>在没有 <code>istio-injection</code> 标记的命名空间中，在部署前可以使用 <a href="https://istio.io/zh/docs/reference/commands/istioctl/#istioctl-kube-inject" target="_blank" rel="noopener"><code>istioctl kube-inject</code></a> 命令将 Envoy 容器手动注入到应用的 pod 中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> istioctl kube-inject -f &lt;your-app-spec&gt;.yaml | kubectl apply -f -</span></span><br></pre></td></tr></table></figure>

<p>如果您不确定要从哪开始，可以先<a href="https://istio.io/zh/docs/examples/bookinfo/" target="_blank" rel="noopener">部署 Bookinfo 示例</a>，它会让您体验到 Istio 的流量路由、故障注入、速率限制等功能。 然后您可以根据您的兴趣浏览各种各样的 <a href="https://istio.io/zh/docs/tasks/" target="_blank" rel="noopener">Istio 任务</a>。</p>
<p>下列任务都是初学者开始学习的好入口：</p>
<ul>
<li><a href="https://istio.io/zh/docs/tasks/traffic-management/request-routing/" target="_blank" rel="noopener">请求路由</a></li>
<li><a href="https://istio.io/zh/docs/tasks/traffic-management/fault-injection/" target="_blank" rel="noopener">故障注入</a></li>
<li><a href="https://istio.io/zh/docs/tasks/traffic-management/traffic-shifting/" target="_blank" rel="noopener">流量转移</a></li>
<li><a href="https://istio.io/zh/docs/tasks/observability/metrics/querying-metrics/" target="_blank" rel="noopener">查询指标</a></li>
<li><a href="https://istio.io/zh/docs/tasks/observability/metrics/using-istio-dashboard/" target="_blank" rel="noopener">可视化指标</a></li>
<li><a href="https://istio.io/zh/docs/tasks/observability/logs/collecting-logs/" target="_blank" rel="noopener">日志收集</a></li>
<li><a href="https://istio.io/zh/docs/tasks/policy-enforcement/rate-limiting/" target="_blank" rel="noopener">速率限制</a></li>
<li><a href="https://istio.io/zh/docs/tasks/traffic-management/ingress/ingress-control/" target="_blank" rel="noopener">Ingress 网关</a></li>
<li><a href="https://istio.io/zh/docs/tasks/traffic-management/egress/egress-control/" target="_blank" rel="noopener">访问外部服务</a></li>
<li><a href="https://istio.io/zh/docs/tasks/observability/kiali/" target="_blank" rel="noopener">可视化您的网格</a></li>
</ul>
<p>下一步，可以定制 Istio 并部署您自己的应用。在您开始自定义 Istio 来适配您的平台或者其他用途之前，请查看以下资源：</p>
<ul>
<li><a href="https://istio.io/zh/docs/ops/deployment/deployment-models/" target="_blank" rel="noopener">部署模型</a></li>
<li><a href="https://istio.io/zh/docs/ops/best-practices/deployment/" target="_blank" rel="noopener">部署最佳实践</a></li>
<li><a href="https://istio.io/zh/docs/ops/deployment/requirements/" target="_blank" rel="noopener">Pod 需求</a></li>
<li><a href="https://istio.io/zh/docs/setup/" target="_blank" rel="noopener">常规安装说明</a></li>
</ul>
<h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h1 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/java/sharding-sphere/vitness/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Focus-1">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus-1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/java/sharding-sphere/vitness/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-02T21:58:22+08:00">
                2020-06-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/java/collection/java-collection-map-init-oom-bug/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Focus-1">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus-1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/java/collection/java-collection-map-init-oom-bug/" itemprop="url">永远不要使用双花括号初始化实例，否则可能会OOM！</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-23T00:00:00+08:00">
                2020-05-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <br>



<p>生活中的尴尬无处不在，有时候你只是想简单的装一把，但某些“老同志”总是在不经意之间，给你无情的一脚，踹得你简直无法呼吸。</p>
<p>但谁让咱年轻呢？吃亏要趁早，前路会更好。</p>
<p>喝了这口温热的鸡汤之后，咱们来聊聊是怎么回事。</p>
<p>事情是这样的，在一个不大不小的项目中，小王写下了这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap() &#123;&#123;</span><br><span class="line">    put(<span class="string">"map1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">    put(<span class="string">"map2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">    put(<span class="string">"map3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line">map.forEach((k, v) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"key:"</span> + k + <span class="string">" value:"</span> + v);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>本来是用它来替代下面这段代码的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="string">"map1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">map.put(<span class="string">"map2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">map.put(<span class="string">"map3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">map.forEach((k, v) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"key:"</span> + k + <span class="string">" value:"</span> + v);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>两块代码的执行结果也是完全一样的：</p>
<blockquote>
<p>key:map3 value:value3</p>
<p>key:map2 value:value2</p>
<p>key:map1 value:value1</p>
</blockquote>
<p>所以小王正在得意的把这段代码介绍给部门新来的妹子小甜甜看，却不巧被正在经过的老张也看到了。</p>
<p>老张本来只是想给昨天的枸杞再续上一杯 85° 的热水，但说来也巧，刚好撞到了一次能在小甜甜面前秀技术的一波机会，于是习惯性的整理了一下自己稀疏的秀发，便开启了 diss 模式。</p>
<p>“小王啊，你这个代码问题很大啊！”</p>
<p>“怎么能用双花括号初始化实例呢？”</p>
<p>此时的小王被问的一脸懵逼，内心有无数个草泥马奔腾而过，心想你这头老牛竟然也和我争这颗嫩草，但内心却有一种不祥的预感，感觉自己要输，瞬间羞涩的不知该说啥，只能红着小脸，轻轻的“嗯？”了一声。</p>
<p>老张：“使用双花括号初始化实例是会导致内存溢出的啦！侬不晓得嘛？”</p>
<p>小王沉默了片刻，只是凭借着以往的经验来看，这“老家伙”还是有点东西的，于是敷衍的“哦~”了一声，仿佛自己明白了怎么回事一样，，其实内心仍然迷茫的一匹，为了不让其他同事发现，只得这般作态。</p>
<p>于是片刻的敷衍，待老张离去之后，才悄悄的打开了 Google，默默的搜索了一下。</p>
<p>小王：哦，原来如此……</p>
<h1 id="双花括号初始化分析"><a href="#双花括号初始化分析" class="headerlink" title="双花括号初始化分析"></a>双花括号初始化分析</h1><p>首先，我们来看使用双花括号初始化的本质是什么？</p>
<p>以我们这段代码为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap() &#123;&#123;</span><br><span class="line">    put(<span class="string">"map1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">    put(<span class="string">"map2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">    put(<span class="string">"map3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>这段代码<strong>其实是创建了匿名内部类，然后再进行初始化代码块</strong>。</p>
<p>这一点我们可以使用命令<code>javac</code>将代码编译成字节码之后发现，我们发现之前的一个类被编译成两个字节码（.class）文件，如下图所示：</p>
<p>我们使用 Idea 打开<code>DoubleBracket$1.class</code>文件发现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleBracket</span>$1 <span class="keyword">extends</span> <span class="title">HashMap</span> </span>&#123;</span><br><span class="line">    DoubleBracket$<span class="number">1</span>(DoubleBracket var1) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = var1;</span><br><span class="line">        <span class="keyword">this</span>.put(<span class="string">"map1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">        <span class="keyword">this</span>.put(<span class="string">"map2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时我们可以确认，它就是一个匿名内部类。那么问题来了，匿名内部类为什么会导致内存溢出呢？</p>
<br>

<h1 id="匿名内部类的“锅”"><a href="#匿名内部类的“锅”" class="headerlink" title="匿名内部类的“锅”"></a>匿名内部类的“锅”</h1><p>在 Java 语言中非静态内部类会持有外部类的引用，从而导致 GC 无法回收这部分代码的引用，以至于造成内存溢出。</p>
<h3 id="思考-1：为什么要持有外部类？"><a href="#思考-1：为什么要持有外部类？" class="headerlink" title="思考 1：为什么要持有外部类？"></a>思考 1：为什么要持有外部类？</h3><p>这个就要从匿名内部类的设计说起了，在 Java 语言中，非静态匿名内部类的主要作用有两个。</p>
<p><strong>1</strong>、当匿名内部类只在外部类（主类）中使用时，匿名内部类可以让外部不知道它的存在，从而减少了代码的维护工作。</p>
<p><strong>2</strong>、当匿名内部类持有外部类时，它就可以直接使用外部类中的变量了，这样可以很方便的完成调用，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleBracket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String userName = <span class="string">"磊哥"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap() &#123;&#123;</span><br><span class="line">            put(<span class="string">"map1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">            put(<span class="string">"map2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">            put(<span class="string">"map3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">            put(userName, userName);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码可以看出在<code>HashMap</code>的方法内部，可以直接使用外部类的变量<code>userName</code>。</p>
<h3 id="思考-2：它是怎么持有外部类的？"><a href="#思考-2：它是怎么持有外部类的？" class="headerlink" title="思考 2：它是怎么持有外部类的？"></a>思考 2：它是怎么持有外部类的？</h3><p>关于匿名内部类是如何持久外部对象的，我们可以通过查看匿名内部类的字节码得知，我们使用<code>javap -c DoubleBracket\$1.class</code>命令进行查看，其中<code>$1</code>为以匿名类的字节码，字节码的内容如下；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">javap -c DoubleBracket\$<span class="number">1</span>.class</span><br><span class="line">Compiled from <span class="string">"DoubleBracket.java"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">DoubleBracket</span>$1 <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">HashMap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> com.example.DoubleBracket <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  com.example.DoubleBracket$<span class="number">1</span>(com.example.DoubleBracket);</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: aload_1</span><br><span class="line">       2: putfield      #1                  // Field this$0:Lcom/example/DoubleBracket;</span><br><span class="line">       <span class="number">5</span>: aload_0</span><br><span class="line">       6: invokespecial #7                  // Method java/util/HashMap."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">9</span>: aload_0</span><br><span class="line">      10: ldc           #13                 // String map1</span><br><span class="line">      12: ldc           #15                 // String value1</span><br><span class="line">      14: invokevirtual #17                 // Method put:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">      <span class="number">17</span>: pop</span><br><span class="line">      <span class="number">18</span>: aload_0</span><br><span class="line">      19: ldc           #21                 // String map2</span><br><span class="line">      21: ldc           #23                 // String value2</span><br><span class="line">      23: invokevirtual #17                 // Method put:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">      <span class="number">26</span>: pop</span><br><span class="line">      <span class="number">27</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，关键代码的在<code>putfield</code>这一行，此行表示有一个对<code>DoubleBracket</code>的引用被存入到<code>this$0</code>中，也就是说这个匿名内部类持有了外部类的引用。</p>
<p>如果您觉得以上字节码不够直观，没关系，我们用下面的实际的代码来证明一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleBracket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        Map map = <span class="keyword">new</span> DoubleBracket().createMap();</span><br><span class="line">        <span class="comment">// 获取一个类的所有字段</span></span><br><span class="line">        Field field = map.getClass().getDeclaredField(<span class="string">"this$0"</span>);</span><br><span class="line">        <span class="comment">// 设置允许方法私有的 private 修饰的变量</span></span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(field.get(map).getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">createMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 双花括号初始化</span></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap() &#123;&#123;</span><br><span class="line">            put(<span class="string">"map1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">            put(<span class="string">"map2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">            put(<span class="string">"map3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们开启调试模式时，可以看出<code>map</code>中持有了外部对象<code>DoubleBracket</code>，如下图所示：</p>
<p>以上代码的执行结果为：</p>
<blockquote>
<p>class com.example.DoubleBracket</p>
</blockquote>
<p>从以上程序输出结果可以看出：<strong>匿名内部类持有了外部类的引用，因此我们才可以使用<code>$0</code>正常获取到外部类，并输出相关的类信息</strong>。</p>
<br>

<h1 id="什么情况会导致内存泄漏？"><a href="#什么情况会导致内存泄漏？" class="headerlink" title="什么情况会导致内存泄漏？"></a>什么情况会导致内存泄漏？</h1><p>当我们把以下正常的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap() &#123;&#123;</span><br><span class="line">        put(<span class="string">"map1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">        put(<span class="string">"map2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">        put(<span class="string">"map3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    <span class="comment">// 业务处理....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改为下面这个样子时，可能会造成内存泄漏：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map <span class="title">createMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap() &#123;&#123;</span><br><span class="line">        put(<span class="string">"map1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">        put(<span class="string">"map2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">        put(<span class="string">"map3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么用了「可能」而不是「一定」会造成内存泄漏？</p>
<p>这是因为当此<code>map</code>被赋值为其他类属性时，可能会导致 GC 收集时不清理此对象，这时候才会导致内存泄漏。可以关注我「Java中文社群」后面会专门写一篇关于此问题的文章。</p>
<br>

<h1 id="如何保证内存不泄露？"><a href="#如何保证内存不泄露？" class="headerlink" title="如何保证内存不泄露？"></a>如何保证内存不泄露？</h1><p>要想保证双花扣号不泄漏，办法也很简单，只需要将<code>map</code>对象声明为<code>static</code>静态类型的就可以了，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title">createMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap() &#123;&#123;</span><br><span class="line">        put(<span class="string">"map1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">        put(<span class="string">"map2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">        put(<span class="string">"map3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>什么？你不相信！</p>
<p>没关系，我们用事实说话，使用以上代码，我们重新编译一份字节码，查看匿名类的内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">javap -c  DoubleBracket\$<span class="number">1</span>.class</span><br><span class="line">Compiled from <span class="string">"DoubleBracket.java"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">DoubleBracket</span>$1 <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">HashMap</span> </span>&#123;</span><br><span class="line">  com.example.DoubleBracket$<span class="number">1</span>();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/util/HashMap."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: aload_0</span><br><span class="line">       5: ldc           #7                  // String map1</span><br><span class="line">       7: ldc           #9                  // String value1</span><br><span class="line">       9: invokevirtual #11                 // Method put:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">      <span class="number">12</span>: pop</span><br><span class="line">      <span class="number">13</span>: aload_0</span><br><span class="line">      14: ldc           #17                 // String map2</span><br><span class="line">      16: ldc           #19                 // String value2</span><br><span class="line">      18: invokevirtual #11                 // Method put:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">      <span class="number">21</span>: pop</span><br><span class="line">      <span class="number">22</span>: aload_0</span><br><span class="line">      23: ldc           #21                 // String map3</span><br><span class="line">      25: ldc           #23                 // String value3</span><br><span class="line">      27: invokevirtual #11                 // Method put:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">      <span class="number">30</span>: pop</span><br><span class="line">      <span class="number">31</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这次的代码我们可以看出，<strong>已经没有<code>putfield</code>关键字这一行了，也就是说静态匿名类不会持有外部对象的引用了</strong>。</p>
<h3 id="为什么静态内部类不会持有外部类的引用？"><a href="#为什么静态内部类不会持有外部类的引用？" class="headerlink" title="为什么静态内部类不会持有外部类的引用？"></a>为什么静态内部类不会持有外部类的引用？</h3><p>原因其实很简单，因为匿名内部类是静态的之后，它所引用的对象或属性也必须是静态的了，因此就可以直接从 JVM 的 Method Area（方法区）获取到引用而无需持久外部对象了。</p>
<br>

<h1 id="双花括号的替代方案"><a href="#双花括号的替代方案" class="headerlink" title="双花括号的替代方案"></a>双花括号的替代方案</h1><p>即使声明为静态的变量可以避免内存泄漏，但依旧不建议这样使用，为什么呢？</p>
<p>原因很简单，项目一般都是需要团队协作的，假如那位老兄在不知情的情况下把你的<code>static</code>给删掉呢？这就相当于设置了一个隐形的“坑”，其他不知道的人，一不小心就跳进去了，所以我们可以尝试一些其他的方案，比如 Java8 中的 Stream API 和 Java9 中的集合工厂等。</p>
<h3 id="替代方案-1：Stream"><a href="#替代方案-1：Stream" class="headerlink" title="替代方案 1：Stream"></a>替代方案 1：Stream</h3><p>使用 Java8 中的 Stream API 替代，示例如下。原代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList() &#123;&#123;</span><br><span class="line">    add(<span class="string">"Java"</span>);</span><br><span class="line">    add(<span class="string">"Redis"</span>);</span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>替代代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Stream.of(<span class="string">"Java"</span>, <span class="string">"Redis"</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h3 id="替代方案-2：集合工厂"><a href="#替代方案-2：集合工厂" class="headerlink" title="替代方案 2：集合工厂"></a>替代方案 2：集合工厂</h3><p>使用集合工厂的<code>of</code>方法替代，示例如下。原代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span> HashMap() &#123;&#123;</span><br><span class="line">    put(<span class="string">"map1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">    put(<span class="string">"map2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>替代代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map map = Map.of(<span class="string">"map1"</span>, <span class="string">"Java"</span>, <span class="string">"map2"</span>, <span class="string">"Redis"</span>);</span><br></pre></td></tr></table></figure>

<p>显然使用 <code>Java9</code> 中的方案非常适合我们，简单又酷炫，只可惜我们还在用 <code>Java 6...6...6...</code>心碎了一地。</p>
<br>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文我们讲了双花括号初始化因为会持有外部类的引用，从而可以会导致内存泄漏的问题，还从字节码以及反射的层面演示了这个问题。</p>
<p>要想保证双花括号初始化不会出现内存泄漏的办法也很简单，只需要被<code>static</code>修饰即可，但这样做还是存在潜在的风险，可能会被某人不小心删除掉，于是我们另寻它道，发现了可以使用 <code>Java8</code> 中的 <code>Stream</code> 或 <code>Java9</code> 中的集合工厂<code>of</code>方法替代 双大括号。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/mysql/mysql-issue-max-connect-errors/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Focus-1">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus-1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/mysql/mysql-issue-max-connect-errors/" itemprop="url">被我误解的max_connect_errors</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-22T00:00:00+08:00">
                2020-05-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <br>

<blockquote>
<p>原文：<a href="https://developer.aliyun.com/article/755441" target="_blank" rel="noopener">https://developer.aliyun.com/article/755441</a></p>
</blockquote>
<h2 id="第一节-什么是max-connect-errors"><a href="#第一节-什么是max-connect-errors" class="headerlink" title="第一节 什么是max_connect_errors"></a>第一节 什么是<a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fserver-system-variables.html%23sysvar_max_connect_errors" target="_blank" rel="noopener">max_connect_errors</a></h2><p>一开始接触这个参数的时候，感觉他和max_connections的含义差不多，字面意思简单明了，这个参数的含义是最大连接错误数，翻翻mysql的文档中的解释是If more than this many successive connection requests from a host are interrupted without a successful connection, the server blocks that host from further connections,大意是：如果mysql服务器<strong>连续</strong>接收到了来自于<strong>同一个主机</strong>的请求，且这些<strong>连续</strong>的请求全部都<strong>没有成功的建立连接</strong>就被断开了，当这些<strong>连续</strong>的请求的累计值大于 max_connect_errors的设定值时，mysql服务器就会阻止这台主机后续的所有请求。”without a successful connection”那太好办了，故意输错密码不就行了，并且网上搜索了下该参数的说明，大量的文章充斥着” 防止暴力破解密码”的内容，于是兴高采烈的去做了测试。以下测试基于自建的mysql（非rds for mysql），由于rds for mysql无法直接设置set global，设置时需要在”rds控制台-参数这里”里进行设置：<a href="https://help.aliyun.com/document_detail/26179.html?spm=5176.11065259.1996646101.searchclickresult.44156de7pLffcV" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/26179.html?spm=5176.11065259.1996646101.searchclickresult.44156de7pLffcV</a></p>
<br>

<h2 id="第二节-测试max-connect-errors"><a href="#第二节-测试max-connect-errors" class="headerlink" title="第二节 测试max_connect_errors"></a>第二节 测试<a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fserver-system-variables.html%23sysvar_max_connect_errors" target="_blank" rel="noopener">max_connect_errors</a></h2><p>1,创建账号：</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/e7e62a3ea66248ab87c6a1da1b147896.png" alt="image.png"></p>
<p>2,设置max_connect_errors为3：</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/474298780e8146799e583ef69c8ece4a.png" alt="image.png"></p>
<p>3，故意输错密码3次，第四次使用正确密码登录进行验证：</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/8b0044d120c04ff8b8c721c78107207f.png" alt="image.png"></p>
<p>4,结论是第四次依然可以登录，即密码不对（认证失败）不属于” ”without a successful connection””的范畴，网上的” 防止暴力破解密码”也不成立了。</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/1ee779a11f0d41b880675f2833656da7.png" alt="image.png"></p>
<br>

<h2 id="第三节-继续分析max-connect-errors"><a href="#第三节-继续分析max-connect-errors" class="headerlink" title="第三节 继续分析max_connect_errors"></a>第三节 继续分析<a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fserver-system-variables.html%23sysvar_max_connect_errors" target="_blank" rel="noopener">max_connect_errors</a></h2><p>再继续看文档，发现还有以下说明：</p>
<p>You can unblock blocked hosts by flushing the host cache. To do so, issue a <a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fflush.html%23flush-hosts" target="_blank" rel="noopener">FLUSH HOSTS</a> statement or execute a <a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fmysqladmin.html" target="_blank" rel="noopener">mysqladmin flush-hosts</a> command.</p>
<p>大意是：</p>
<p>当你遇到主机被阻止的时候，你可以清空host cache来解决，具体的清空方法是执行flush hosts或者在mysql服务器的shell里执行 <a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fmysqladmin.html" target="_blank" rel="noopener">mysqladmin flush-hosts</a>操作</p>
<p>既然清空host cache可以解决主机被阻止访问的问题，那应该与host cache有些关系，看看host cache的介绍可能会有些眉目，关于host cache，文档解释如下：</p>
<p>The MySQL server maintains a host cache in memory that contains information about clients: IP address, host name, and error information. The server uses this cache for nonlocal TCP connections. It does not use the cache for TCP connections established using a loopback interface address (127.0.0.1 or ::1), or for connections established using a Unix socket file, named pipe, or shared memory.</p>
<p>大意是：</p>
<p>Mysql服务器会在内存里管理一个host cache，host cache里保存了一些客户端的ip地址，主机名，以及这个客户端在与server建立连接时遇到的一些错误信息，host cache对不是本地的TCP连接才有效，所以host cache对127.0.0.1 或者::1是无效的，并且对于Unix socket file、named pipe以及 shared memory方式建立的连接也是无效的。并且通过了解，host cache的内容可以通过performance_schema.host_cache来查看，通过performance_schema.host_cache表里的几个列的描述信息，对之前的测试不成立的原因有些了解了，部分相关列如下：</p>
<ul>
<li>IP<br>The IP address of the client that connected to the server, expressed as a string.</li>
</ul>
<p>连接到mysql server的主机的连接地址</p>
<ul>
<li>HOST<br>The resolved DNS host name for that client IP, or NULL if the name is unknown.</li>
</ul>
<p>通过dns解析IP地址获取到的该IP地址对应的mysql client的主机名</p>
<ul>
<li>SUM_CONNECT_ERRORS<br>The number of connection errors that are deemed “blocking” (assessed against the max_connect_errors system variable). Only protocol handshake errors are counted, and only for hosts that passed validation (HOST_VALIDATED = YES).</li>
<li>COUNT_HANDSHAKE_ERRORS<br>The number of errors detected at the wire protocol level.</li>
</ul>
<p>通过SUM_CONNECT_ERRORS(连接错误计数)描述，重点是红色部分：只计算协议握手过程的错误(Only protocol handshake errors are counted),也就是说max_connect_errors 可能记录的是协议(不确定是tcp协议还是应用协议，通过抓包以及COUNT_HANDSHAKE_ERRORS的” the wire protocol level”说明可能是指应用协议)的握手过程中出现的错误 ，也就是可以说网络不好(无法顺利握手)会导致该问题。</p>
<br>

<h2 id="第四节-继续测试max-connect-errors"><a href="#第四节-继续测试max-connect-errors" class="headerlink" title="第四节 继续测试max_connect_errors"></a>第四节 继续测试<a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fserver-system-variables.html%23sysvar_max_connect_errors" target="_blank" rel="noopener">max_connect_errors</a></h2><p>通过之前的说明，需要模拟应用协议握手失败的情况，最后考虑使用telnet一些来做测试</p>
<p>1,创建账号</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/40952e24f8244f9ca6e48b5c29a32de9.png" alt="image.png"></p>
<p>2,设置max_connect_errors为3：</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/d571db4eee624bbabaa2a362090121c1.png" alt="image.png"></p>
<p>3,先使用telnet 10.26.254.217 3306连接3次，第四次使用正确的账号密码尝试登陆：</p>
<p>telnet前查看performance_schema.host_cache的记录为空</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/949aead2e79c4bcd9bb585ee450b4126.png" alt="image.png"></p>
<p>第一次telnet 10.26.254.217 3306</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/84dbb96324234398b7b4d9b46016940f.png" alt="image.png"></p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/aa85fe91b1c14d3599d9529dc5116d8f.png" alt="image.png"></p>
<p>第二次 telnet 10.26.254.217 3306</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/38fa608ac69948328adbd4df1eb66fb1.png" alt="image.png"></p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/84e5ecbcd4954b81818a12f2800fabe9.png" alt="image.png"></p>
<p>第三次telnet 10.26.254.217 3306</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/9ebc5df826144464aa49705656b1a5a5.png" alt="image.png"></p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/f3c46a8b2bd54e46ba2d173a2879b4ee.png" alt="image.png"></p>
<p>第四次执行mysql -h10.26.254.217 -utestcon -p123 -P3306</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/81d064ae8f594d5aad095910872aefd6.png" alt="image.png"></p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/de855eea61c44cb0a6a9129b95c25728.png" alt="image.png"></p>
<p>问题复现了，出现了错误提示ERROR 1129 (HY000): Host ‘10.24.236.231’ is blocked because of many connection errors; unblock with ‘mysqladmin flush-hosts’</p>
<br>

<h2 id="第五节-ERROR-1129-HY000-问题延伸"><a href="#第五节-ERROR-1129-HY000-问题延伸" class="headerlink" title="第五节 ERROR 1129 (HY000)问题延伸"></a>第五节 ERROR 1129 (HY000)问题延伸</h2><p>解决ERROR 1129 (HY000)的方法是执行flush host或者<a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fmysqladmin.html" target="_blank" rel="noopener"> mysqladmin flush-hosts</a>，其目的是为了清空host cache里的信息，那是不是说不使用host cache就可以了？使host cache不生效的方式有如下两种：</p>
<p>1,设置 <a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fserver-system-variables.html%23sysvar_host_cache_size" target="_blank" rel="noopener">host_cache_size</a> 为0/ 打开<a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fserver-options.html%23option_mysqld_skip-host-cache" target="_blank" rel="noopener">skip-host-cache</a></p>
<p>2,打开<a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fserver-options.html%23option_mysqld_skip-name-resolve" target="_blank" rel="noopener">skip-name-resolve</a></p>
<p>需要通过测试看下推测是否生效</p>
<p>5.1 设置 <a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fserver-system-variables.html%23sysvar_host_cache_size" target="_blank" rel="noopener">host_cache_size 为0</a>/ 打开<a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fserver-options.html%23option_mysqld_skip-host-cache" target="_blank" rel="noopener">skip-host-cache</a><br>1,设置<a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fserver-system-variables.html%23sysvar_host_cache_size" target="_blank" rel="noopener">host_cache_size</a>为0</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/3d56c2d7717a4491a520da9d1feeac30.png" alt="image.png"></p>
<p>2,再次查询performance_schema.host_cache</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/89b5d7e6da314e3d8ed1a1555bcd3c33.png" alt="image.png"></p>
<p>3,继续之前的测试：先使用telnet 10.26.254.217 3306连接3次，第四次使用正确的账号密码尝试登陆</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/2d945a9ea18b484cb18867538c0fdd93.png" alt="image.png"></p>
<p>更改已经生效，<a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fserver-system-variables.html%23sysvar_max_connect_errors" target="_blank" rel="noopener">max_connect_errors</a>的作用无效了</p>
<p>5.2 打开<a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fserver-options.html%23option_mysqld_skip-name-resolve" target="_blank" rel="noopener">skip-name-resolve</a><br>1,在cnf配置文件里设置<a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fserver-options.html%23option_mysqld_skip-name-resolve" target="_blank" rel="noopener">skip-name-resolve </a>以此打开<a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fserver-options.html%23option_mysqld_skip-name-resolve" target="_blank" rel="noopener">skip-name-resolve</a></p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/533ea2abead949eca053687ae90b10c7.png" alt="image.png"></p>
<p>2,继续之前的测试：先使用telnet 10.26.254.217 3306连接3次，第四次使用正确的账号密码尝试登陆</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/633cfc564e104211b103eacc6a19c2c0.png" alt="image.png"></p>
<p>3,查询performance_schema.host_cache</p>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/d063f01a34474c3f97cb01eb8580536d.png" alt="image.png"></p>
<p>更改已经生效，<a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.243b3fd2jm9Efr&url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.6%2Fen%2Fserver-system-variables.html%23sysvar_max_connect_errors" target="_blank" rel="noopener">max_connect_errors</a>的作用无效了，RDS for mysql 的skip_name_resolve是on的状态，</p>
<p>所以很少会出现ERROR 1129 (HY000)的错误</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/algorithm/dynamic-programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Focus-1">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus-1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/algorithm/dynamic-programming/" itemprop="url">动态规划的理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-15T00:00:00+08:00">
                2020-05-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <br>



<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20201105115038321.png" alt="image-20201105115038321"></p>
<p><strong>动态规划</strong>，一直以来听着就是一种很高深莫测的算法思想。尤其是上学时候算法的第一堂课，老师巴拉巴拉列了一大堆的算法核心思想，<strong>贪心、回溯、动态规划</strong>… …，开始感觉要在算法世界里游刃有余的进行解决各种各样牛B问题了，没想到的还是稀里糊涂学过了之后还就真的是学过了（大学的课程还真是一个样子）。再后来才明白，大学的课程一般来说就是入门级讲解，用来开拓眼界的，真正想要有一番自己的见解，必须要在背后下一番辛苦，形成自己的<strong>思考逻辑</strong>。</p>
<p>再后来返回头来看，<strong>动态规划</strong>理解起来还是比较困难，什么<strong>重叠子问题、动态转移方程，优化点</strong>等等等等，稀里糊涂，最后痛定思痛，好好看着其他人的分享理解了一部分，疯狂刷题几十道。算是基本可以佛挡杀佛了.</p>
<p>在我的这些学习积累过程中，总结出来希望可以给到大家一点小小的帮助，相信在读完这篇文章的时候，你会感觉到<strong>动态规划</strong>给你带来的奇妙之处。也一定对<strong>动态规划</strong>形成自己的<strong>思考方式</strong>. 很🐂的DP！！！</p>
<h2 id="首先，先大致列下这篇文章会讲到什么"><a href="#首先，先大致列下这篇文章会讲到什么" class="headerlink" title="首先，先大致列下这篇文章会讲到什么"></a>首先，先大致列下这篇文章会讲到什么</h2><h4 id="1-相较于暴力解法，动态规划带给我们的是什么？为什么会有重叠子问题以及怎么去避免的"><a href="#1-相较于暴力解法，动态规划带给我们的是什么？为什么会有重叠子问题以及怎么去避免的" class="headerlink" title="1.相较于暴力解法，动态规划带给我们的是什么？为什么会有重叠子问题以及怎么去避免的?"></a>1.相较于暴力解法，动态规划带给我们的是什么？为什么会有重叠子问题以及怎么去避免的?</h4><h4 id="2-用不同难度的动态规划问题举例说明，-最后会使用《打家劫舍》系列三个题再重温一次"><a href="#2-用不同难度的动态规划问题举例说明，-最后会使用《打家劫舍》系列三个题再重温一次" class="headerlink" title="2.用不同难度的动态规划问题举例说明， 最后会使用《打家劫舍》系列三个题再重温一次."></a>2.用不同难度的动态规划问题举例说明， 最后会使用《打家劫舍》系列三个题再重温一次.</h4><p>看完本篇文章后，相信大家会对DP问题会有一个初步的思考，一定会入门。后面大家可以继续练习相关问题，熟能生巧，思考的多了就会形成自己的思维逻辑.</p>
<p>好了，话不多说，开搞…</p>
<h2 id="一、动态规划带给我们的优势"><a href="#一、动态规划带给我们的优势" class="headerlink" title="一、动态规划带给我们的优势"></a>一、动态规划带给我们的优势</h2><p><strong>很有趣，一定要看完，必定有收获，加油！💪💪💪</strong></p>
<p>平时在我们算法设计的过程中，一般讲求的是算法的执行效率和空间效率的利用情况</p>
<p>也就是我们熟知的<strong>时间复杂度</strong>（执行时耗费时间的长度）和<strong>空间复杂度</strong>（执行时占用存储单元的长度）</p>
<p>那下面用<strong>时间复杂度和空间复杂度</strong>来评估下<strong>传统算法设计</strong>和用<strong>动态规划思想</strong>解决下的效率情况</p>
<h4 id><a href="#" class="headerlink" title=" "></a> </h4><h4 id="传统递归-vs-DP"><a href="#传统递归-vs-DP" class="headerlink" title="传统递归 vs. DP"></a>传统递归 vs. DP</h4><p>先用一个被大佬们举例举到烂的🌰，这个栗子很烂，但是真的<strong>很香</strong>：必须着重<strong>强调</strong>.</p>
<p><strong>《斐波那契（Fibonacci）数列的第n项》</strong></p>
<p><strong>举荐理由：</strong>在我自己看来Fibonacci是动态规划设计中的入门级案例，就好比说编程中的“hello world”，大数据中的“word count”.</p>
<p>Fibonacci几乎完美的诠释了<strong>动态规划带来的思想和技巧</strong>然而没有任何其他的要考虑的细枝末节，这种很清晰的方法看起来很适合整个的动态规划的思维方式，很适合入门来进行的思考方式.</p>
<p>接下来咱们先来看题目：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">写一个函数，输入n，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</span><br><span class="line"></span><br><span class="line">F(0) = 0, F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br><span class="line">斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</span><br></pre></td></tr></table></figure>

<p>比较一下传统递归解法和动态规划思想下的解决对比</p>
<h4 id="1-先-递归解决"><a href="#1-先-递归解决" class="headerlink" title="1. 先 递归解决"></a>1. 先 递归解决</h4><p>传统对于这种题目的思考方式会利用递归求解，做起来比较简单，就是不断的去递归调用，看下面代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    i = 0</span><br><span class="line">    def fib_recur(self, N):</span><br><span class="line">        print &quot;F(&quot;,self.i,&quot;) = &quot;, N   # 此处仅仅来看递归输出的N</span><br><span class="line">        self.i += 1</span><br><span class="line">        </span><br><span class="line">        if N &lt;= 1:</span><br><span class="line">            return N</span><br><span class="line">        return self.fib_recur(N-1) + self.fib_recur(N-2)  # 递归输出</span><br></pre></td></tr></table></figure>

<p>输出的结果：</p>
<p><strong>重复计算</strong></p>
<p>明显可以看到，总计 8 次的计算过程中，相同的计算结果有三对进行了<strong>重复计算</strong>（下图中同色项，不包含灰色），也就是说在递归的过程中，把曾经计算过的项进行了<strong>又一次的重复计算</strong>，这样对于时间效率是比较低的，唯一的好处可能就是代码看起来比较好懂，但是终归不是一个好的算法设计方法。</p>
<p>代码中，在计算N的时候就去递归计算 <code>fib(N-1) + fib(N-2)</code>，那么，这种情况下的计算过程中。会是下面图中的一个计算过程。</p>
<p>可以发现，会有相当一部分的重复计算，这样对于时间都是重复的消耗。</p>
<blockquote>
<p>参考图中相同颜色的项，比如说粉色的重复计算、黄色的重复计算等</p>
<p><strong>注意</strong>：递归中没有对空间进行了增加，始终都是同样的长度，仅仅是不断的弹出和压入</p>
</blockquote>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20201105115233611.png" alt="image-20201105115233611"></p>
<p>为了更好的说明这种重复计算带来时间效率的低下。再比如说，相比上述图中的计算节点，再增加一个节点的计算，增加计算F(5)，那么由于递归的计算方式，会有更多的项（下图中线框中部分）进行了重复的计算。在计算<code>F(5)</code>的时候，会递归调用<code>F(4)</code>和<code>F(3)</code>，而在下图中，计算<code>F(4)</code>的时候，又会完整的去计算<code>F(3)</code>。这样，如果N很大的话，会有更大的时间消耗.</p>
<p>这样，这棵树的规模进行进行成倍增加，时间复杂度很明显的进行了成倍的扩张。对于时间上来说是很恐怖的.</p>
<p>时间复杂度带来的低效率严重超过了代码的可读性，所以我们可以想办法将<strong>过去计算</strong>过的节点<strong>进行保存</strong>。这样，我们就会用到下面要说的动态规划思想带来的时间上的高效.</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20201105115319198.png" alt="image-20201105115319198"></p>
<blockquote>
<p>时间复杂度： —&gt; 指数级</p>
<p>空间复杂度：</p>
</blockquote>
<h4 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h4><h4 id="2-后-动态规划解决"><a href="#2-后-动态规划解决" class="headerlink" title="2. 后 动态规划解决"></a>2. 后 动态规划解决</h4><p><strong>大概解释一下字面意思：</strong></p>
<p><strong>动态规划：\</strong>我们不直接去解决问题，而是在每一步解决问题的时候，达到每一步的最优情况。换句话说，就是在每一步解决问题过程中，利用*<em>过去的状态*</em>以及<strong>当前状态</strong>的情况而达到一个当前的最优状态.</p>
<p><strong>规划：\</strong>在一般解决该类问题的时候，会有一个“填表格”的过程，无论是简单情况下的*<em>一维表格*</em>还是复杂一点的<strong>二维表格</strong>，都是以<strong>开辟空间换时间</strong>的思想，以争取最佳的时间效率. （保存过程中间值，方便后续直接使用）.</p>
<p><strong>动态：</strong>用上面的案例来说，递归解决过程中的每一步都会从基本问题不断的“自顶向下”去求解，在每一步骤中，会有相同的计算逻辑进行了重复的计算。相比于递归思想，动态规划思想增加了对历史上计算结果的保存，逐步记录下中间的计算结果，在每一步求得最优值.</p>
<p>因此，动态规划可以避免重复计算，达到了时间上的最优，从指数级变为常数级别，相较于开辟的一段内存空间存放中间过程值的开销，是非常值得的.</p>
<p><strong>那么，接下来咱们依照动态规划的思路进行对Fibonacci进行下解决</strong></p>
<p>依据题中的规则：</p>
<p>F(0) = 0, F(1) = 1</p>
<p>F(N) = F(N - 1) + F(N - 2), when N &gt; 1</p>
<p>那么，👇👇F(N) 的值只与他的前两个状态有关系👇👇</p>
<p>a. 初始化值 : F(0) = 0, F(1) = 1 b. 想要计算得到F(2)， 那么F(2) = F(0) + F(1) –&gt; 保存 F(2) c. 想要计算得到F(3)， 那么F(3) = F(2) + F(1) –&gt; 保存 F(3) d. 想要计算得到F(3)， 那么F(4) = F(3) + F(2) –&gt; 保存 F(4)</p>
<p>利用动态规划思想，以一维数组辅助实现的Fibonacci，看下图</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20201105115351513.png" alt="image-20201105115351513"></p>
<p>是不是很简单的思路，仅仅靠保存过程中的一些值就能很简单的利用循环就可以实现了，没必要用递归反复计算进行实现。</p>
<p>想要计算得到第 n 个值的多少？那么，以下几点是我们必须要做到的</p>
<p>a. <strong>定义一个一维数组</strong> —&gt; 一般用dp来命名</p>
<p>b. <strong>动态方程的设定</strong> —&gt; 题中的F(N) = F(N - 1) + F(N - 2)</p>
<p>c. <strong>初始化数值</strong> —&gt; F(0) = 0和F(1) = 1</p>
<p>上述的 a、b 和 c 点就是动态规划思想的几个核心要素</p>
<p>下面来看下要实现的代码（代码中，用dp来代替上面的F()）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def fib(self, N):</span><br><span class="line">        if N == 0:</span><br><span class="line">            return 0</span><br><span class="line">     </span><br><span class="line">        dp = [0 for _ in range(N+1)]  # 1定义dp[i]保存第i个计算得到的数值</span><br><span class="line">        dp[0] = 0    # 2初始化</span><br><span class="line">        dp[1] = 1   # 2初始化</span><br><span class="line">        for i in range(2, N+1): # 3动态方程实现，由于0和1都实现了赋值，现在需要从第2个位置开始赋值</span><br><span class="line">            dp[i] = dp[i - 1] + dp[i - 2]</span><br><span class="line">       </span><br><span class="line">        print dp   # 记录计算过程中的次数，与上述递归形成对比</span><br><span class="line">        return dp[N]</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 1, 2, 3]</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>以上，最重要的就是1 2 3 点，而执行过程参照<strong>输出</strong>对比递归算法，计算少了很多，同样的计算只计算了一次。</p>
<blockquote>
<p>时间复杂度：</p>
<p>空间复杂度：</p>
</blockquote>
<p>介绍了上面的内容了，此处来条分割线吧，针对上述的 <strong>递归 vs. DP</strong></p>
<hr>
<p>既然动态规划的方案也介绍了，下面咱们再仔细看看，是否有优化的空间，毕竟对于一个算法方案的设计，都有找到其优化点，无论是时间还是空间的效率都想要达到一个理想的值。</p>
<h4 id="3-动态规划-优化"><a href="#3-动态规划-优化" class="headerlink" title="3. 动态规划 + 优化"></a>3. 动态规划 + 优化</h4><p>咱们看下这张图解，发现每个计算节点都<strong>只与前两个项有关系</strong>。换句话说，咱们只要保存两个值就好了，计算新的节点值的时候，把新的值赋值给前两个值的第一个就好了</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20201105115424911.png" alt="image-20201105115424911"></p>
<p>话说只要两个值，现在定义两个变量 dp1 和 dp2。那么，现在咱们一步一步模拟一下：</p>
<p>a. 初始化值 : F(0) = 0, F(1) = 1</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20201105115445574.png" alt="image-20201105115445574"></p>
<p>b. 想要计算得到F(2)， 那么F(2) = F(0) + F(1) –&gt; 保存 F(2)</p>
<p>顺带将F(1)赋值给dp1， f(2)赋值给dp2</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20201105115505726.png" alt="image-20201105115505726"></p>
<p>c. 想要计算得到F(3)， 那么F(3) = F(2) + F(1) –&gt; 保存 F(3)</p>
<p>顺带将F(2)赋值给dp1， F(3)赋值给dp2</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20201105115528231.png" alt="image-20201105115528231"></p>
<p>d. 想要计算得到F(3)， 那么F(4) = F(3) + F(2) –&gt; 保存 F(4)</p>
<p>顺带将F(3)赋值给dp1， F(4)赋值给dp2</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20201105115545179.png" alt="image-20201105115545179"></p>
<p>至此为止，整个过程仅仅用到了两个变量来存储过程中产生的值，也就之前没有优化的空间效率得到了优化</p>
<p>咱们把代码也贴一下吧，供参考</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def fib_dp1(self, N):</span><br><span class="line">        if N == 0: return 0</span><br><span class="line"></span><br><span class="line">        dp1, dp2 = 0, 1</span><br><span class="line"></span><br><span class="line">        for i in range(2, N+1):</span><br><span class="line">            dp1 = dp1 + dp2</span><br><span class="line">            dp1, dp2 = dp2, dp1</span><br><span class="line"></span><br><span class="line">        return dp2</span><br></pre></td></tr></table></figure>

<p>看起来是不是更加简洁了。</p>
<p>洋洋洒洒不知不觉写了这么多了。</p>
<blockquote>
<p>如果有读者说这太简单了，我这篇文章内容面对的是小白级别的，如果读者是中等往上的水平，可直接跳到后面的案例三开始参考。</p>
<p>另外，如果有任何的意见可随时对我的文章进行评论，欢迎&amp;感谢大家一起讨论</p>
<p>也可关注公众号「计算广告生态」，回复“DP”，获取该文件的pdf文件</p>
</blockquote>
<p>大家感觉这个例子怎么样，三点说明：<strong>1.定义dp数组 2.动态方程 3.初始化数值</strong></p>
<p>这也说明了为什么用<strong>斐波那契数列</strong>来引入<strong>动态规划</strong>的，因为斐波那契数列本身就明确的告诉你动态方程是什么，初始化的值是什么，所以好好的体会这种思想，尤其是从传统递归 -&gt; 动态规划的思想解决，再到优化的方面，很值得深思。</p>
<p>那接下来，咱们就找几个有代表性的栗子来尝尝鲜</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20201105115614450.png" alt="image-20201105115614450"></p>
<h2 id="二、动态规划四大解题步骤处理问题"><a href="#二、动态规划四大解题步骤处理问题" class="headerlink" title="二、动态规划四大解题步骤处理问题"></a>二、动态规划四大解题步骤处理问题</h2><p>上面用斐波那契数列问题，引出了下面的几点，在这里再详细赘述一下</p>
<p>在后面的案例中将会尽量严格按照这几个步骤进行解决问题</p>
<blockquote>
<p>步骤一：定义dp数组的含义</p>
<p>步骤二：定义状态转移方程</p>
<p>步骤三：初始化过程转移的初始值</p>
<p>步骤四：可优化点(可选)</p>
</blockquote>
<h4 id="步骤一：定义dp数组的含义"><a href="#步骤一：定义dp数组的含义" class="headerlink" title="步骤一：定义dp数组的含义"></a>步骤一：定义dp数组的含义</h4><p>绝大部分情况下，我们需要定义一维数组或者二维数组进行存储在计算过程中产生的最优值，这里为什么是最优值呢？是因为在解决问题过程中，一般情况dp数组用来保存<strong>从开始到当前情况的最优值</strong>，故而保存的是截止到目前的最优值，避免重复计算（这里看起来思维有混乱的同学们，想想上面Fibonacci 递归解法和动态规划的对比）</p>
<p><strong>所以，dp无论是一维的还是二维的，要想清楚代表什么，一般来说代表的是截止到目前情况下的最优值</strong></p>
<h4 id="步骤二：定义状态转移方程"><a href="#步骤二：定义状态转移方程" class="headerlink" title="步骤二：定义状态转移方程"></a>步骤二：定义状态转移方程</h4><p>什么是动态转移方程？如果有一个问题摆在我们面前，然后这个问题在解决的过程中，会发现有很多的重叠的子问题，重叠子结构，而通过这些子问题的解决，最终将会把该问题进行解决</p>
<p>通俗来说，在解决问题过程中，能够发现一个不断解决子问题的动态规律，比如说Fibonacci中的F(N) = F(N - 1) + F(N - 2)，而在其他的可以用动态规划解决的问题中，需要我们自己去发现这样的内在规律。这个是最难的也是最终于要的，只要这一步解决了，接下来我们解决这个问题基本就没问题了.</p>
<h4 id="步骤三：初始化过程转移的初始值"><a href="#步骤三：初始化过程转移的初始值" class="headerlink" title="步骤三：初始化过程转移的初始值"></a>步骤三：初始化过程转移的初始值</h4><p>顺着步骤二的思路来，既然动态方程定义好了，是不是需要一个<strong>支点</strong>来撬动它进行不断的计算下去。</p>
<p>那么，这个<strong>支点</strong>就需要我们来初始定义，将动态方程激活，进行计算。举例来说Fibonacci中的F(0) = 0和F(1) = 1，有了这两个值，它的动态方程F(N) = F(N - 1) + F(N - 2)就可以进行下去了</p>
<p>这个就是我们要想好的初始值，实际问题可能还需要我们想想清楚.</p>
<h4 id="步骤四：可优化点-可选"><a href="#步骤四：可优化点-可选" class="headerlink" title="步骤四：可优化点(可选)"></a>步骤四：可优化点(可选)</h4><p>可优化的这里，最重要的会是dp数组这块，也会有不同问题不同的优化点</p>
<p>在例子中，我们会进行不同的优化.</p>
<p>总之一点，建议大家动笔多画画图，很多细节慢慢就会出现了.</p>
<h3 id="案例一：打家劫舍I-「来自leetcode198」"><a href="#案例一：打家劫舍I-「来自leetcode198」" class="headerlink" title="案例一：打家劫舍I 「来自leetcode198」"></a>案例一：打家劫舍I 「来自leetcode198」</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,7,9,3,1]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure>

<p>把经典案例系列拆分开讨论下吧，咱们首先将「打家劫舍I」来看看</p>
<p>该题可以用动态规划的思想来解决的原因是，在小偷不断偷取的过程中，始终想要偷得的物品价值最大，最优，每一步骤都与之前的偷取情况有关系，而且每一步都要考虑是否能偷，是否会带来最大利益，这就使得我们可以用动态规划的思想来解决问题。然后严格按照四步骤进行解题.</p>
<h5 id="步骤一：定义dp数组的含义-1"><a href="#步骤一：定义dp数组的含义-1" class="headerlink" title="步骤一：定义dp数组的含义"></a>步骤一：定义dp数组的含义</h5><p>之前提到的，dp数组存储的值一般代表截止目前的最优值，在该题目中，我们定义：</p>
<p> <strong>dp[i] 代表到达第 i 个房屋偷得的最高金额，也就是当前最大子序和</strong></p>
<p>无论房屋有几间，最后我们取到dp数组的最后一个值就求得小偷偷得的最高金额</p>
<h5 id="步骤二：找出关系元素间的动态方程"><a href="#步骤二：找出关系元素间的动态方程" class="headerlink" title="步骤二：找出关系元素间的动态方程"></a>步骤二：找出关系元素间的动态方程</h5><p>动态规划解决的问题，一般来说就是解决最优子问题，“自顶向下” 的去不断的计算每一步骤的最优值。</p>
<p>也就是想要得到dp[i]的值，我们必须要知道dp[i-1]，dp[i-2]，dp[i-3] … 的每一步的最优值，在这个状态转移的过程中，我们必须要想清楚怎么去定义关系式。然而在每一步的计算中，都与前几项有关系，这个固定的关系就是我们要寻找的重叠子问题，也同样是接下来要详细定义的动态方程</p>
<p>该题目中，当小偷到达第 i 个屋子的时候，他的选择有两种：一种是偷，另外一种是不偷， 然后选择价值较大者</p>
<p>a. 偷的情况计算：必然是dp[3] = nums[2] + dp[1]，如果是偷取该屋子的话，相邻屋子是不能偷取的，因此，通项式子是：dp[i] = nums[i-1] + dp[i-2]</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20201105115637272.png" alt="image-20201105115637272"></p>
<p>b. 不偷的情况计算：必然是dp[3] = dp[2]，如果是不偷取该屋子的话，相邻屋子就是其最优值，因此，通项式子是：dp[i] = dp[i-1]</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20201105115659499.png" alt="image-20201105115659499"></p>
<p>最后，要想偷得最高金额，那么，必须选取在偷与不偷之间的最大值作为我们是否选取的关键点。即：</p>
<p> <strong>动态方程:</strong> dp[i] = max(dp[i-1], nums[i-1]+dp[i-2])</p>
<h5 id="步骤三：初始化数值设定"><a href="#步骤三：初始化数值设定" class="headerlink" title="步骤三：初始化数值设定"></a>步骤三：初始化数值设定</h5><p>初始化: 给没有房子时，dp一个位置，即：dp[0]  1 当size=0时，没有房子，dp[0]=0；2 当size=1时，有一间房子，偷即可：dp[1]=nums[0]</p>
<p>那么，按照这个思路来整理一下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line"></span><br><span class="line">    def rob(self, nums):</span><br><span class="line">      # 1.dp[i] 代表当前最大子序和</span><br><span class="line">      # 2.动态方程: dp[i] = max(dp[i-1], nums[i-1]+dp[i-2])</span><br><span class="line">      # 3.初始化: 给没有房子时，dp一个位置，即：dp[0]</span><br><span class="line">      #   3.1 当size=0时，没有房子，dp[0]=0；</span><br><span class="line">      #   3.2 当size=1时，有一间房子，偷即可：dp[1]=nums[0]</span><br><span class="line">      size = len(nums)</span><br><span class="line">      if size == 0:</span><br><span class="line">        return 0</span><br><span class="line"></span><br><span class="line">      dp = [0 for _ in range(size+1)]</span><br><span class="line"></span><br><span class="line">      dp[0] = 0</span><br><span class="line">      dp[1] = nums[0]</span><br><span class="line">      for i in range(2, size+1):</span><br><span class="line">        dp[i] = max(dp[i-1], nums[i-1]+dp[i-2])</span><br><span class="line">        return dp[size]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度：O(N)</p>
<p>空间复杂度：O(N)</p>
</blockquote>
<p>那下面想想看有没有可优化的地方，尽量的释放一部分计算机资源</p>
<h5 id="步骤四：优化"><a href="#步骤四：优化" class="headerlink" title="步骤四：优化"></a>步骤四：优化</h5><p>从 dp[i] = max(dp[i-1], nums[i-1]+dp[i-2]) 关系来看，每一次动态变化，都与前两次状态有关系（dp[i-1], dp[i-2])，而前面的一些值是没有必要留存的.</p>
<p>所以，dp只需要定义两个变量就好，将空间复杂度降为O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line"></span><br><span class="line">    def rob_o(self, nums):</span><br><span class="line">        # 依照上面的思路，其实我们用到的数据永远都是dp的dp[i-1]和dp[i-2]两个变量</span><br><span class="line">        # 因此，我们可以使用两个变量来存放前两个状态值</span><br><span class="line">        # 空间使用由O(N) -&gt; O(1)</span><br><span class="line"></span><br><span class="line">        size = len(nums)</span><br><span class="line">        if size == 0:</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        dp1 = 0</span><br><span class="line">        dp2 = nums[0]</span><br><span class="line">        for i in range(2, size+1):</span><br><span class="line">            dp1 = max(dp2, nums[i-1]+dp1)</span><br><span class="line">            dp1, dp2 = dp2, dp1</span><br><span class="line">        return dp2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度：O(N)</p>
<p>空间复杂度：O(1)</p>
</blockquote>
<p>说完《打家劫舍I 》，中间穿插另外一道题目，利用二维dp来解决的一个问题。</p>
<p>最后再说说《打家劫舍II 》和《打家劫舍III》，把这一系列的<strong>打家劫舍</strong>问题搞明白了，相信你对动态规划有一个较为深刻的入门体验</p>
<blockquote>
<p>如果有读者说这太简单了，我这篇文章内容面对的是小白级别的，如果读者是中等往上的水平，可直接跳到后面的案例三开始参考。</p>
<p>另外，如果有任何的意见可随时对我的文章进行评论，欢迎&amp;感谢大家一起讨论</p>
</blockquote>
<h3 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h3><h3 id="案例二：不同路径「来自leetcode62」"><a href="#案例二：不同路径「来自leetcode62」" class="headerlink" title="案例二：不同路径「来自leetcode62」"></a>案例二：不同路径「来自leetcode62」</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20201105115801740.png" alt="image-20201105115801740"></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: m = 3, n = 2</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line"></span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: m = 7, n = 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure>

<p><em>提示：</em></p>
<p>1 &lt;= m, n &lt;= 100 题目数据保证答案小于等于 2 * 10 ^ 9</p>
<p>下面依然按照四个步骤来进行讨论：</p>
<h5 id="步骤一：定义dp数组的含义-2"><a href="#步骤一：定义dp数组的含义-2" class="headerlink" title="步骤一：定义dp数组的含义"></a>步骤一：定义dp数组的含义</h5><p>当前这道题是从左上角到右下角的，题目中规定只能向右或者向下走，所以我们必须要定义一个二维数组来保存计算过程中的值。所以，这块定义：</p>
<p> <strong>dp[i][j]: 代表到达位置 (i, j) 的所有路径的总数</strong></p>
<p>即：机器人从左上角到右下角所有路径的总和，dp中每个位置的值代表行走到达 (i, j) 每个位置的总共的路径数</p>
<h5 id="步骤二：找出关系元素间的动态方程-1"><a href="#步骤二：找出关系元素间的动态方程-1" class="headerlink" title="步骤二：找出关系元素间的动态方程"></a>步骤二：找出关系元素间的动态方程</h5><p>由于题目中规定只能向右或者向下走，所以在机器人行进的时候，只能是向右或向下.</p>
<p>那么，分别讨论下两种情况，想要到达位置(i, j)，可以从位置(i-1, j)或者(i, j-1)出发到达。因此，到达位置(i, j) 的总的路径数一定是 <strong>到达位置(i-1, j)路径数</strong> + <strong>到达位置(i, j-1)路径数</strong>。那么，现在可以定义动态方程：</p>
<p> <strong>动态方程：dp[i][j] = dp[i-1][j] + dp[i][j-1]</strong></p>
<h5 id="步骤三：初始化数值设定-1"><a href="#步骤三：初始化数值设定-1" class="headerlink" title="步骤三：初始化数值设定"></a>步骤三：初始化数值设定</h5><p>很明显，在机器人走第 0 行，第 0 列的时候，无论怎么走，都只有 1 种走法。</p>
<p>因此，初始化值的设定，一定是 dp[0..m][1] 或者 dp[1][0..n] 都等于1</p>
<p>因此初始值如下：</p>
<p> <strong>dp[0] [0….n-1] = 1;</strong> // 机器人一直向右走，第 0 列统统为 1</p>
<p> <strong>dp[0…m-1] [0] = 1;</strong> // 机器人一直向下走，第 0 列统统为 1</p>
<p>现在，按照这个思路来整理一下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line"></span><br><span class="line">    def uniquePaths1(self, m, n):</span><br><span class="line"></span><br><span class="line">        # 初始化表格，由于初始化0行 0列都为1。那么，先全部置为1</span><br><span class="line">        dp = [[1 for _ in range(m)] for _ in range(n)]</span><br><span class="line"></span><br><span class="line">        for i in range(1, n):</span><br><span class="line">            for j in range(1, m):</span><br><span class="line">                dp[i][j] = dp[i-1][j] + dp[i][j-1]</span><br><span class="line"></span><br><span class="line">        return dp[n-1][m-1]</span><br></pre></td></tr></table></figure>

<p>上述代码中由于dp[0..m][1] 或者 dp[1][0..n] 都等于1，所以在定义二维数组dp时候，统统赋初始值为 1</p>
<p>然后从位置(1, 1)开始计算每个位置的总路径数</p>
<blockquote>
<p>时间复杂度：O(M*N)</p>
<p>空间复杂度：O(M*N)</p>
</blockquote>
<p>既然到这里了，下面再想想看有没有可优化的地方</p>
<h5 id="步骤四：优化-1"><a href="#步骤四：优化-1" class="headerlink" title="步骤四：优化"></a>步骤四：优化</h5><p>可以依照前面的解决的思路，应该也可以从空间上进行一定的优化</p>
<p>参照前面的案例，之前定义的是一维数组dp，优化点是每一步骤都只与前面的两个计算好的数值有关系，然后优化点就是将dp[N] -&gt; dp1和dp2，空间复杂度由 O(N) -&gt; O(1)，如果是很大规模的数据计算的话，空间效率提升了不少.</p>
<p>现在这个例子中的动态方程是<strong>dp[i][j] = dp[i-1][j] + dp[i][j-1]</strong>，很明显，每一步骤中的状态值只与左边相邻的值和上面的值相关。举例（为了方便，用 3*4 来举例）：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20201105115821303.png" alt="image-20201105115821303"></p>
<p>这个完整的图片描述中，机器人从左上角的位置(1, 1)开始移动，逐渐每一步都根据动态方程进行前进，明显的可以看出机器人每移动一格，所得到的路径总和只与它的上方和左方数值有关系。也就是我们会发现，机器人移动到第2行的时候，第0行数据完全是没有用的状态。</p>
<p>因此，这个优化点就出来了，在算法设计的时候，dp仅仅定义2行N列的数组就ok了，省去了m-2行的空间开销。这个代码如果大家想明白了请自行设计出来，自己写出来一定会有更加深刻的理解，再强调：多思考，形成潜移默化的思维方式.</p>
<p>看完这个步骤之后，是不是很明显的优化点，为什么上面没有给出大家代码呢？是因为我看到貌似可以继续优化的点（粘住空间优化项了哈哈哈），那就继续在空间开销上做文章。</p>
<p><strong>引导：</strong>根据上述咱们的优化方案，说道 “机器人移动到第2行的时候，第0行数据完全是没有用的状态”，其实当前聪明的读者你想想，再看看，下面的图中（从上图截取过来）。其实，不仅仅是第 0 行完全没用了，而且在第2 行做移动的时候，移动到位置(i, j)的时候，计算好位置(i, j)，那么接下来，位置(i-1, j)的数据也就没用了。换句话说，边走，第 1 行开始的某些数据也就没用了，还在占着空间</p>
<p> <strong>这块大家一定多想想，多理解，多画图</strong></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20201105115838014.png" alt="image-20201105115838014"></p>
<p>下面按照这种思路，看下图的步骤，也画好了用一维数组进行解决问题，也画出来每一步骤与上图的类比过程：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20201105115857548.png" alt="image-20201105115857548"></p>
<p>在这里，有犯困的同学可以自己动手画一画，理解一下，个人感觉是一个很好的思维扩展</p>
<p>接下来，就按照这样的思路进行代码实现，会发现码起来很简单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line"></span><br><span class="line">    def uniquePaths2(self, m, n):</span><br><span class="line">        if m &gt; n:</span><br><span class="line">            m, n = n, m</span><br><span class="line"></span><br><span class="line">        dp = [1 for _ in range(m)]</span><br><span class="line"></span><br><span class="line">        for i in range(1, n):</span><br><span class="line">            for j in range(1, m):</span><br><span class="line">                dp[j] = dp[j] + dp[j-1]</span><br><span class="line"></span><br><span class="line">        return dp[m-1]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度：O(m*n)</p>
<p>空间复杂度：O(min(m ,n))</p>
</blockquote>
<p>是不是从思维方面简单干净了许多</p>
<p>搞清楚上面的栗子之后呢，我们将上面的例题进行一个简单的难度增加，说白了，就是在路上打几个阻碍点</p>
<p>来看:</p>
<h3 id="案例三：不同路径II-「来自leetcode63」"><a href="#案例三：不同路径II-「来自leetcode63」" class="headerlink" title="案例三：不同路径II 「来自leetcode63」"></a>案例三：不同路径II 「来自leetcode63」</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20201105115914203.png" alt="image-20201105115914203"></p>
<blockquote>
<p>说明：m 和 n 的值均不超过 100。</p>
</blockquote>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">输出: 2</span><br><span class="line">解释:</span><br><span class="line">3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 2 条不同的路径：</span><br><span class="line"></span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>

<p><strong>咱们先看一下题中的两个关键点：</strong> 关键点1：只能向右或者向下 关键点2：有障碍物为1， 无障碍物为0</p>
<p>根据 关键点1 和 关键点2 依然按照四个步骤来进行讨论：</p>
<h5 id="步骤一：定义dp数组的含义-3"><a href="#步骤一：定义dp数组的含义-3" class="headerlink" title="步骤一：定义dp数组的含义"></a>步骤一：定义dp数组的含义</h5><p>这个题目中定义的dp数组是和上一个例题中定义的dp数组的含义是相同的，但由于该题中已经定义有数组obstacleGrid，可以直接利用，无需额外开辟空间 那么，就利用obstacleGrid作为动态规划中存储计算过程中的最优值</p>
<h5 id="步骤二：找出关系元素间的动态方程-2"><a href="#步骤二：找出关系元素间的动态方程-2" class="headerlink" title="步骤二：找出关系元素间的动态方程"></a>步骤二：找出关系元素间的动态方程</h5><p>参照上一题目，规定动态方程: obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1] 由于机器人在移动过程中有障碍物，那么，对上面动态方程加一些限制条件 a.若当前 obstacleGrid[i][j] 为0。那么，直接计算动态方程下的计算过程 b.若当前 obstacleGrid[i][j] 不为0。那么，直接置该位置的值为0</p>
<p>所以，在进行动态方程遍历的时候，先进行 obstacleGrid[i][j]的判断，再进行动态方程的计算执行</p>
<h5 id="步骤三：初始化数值设定-2"><a href="#步骤三：初始化数值设定-2" class="headerlink" title="步骤三：初始化数值设定"></a>步骤三：初始化数值设定</h5><p>相比于上一题目，相似的是，在机器人走第 0 行，第 0 列的时候，无论怎么走，都只有 1 种走法  但由于有障碍物，那走到障碍物的时候，后面都是走不下去的（下图用第一行来举例）。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20201105115928800.png" alt="image-20201105115928800"></p>
<p>所以，初始化第 0 行，第 0 列的时候，障碍物 1 后面的都是不可达的。所以，初始化行和列的逻辑表达：</p>
<p> <strong>该位置是否可达=前一个位置的状态and该位置能否可达 得到能否到达这个位置</strong></p>
<p>只有前一个位置为1（可达，只有1种方式） ，当前位置为0（无障碍物）这种情况才能到达该位置，然后为该位置设 1 （可达，只有1种方式）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 0 行初始化表达式: </span><br><span class="line">obstacleGrid[0][row] = int(obstacleGrid[0][row] == 0 and obstacleGrid[0][row-1] == 1)</span><br><span class="line"># 0 列初始化表达式: </span><br><span class="line">obstacleGrid[clo][0] = int(obstacleGrid[clo][0] == 0 and obstacleGrid[clo-1][0] == 1)</span><br></pre></td></tr></table></figure>

<p>这些都准备就绪之后，按照相关思路进行编码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line"></span><br><span class="line">    def uniquePathsWithObstacles1(self, obstacleGrid):</span><br><span class="line">       # 行列长度</span><br><span class="line">        m = len(obstacleGrid)</span><br><span class="line">        n = len(obstacleGrid[0])</span><br><span class="line"></span><br><span class="line">        # 如果在位置(0, 0)，哪里都去不了，直接返回0</span><br><span class="line">        if obstacleGrid[0][0] == 1:</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        # 否则，位置(0, 0)可以到达</span><br><span class="line">        obstacleGrid[0][0] = 1</span><br><span class="line"></span><br><span class="line">        # 初始化 0 列</span><br><span class="line">        for clo in range(1, m):</span><br><span class="line">            obstacleGrid[clo][0] = int(obstacleGrid[clo][0] == 0 and obstacleGrid[clo-1][0] == 1)</span><br><span class="line"></span><br><span class="line">        # 初始化 0 行</span><br><span class="line">        for row in range(1, n):</span><br><span class="line">            obstacleGrid[0][row] = int(obstacleGrid[0][row] == 0 and obstacleGrid[0][row-1] == 1)</span><br><span class="line"></span><br><span class="line">        # 从位置(1, 1)根据动态方程开始计算</span><br><span class="line">        for i in range(1, m):</span><br><span class="line">            for j in range(1, n):</span><br><span class="line">                if obstacleGrid[i][j] == 0:</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]</span><br><span class="line">                else:</span><br><span class="line">                    obstacleGrid[i][j] = 0</span><br><span class="line"></span><br><span class="line">        return obstacleGrid[m-1][n-1]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度: O(mxn)</p>
<p>空间复杂度: O(1)</p>
</blockquote>
<h5 id="步骤四：优化-2"><a href="#步骤四：优化-2" class="headerlink" title="步骤四：优化"></a>步骤四：优化</h5><p>这块的优化先不谈了，这里基本没有什么优化点，之前都是由于自己要开辟内存空间，通过空间的优化来进行，而本题是在给定的数组中进行操作的</p>
<p>有了这几个案例的基础之后，咱们后面把经典的《打家劫舍》系列剩下的两个题目讨论完，就先告一段落，后面也希望以不同的方式与大家多多交流，互相学习</p>
<p>如果有读者看着累了，可以先保存，收藏下来，待消化了前面的内容，方便再回来看看。</p>
<h3 id="案例四：打家劫舍II-「来自leetcode213」"><a href="#案例四：打家劫舍II-「来自leetcode213」" class="headerlink" title="案例四：打家劫舍II 「来自leetcode213」"></a>案例四：打家劫舍II 「来自leetcode213」</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure>

<p>与《打家劫舍I》不同的是，《打家劫舍I》的屋子是线性的，而《打家劫舍II》是环状的，所以要考虑的点会增加一些，因为首位相连接的情况，咱们分为下面三种情况进行设定：</p>
<p>a. 不偷首偷尾</p>
<p>b. 偷首不偷尾</p>
<p>c. 首位都不偷 显然，c 种方式损失太大，不会获得最高的金额，故选取 a 和 b。那么，下面分为两种情况，分别计算不包含首和不包含尾这两种情况来判断小偷哪种方式偷取的金额最高。</p>
<p>下面依然按照之前的四个步骤来进行分析</p>
<h5 id="步骤一：定义dp数组的含义-4"><a href="#步骤一：定义dp数组的含义-4" class="headerlink" title="步骤一：定义dp数组的含义"></a>步骤一：定义dp数组的含义</h5><p>dp[i] 代表的含义和之前一致，dp数组存储的值一般代表截止目前的最优值</p>
<p>所以，<strong>dp[i] 代表到达第 i 个房屋偷得的最高金额，也就是当前最大子序和</strong></p>
<p>但是最后会讨论<strong>不包含首</strong>和<strong>不包含尾</strong>这两种情况下得到的dp数组的最后一位，然后获取其中较大者，就是我们要取得的最高金额</p>
<p>#####步骤二：找出关系元素间的动态方程</p>
<p>动态方程可参照《打家劫舍I》，有很详细的图解过程，该例子动态方程的变化和之前是完全一致的：</p>
<p> <strong>dp[i] = max(dp[i-1], nums[i-1]+dp[i-2])</strong></p>
<h5 id="步骤三：初始化设定"><a href="#步骤三：初始化设定" class="headerlink" title="步骤三：初始化设定"></a>步骤三：初始化设定</h5><p>初始化: 给没有房子时，dp一个位置，即：dp[0] </p>
<p>  a. 当size=0时，没有房子，小偷没办法偷：dp[0]=0；</p>
<p>  b. 当size=1时，有一间房子，只要偷即可：dp[1]=nums[0]</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20201105115946976.png" alt="image-20201105115946976"></p>
<p>由于屋子首位相连接，所以在计算时候，直接分为两种情况。第一种略过第一个屋子，第二种略过第二个屋子，这样得到的两个数组结果。最后只要比较最后一位数值的大小就ok了。解决！</p>
<p>该例子步骤三之后，感兴趣的同学可以自己写一下代码，和《打家劫舍I》的代码很类似，后面我写了优化后的代码，可能会更加的明白怎么写。咱们直接到步骤四，有了上面的案例，直接来看看优化后的方案:</p>
<h5 id="步骤四：优化-3"><a href="#步骤四：优化-3" class="headerlink" title="步骤四：优化"></a>步骤四：优化</h5><p>同样从 dp[i] = max(dp[i-1], nums[i-1]+dp[i-2]) 关系来看，每一次动态变化，都与前两次状态有关系（dp[i-1], dp[i-2])，而前面的一些值是没有必要留存的，只要保存两个变量来保存过程最优值就好.</p>
<p>代码中有详细的注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line"></span><br><span class="line">    def rob(self, nums):</span><br><span class="line">        # 点睛：与打家劫舍I的区别是屋子围成了一个环</span><br><span class="line">        #   那么，很明显可以分为三种情况：</span><br><span class="line">        #   1. 首位都不偷</span><br><span class="line">        #   2. 偷首不偷尾</span><br><span class="line">        #   3. 不偷首偷尾</span><br><span class="line">        # 显然，第1种方式损失太大，选取2、3。</span><br><span class="line">        # 那么，分为两种情况，分别计算不包含首和不包含尾这两种情况来判断哪个大哪个小</span><br><span class="line"></span><br><span class="line">        # 1.dp[i] 代表当前最大子序和</span><br><span class="line">        # 2.动态方程: dp[i] = max(dp[i-1] and , nums[i-1]+dp[i-2])</span><br><span class="line">        # 3.初始化: 给没有房子时，dp一个位置，即：dp[0]</span><br><span class="line">        #   3.1 当size=0时，没有房子，dp[0]=0；</span><br><span class="line">        #   3.2 当size=1时，有一间房子，偷即可：dp[1]=nums[0]</span><br><span class="line"></span><br><span class="line">        # 依照《打家劫舍I》的优化方案进行计算</span><br><span class="line"></span><br><span class="line">        # nums处理，分别切割出去首和去尾的子串</span><br><span class="line">        nums1 = nums[1:]</span><br><span class="line">        nums2 = nums[:-1]</span><br><span class="line"></span><br><span class="line">        size = len(nums)</span><br><span class="line">        if size == 0:</span><br><span class="line">            return 0</span><br><span class="line">        if size == 1:</span><br><span class="line">            return nums[0]</span><br><span class="line"></span><br><span class="line">        def handle(size, nums):</span><br><span class="line">            dp1 = 0</span><br><span class="line">            dp2 = nums[0]</span><br><span class="line">            for i in range(2, size+1):</span><br><span class="line">                dp1 = max(dp2, nums[i-1]+dp1)</span><br><span class="line">                dp1, dp2 = dp2, dp1</span><br><span class="line">            return dp2</span><br><span class="line"></span><br><span class="line">        res1 = handle(size-1, nums1)</span><br><span class="line">        res2 = handle(size-1, nums2)</span><br><span class="line"></span><br><span class="line">        return max(res1, res2)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度：O(N)</p>
<p>空间复杂度：O(1)</p>
</blockquote>
<p>再看看下面小偷遇到的情况，感叹：即使当小偷，也要步步规划才能拿到最高的金额啊…</p>
<h3 id="案例五：打家劫舍III-「来自leetcode337」"><a href="#案例五：打家劫舍III-「来自leetcode337」" class="headerlink" title="案例五：打家劫舍III 「来自leetcode337」"></a>案例五：打家劫舍III 「来自leetcode337」</h3><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3,null,3,null,1]</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">  / \</span><br><span class="line">   2   3</span><br><span class="line">    \   \ </span><br><span class="line">     3   1</span><br><span class="line"></span><br><span class="line">输出: 7 </span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,4,5,1,3,null,1]</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">  / \</span><br><span class="line">   4   5</span><br><span class="line">  / \   \ </span><br><span class="line"> 1   3   1</span><br><span class="line">输出: 9</span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.</span><br></pre></td></tr></table></figure>

<p>题目出的很好，但是立马会给人一种小偷也不是好当的的赶脚…</p>
<p>言归正传，咱们先来说说题目本身</p>
<p>《打家劫舍》的小偷从一维线性到环形，再到二维矩形的屋子？是我想简单了，直接就干到树形了，是不是看着很香，而且很想，看下去，研究研究…</p>
<p>来整理几点思路，再来按照四步走：</p>
<p>1.由于房屋是树状的，因此，我们可以使用遍历树的传统方法进行遍历(前序、中序、后续) 2.简单的思路是，从树低进行往上遍历，拿到最优的打劫值。可以选用后续遍历 3.得到每一节点的最优值，最后选取最优的结果</p>
<p>依然按照三个步骤来进行分析（无优化点）</p>
<h5 id="步骤一：定义dp数组的含义-5"><a href="#步骤一：定义dp数组的含义-5" class="headerlink" title="步骤一：定义dp数组的含义"></a>步骤一：定义dp数组的含义</h5><p>dp[i]代表该节点及以下打最多的劫（拿到最多的钱）</p>
<h5 id="步骤二：找出关系元素间的动态方程-3"><a href="#步骤二：找出关系元素间的动态方程-3" class="headerlink" title="步骤二：找出关系元素间的动态方程"></a>步骤二：找出关系元素间的动态方程</h5><p>根据我们每走到一个节点，都会有两种情况，那就是 <strong>偷(1)</strong> 与 <strong>不偷(0)</strong>。我们分开来讨论：</p>
<p>a. 用 <strong>dp[0]</strong> 代表不偷取该节点到目前为止拿到最多的钱，那么儿子节点偷不偷都ok。</p>
<p>所以： <strong>dp[0] = max(left[0], left[1]) + max(right[0], right[1])</strong></p>
<p>b. 用 <strong>dp[1]</strong> 代表偷了该节点到目前为止拿到最多的钱，则儿子节点都不能被偷。</p>
<p>所以：<strong>dp[1] = value + left[0] + right[0]</strong> (value代表该节点的价值)</p>
<p>有看不懂的地方吗？再紧接着解释一下：</p>
<p>left[0]代表不偷取左孩子拿到最高的金额</p>
<p>left[1]代表偷取左孩子拿到最高的金额</p>
<p>right[0]代表不偷取右孩子拿到最高的金额</p>
<p>right[1]代表偷取右孩子拿到最高的金额</p>
<p> <em>如果还有不太懂的话，留言或者添加我的公众号「计算广告生态」联系我，随时骚扰我哈</em></p>
<h5 id="步骤三：初始化设定-1"><a href="#步骤三：初始化设定-1" class="headerlink" title="步骤三：初始化设定"></a>步骤三：初始化设定</h5><p>该例子的初始化比较简单，就是当前树的形状为空的时候，直接返回dp[0, 0]</p>
<p>下面贴出完整代码，其中包含<strong>树的初始化</strong>代码 &amp;&amp; 一大堆的注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line">class TreeNode(object):</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = None</span><br><span class="line">        self.right = None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution():</span><br><span class="line"></span><br><span class="line">    def rob(self, root):</span><br><span class="line"></span><br><span class="line">        # 说明：</span><br><span class="line">        # 1.由于房屋是树状的，因此，我们可以使用遍历树的传统方法进行遍历(前序、中序、后续)</span><br><span class="line">        # 2.简单的思路是，从树低进行往上遍历，拿到最优的打劫值。可以选用后续遍历</span><br><span class="line">        # 3.得到每一节点的最优值，最后选取最优的结果</span><br><span class="line"></span><br><span class="line">        # 1.dp[i]代表该节点及以下拿到的最多的钱</span><br><span class="line">        # 2.动态方程：</span><br><span class="line">        #   2.1 dp[0]代表不偷该节点拿到最多的钱，则儿子节点偷不偷都ok。dp[0] = max(left[0], left[1]) + max(right[0], right[1])</span><br><span class="line">        #   2.2 dp[1]代表偷了该节点拿到最多的钱，则儿子节点都不能被偷。dp[1] = var + left[0] + right[0]</span><br><span class="line">        # 3.初始化：当前树的形状为空的时候，直接返回dp[0, 0]</span><br><span class="line">        def postTrasval(root):</span><br><span class="line">            dp = [0, 0]</span><br><span class="line">            if not root:</span><br><span class="line">                return dp</span><br><span class="line">            left = postTrasval(root.left)</span><br><span class="line">            right = postTrasval(root.right)</span><br><span class="line"></span><br><span class="line">            dp[0] = max(left[0], left[1]) + max(right[0], right[1])</span><br><span class="line">            dp[1] = root.val + left[0] + right[0]</span><br><span class="line"></span><br><span class="line">            return dp</span><br><span class="line"></span><br><span class="line">        dp = postTrasval(root)</span><br><span class="line">        return max(dp[0], dp[1])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    # initial tree structure</span><br><span class="line">    T = TreeNode(3)</span><br><span class="line">    T.left = TreeNode(2)</span><br><span class="line">    T.right = TreeNode(3)</span><br><span class="line">    T.left.right = TreeNode(3)</span><br><span class="line">    T.right.right = TreeNode(1)</span><br><span class="line"></span><br><span class="line">    # The solution to the Question</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.rob(T))</span><br></pre></td></tr></table></figure>

<p>至此为止，想要讲解的全部完毕了</p>
<p>洋洋洒洒过万字，自己都没想到写了这么多</p>
<p>在强调一点吧，这些题目全部理解 外加 自己另外练习，一定能够cover<strong>关于动态规划80%以上的题目</strong>，基本上都是dp为一维数组，二维数组的题目，很少有很奇怪的题型出现。所以，本文将《打家劫舍》经典案例详细讲解了一次，还有不同路径的问题，也是很经典的题目，而经典题目一定很具有代表性。优化方向很多，本文也只介绍了关于空间方面的优化，因为这个是最最常见的。</p>
<p>最后，大家一定多画图，多思考，题解百边其义自见（百边有点多哈哈哈）</p>
<p>还有，多理解四步骤， 加油！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/devops/k8s/rancher2-k8s-docker-install/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Focus-1">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus-1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/devops/k8s/rancher2-k8s-docker-install/" itemprop="url">centos8 通过 rancher2 部署 k8s</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-01T00:00:00+08:00">
                2020-05-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/devops/" itemprop="url" rel="index">
                    <span itemprop="name">devops</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/devops/rancher/" itemprop="url" rel="index">
                    <span itemprop="name">rancher</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <br>

<blockquote>
<p>环境：</p>
<ul>
<li>192.168.145.150 rancher   2核4G</li>
<li>192.168.145.151 k8s-dn1  4核8G</li>
<li>192.168.145.152 k8s-dn2  4核8G</li>
<li>192.168.145.153 k8s-dn3  4核8G</li>
</ul>
</blockquote>
<blockquote>
<p>域名：</p>
<p>192.168.145.150 rancher.dev</p>
</blockquote>
<h1 id="1、虚拟机安装centos"><a href="#1、虚拟机安装centos" class="headerlink" title="1、虚拟机安装centos"></a>1、虚拟机安装centos</h1><blockquote>
<p><a href="https://www.cnblogs.com/wcwen1990/p/7630545.html" target="_blank" rel="noopener">https://www.cnblogs.com/wcwen1990/p/7630545.html</a></p>
</blockquote>
<h1 id="2、先设置为NAT保证可以访问外网："><a href="#2、先设置为NAT保证可以访问外网：" class="headerlink" title="2、先设置为NAT保证可以访问外网："></a>2、先设置为NAT保证可以访问外网：</h1><blockquote>
<p><a href="http://baijiahao.baidu.com/s?id=1597809303775176940&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">http://baijiahao.baidu.com/s?id=1597809303775176940&amp;wfr=spider&amp;for=pc</a></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-ensXXXX</span><br><span class="line"></span><br><span class="line">ONBOOT=yes</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">IPADDR=192.168.145.150</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.145.2</span><br><span class="line">DNS1=192.168.145.2</span><br></pre></td></tr></table></figure>

<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200723225333027.png" alt="image-20200723225333027"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> centos 7</span></span><br><span class="line">service network restart</span><br><span class="line"><span class="meta">#</span><span class="bash"> centos 8</span></span><br><span class="line">nmcli networking off &amp;&amp; nmcli networking on </span><br><span class="line">ifdown eth0 &amp;&amp; ifup eth0 </span><br><span class="line">nmcli con down eth0 &amp;&amp; nmcli con up eth0</span><br><span class="line">systemctl restart NetworkManager</span><br><span class="line"></span><br><span class="line">reboot</span><br><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure>

<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200723230040796.png" alt="image-20200723230040796"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200723230020587.png" alt="image-20200723230020587"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200723225130402.png" alt="image-20200723225130402"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200723225202276.png" alt="image-20200723225202276"></p>
<h1 id="3、安装ifconfig"><a href="#3、安装ifconfig" class="headerlink" title="3、安装ifconfig"></a>3、安装ifconfig</h1><blockquote>
<p><a href="https://www.cnblogs.com/jtnote/p/6103754.html" target="_blank" rel="noopener">https://www.cnblogs.com/jtnote/p/6103754.html</a></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y net-tools.x86_64</span><br></pre></td></tr></table></figure>

<h1 id="4、安装ssh"><a href="#4、安装ssh" class="headerlink" title="4、安装ssh"></a>4、安装ssh</h1><blockquote>
<p><a href="https://www.cnblogs.com/liuhouhou/p/8975812.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuhouhou/p/8975812.html</a></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yum install -y openssl openssh-serverifcon</span><br><span class="line"></span><br><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line"></span><br><span class="line">systemctl restart sshd.service</span><br><span class="line">systemctl enable sshd.service</span><br></pre></td></tr></table></figure>

<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/0.6985510598248372.png" alt="img"></p>
<h1 id="5、用-xshell-连接-contos7"><a href="#5、用-xshell-连接-contos7" class="headerlink" title="5、用 xshell 连接 contos7"></a>5、用 xshell 连接 contos7</h1><h1 id="6、配置-hosts-系统文件"><a href="#6、配置-hosts-系统文件" class="headerlink" title="6、配置 hosts 系统文件"></a>6、配置 hosts 系统文件</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">192.168.145.150 rancher</span><br><span class="line">192.168.145.151 k8s-dn1</span><br><span class="line">192.168.145.152 k8s-dn2</span><br><span class="line">192.168.145.153 k8s-dn3</span><br><span class="line"></span><br><span class="line">192.168.145.150 rancher.dev</span><br></pre></td></tr></table></figure>

<h1 id="7、修改时区"><a href="#7、修改时区" class="headerlink" title="7、修改时区"></a>7、修改时区</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"></span><br><span class="line">vi /etc/sysconfig/clock</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加如下内容</span></span><br><span class="line">ZONE="Asia/Shanghai"</span><br><span class="line">UTC=false</span><br><span class="line">ARC=false</span><br></pre></td></tr></table></figure>

<h1 id="8、安装-ntp，设置-节点间-ntp-同步"><a href="#8、安装-ntp，设置-节点间-ntp-同步" class="headerlink" title="8、安装 ntp，设置 节点间 ntp 同步"></a>8、安装 ntp，设置 节点间 ntp 同步</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看是否安装：</span></span><br><span class="line">rpm -q ntp</span><br><span class="line"><span class="meta">#</span><span class="bash"> centos 7 安装</span></span><br><span class="line">yum install ntpdate ntp -y</span><br><span class="line"><span class="meta">#</span><span class="bash"> centos 8 安装</span></span><br><span class="line">rpm -ivh http://mirrors.wlnmp.com/centos/wlnmp-release-centos.noarch.rpm</span><br><span class="line">yum install wntp -y</span><br><span class="line">ntpdate ntp1.aliyun.com</span><br></pre></td></tr></table></figure>

<h1 id="9、安装-ssh，配置节点间免密登录"><a href="#9、安装-ssh，配置节点间免密登录" class="headerlink" title="9、安装 ssh，配置节点间免密登录"></a>9、安装 ssh，配置节点间免密登录</h1><p>设置主机名</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl set-hostname rancher</span><br><span class="line">hostnamectl set-hostname k8s-dn1</span><br><span class="line">hostnamectl set-hostname k8s-dn2</span><br><span class="line">hostnamectl set-hostname k8s-dn3</span><br></pre></td></tr></table></figure>

<p>依次在每台服务器上执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br><span class="line">cd ~</span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">ssh-copy-id -i .ssh/id_rsa.pub root@rancher</span><br><span class="line">ssh-copy-id -i .ssh/id_rsa.pub root@k8s-dn1</span><br><span class="line">ssh-copy-id -i .ssh/id_rsa.pub root@k8s-dn2</span><br><span class="line">ssh-copy-id -i .ssh/id_rsa.pub root@k8s-dn3</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh 'root@k8s-dn1'</span><br><span class="line">ssh 'root@k8s-dn2'</span><br><span class="line">ssh 'root@k8s-dn3'</span><br><span class="line">ssh 'root@k8s-rancher'</span><br></pre></td></tr></table></figure>

<h1 id="10、关闭防火墙"><a href="#10、关闭防火墙" class="headerlink" title="10、关闭防火墙"></a>10、关闭防火墙</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure>

<h1 id="11、kernel调优"><a href="#11、kernel调优" class="headerlink" title="11、kernel调优"></a>11、kernel调优</h1><p><code>vi /etc/security/limits.conf</code> 在文件末尾添加以下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root soft nofile 655350</span><br><span class="line">root hard nofile 655350</span><br><span class="line">* soft nofile 655350</span><br><span class="line">* hard nofile 655350</span><br></pre></td></tr></table></figure>

<p><code>vi /etc/sysctl.conf</code> 添加如下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_forward=1</span><br><span class="line">net.bridge.bridge-nf-call-iptables=1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables=1</span><br><span class="line">vm.swappiness=0</span><br><span class="line">vm.max_map_count=655360</span><br></pre></td></tr></table></figure>

<h1 id="12、关闭swap"><a href="#12、关闭swap" class="headerlink" title="12、关闭swap"></a>12、关闭swap</h1><p><code>vi /etc/fstab</code> 注释或删除swap交换分区：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/dev/mapper/cl-root     /                       xfs     defaults        0 0</span><br><span class="line">UUID=5fe3b563-4639-47d5-ab24-8161c324f532 /boot                   ext4    defaults        1 2</span><br><span class="line"><span class="meta">#</span><span class="bash"> /dev/mapper/cl-swap     swap                    swap    defaults        0 0</span></span><br></pre></td></tr></table></figure>

<h1 id="13、关闭-selinux"><a href="#13、关闭-selinux" class="headerlink" title="13、关闭 selinux"></a>13、关闭 selinux</h1><p>将<code>SELINUX</code>值设置为disabled：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/selinux/config</span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure>

<p>14、yum 源更新</p>
<blockquote>
<p>阿里云 yum 源 <a href="https://developer.aliyun.com/mirror/centos?spm=a2c6h.13651102.0.0.3e221b11HiFxxt" target="_blank" rel="noopener">https://developer.aliyun.com/mirror/centos?spm=a2c6h.13651102.0.0.3e221b11HiFxxt</a></p>
<p>各种源：<a href="https://developer.aliyun.com/mirror/" target="_blank" rel="noopener">https://developer.aliyun.com/mirror/</a></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/yum.repos.d/</span><br><span class="line">rm -f CentOS-Base.repo CentOS-AppStream.repo CentOS-PowerTools.repo CentOS-centosplus.repo CentOS-Extras.repo</span><br><span class="line"></span><br><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-8.repo</span><br><span class="line"></span><br><span class="line">yum clean all &amp;&amp; yum makecache</span><br></pre></td></tr></table></figure>

<h1 id="15、docker-安装配置"><a href="#15、docker-安装配置" class="headerlink" title="15、docker 安装配置"></a>15、docker 安装配置</h1><p>每个节点执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line"></span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">yum install -y https://download.docker.com/linux/fedora/30/x86_64/stable/Packages/containerd.io-1.2.6-3.3.fc30.x86_64.rpm</span><br><span class="line">yum install -y docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line">systemctl start docker</span><br><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>

<p>配置docker源</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/docker</span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  "registry-mirrors": ["https://k8spv7nq.mirror.aliyuncs.com"]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<h1 id="16、docker安装rancher2"><a href="#16、docker安装rancher2" class="headerlink" title="16、docker安装rancher2"></a>16、docker安装rancher2</h1><p>在rancher节点执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --restart=unless-stopped -p 80:80 -p 443:443 rancher/rancher</span><br><span class="line"></span><br><span class="line">docker logs -f ec91d23fb68b</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="http://192.168.145.150/" target="_blank" rel="noopener">http://192.168.145.150</a></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200724004052435.png" alt="admin/123456"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200724004156391.png" alt="image-20200724004156391"></p>
</blockquote>
<h3 id="访问-rancher"><a href="#访问-rancher" class="headerlink" title="访问 rancher"></a>访问 rancher</h3><blockquote>
<p>在主机hosts添加 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> C:\Windows\System32\drivers\etc\hosts</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 192.168.145.150  rancher.dev</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><a href="https://rancher.dev" target="_blank" rel="noopener">https://rancher.dev</a></p>
<p>admin/123456</p>
</blockquote>
<h1 id="17、安装k8s"><a href="#17、安装k8s" class="headerlink" title="17、安装k8s"></a>17、安装k8s</h1><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200724004944667.png" alt="image-20200724004944667"></p>
<p>在 worker节点机器中配置hosts地址</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/hosts</span><br><span class="line">192.168.145.150 rancher.dev</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --privileged --restart=unless-stopped --net=host -v /etc/kubernetes:/etc/kubernetes -v /var/run:/var/run rancher/rancher-agent:v2.4.5 --server https://rancher.dev --token vpcq7clf5r5v7vcck8wd759xjdb87bj966hzl5tdfjm7mgmdzc5zwq --ca-checksum 9e76ce060a22f87140fca47d350ccbf99d8d7790f76915db6dba7c50d2b95be6 --etcd --controlplane --worker</span><br><span class="line"></span><br><span class="line">docker run -d --privileged --restart=unless-stopped --net=host -v /etc/kubernetes:/etc/kubernetes -v /var/run:/var/run rancher/rancher-agent:v2.4.5 --server https://rancher.dev --token vpcq7clf5r5v7vcck8wd759xjdb87bj966hzl5tdfjm7mgmdzc5zwq --ca-checksum 9e76ce060a22f87140fca47d350ccbf99d8d7790f76915db6dba7c50d2b95be6 --worker</span><br></pre></td></tr></table></figure>

<p>耗时10分钟左右，集群可用</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200724005836365.png" alt="image-20200724005836365"></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200724010046927.png" alt="image-20200724010046927"></p>
<h1 id="18、安装-kubectl-并配置-kubeconfig"><a href="#18、安装-kubectl-并配置-kubeconfig" class="headerlink" title="18、安装 kubectl 并配置 kubeconfig"></a>18、安装 kubectl 并配置 kubeconfig</h1><p>在4台机器上安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.18.0/bin/linux/amd64/kubectl</span><br><span class="line">chmod +x ./kubectl</span><br><span class="line">mv ./kubectl /usr/local/bin/kubectl</span><br><span class="line">kubectl version --client</span><br></pre></td></tr></table></figure>

<p>配置kubeconfig</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200725202349013.png" alt="image-20200725202349013"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/.kube</span><br><span class="line">vi ~/.kube/config</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将上图中的文件内容，复制到文件中</span></span><br><span class="line"></span><br><span class="line">kubectl get all</span><br></pre></td></tr></table></figure>

<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/image-20200725204124834.png" alt="image-20200725204124834"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Focus-1</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">250</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">63</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">102</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://gitee.com/carloz" title="repository - https://gitee.com/carloz" target="_blank">repository - https://gitee.com/carloz</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Focus-1</span>

  
</div>








  <div class="footer-custom">Hosted by <a target="_blank" href="https://gitee.com/carloz">Gitee Repo</a></div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
