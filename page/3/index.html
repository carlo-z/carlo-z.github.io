<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  
    
      
    

    
  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=consolas:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="keywords" content="Java Kafka Docker JVM NIO Netty">
<meta property="og:type" content="website">
<meta property="og:title" content="Focus-1">
<meta property="og:url" content="https://carlo-z.com/page/3/index.html">
<meta property="og:site_name" content="Focus-1">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Focus-1">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://carlo-z.com/page/3/">





  <title>Focus-1</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Focus-1</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/computer-network/linux-srcode-epoll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Focus-1">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus-1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/computer-network/linux-srcode-epoll/" itemprop="url">理解epoll（基于linux2.6.12.1）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-25T00:00:00+08:00">
                2020-04-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computer-network/" itemprop="url" rel="index">
                    <span itemprop="name">computer-network</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computer-network/tcp/" itemprop="url" rel="index">
                    <span itemprop="name">tcp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <br>

<p>epoll在现在的软件中占据了很大的分量，nginx，libuv等单线程事件循环的软件都使用了epoll。之前分析过select，今天分析一下epoll。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>epoll与select</li>
<li>epoll_create</li>
<li>epoll_ctl</li>
<li>epoll_wait</li>
<li>ET、LT模式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;</span><br></pre></td></tr></table></figure>

<h3 id="epoll与select"><a href="#epoll与select" class="headerlink" title="epoll与select"></a>epoll与select</h3><ul>
<li>Epoll 没有最大并发连接的限制，上限是最大可以打开文件的数目</li>
<li>效率提升，epoll对于句柄事件的选择不是遍历的，是事件响应的，就是句柄上事件来就马上选择出来，不需要遍历整个句柄链表，因此效率非常高，内核将句柄用红黑树保存的，IO效率不随FD数目增加而线性下降。</li>
<li>内存拷贝， select让内核把 FD 消息通知给用户空间的时候使用了内存拷贝的方式，开销较大，但是Epoll 在这点上使用了共享内存的方式，这个内存拷贝也省略了。</li>
</ul>
<p>相比于select，epoll最大的好处在于它不会随着监听fd数目的增长而降低效率。因为在内核中的select实现中，它是采用轮询来处理的，轮询的fd数目越多，自然耗时越多。</p>
<p>并且，在linux/posix_types.h头文件有这样的声明：</p>
<p>#define __FD_SETSIZE 1024</p>
<p>表示select最多同时监听1024个fd，当然，可以通过修改头文件再重编译内核来扩大这个数目，但这似乎并不治本。</p>
<p>epoll_create</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size);</span><br></pre></td></tr></table></figure>

<p>创建一个epoll的句柄，</p>
<ul>
<li>size用来告诉内核这个监听的数目一共有多大。</li>
</ul>
<p>这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p>
<p>epoll_ctl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</span><br></pre></td></tr></table></figure>

<p>epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型</p>
<ul>
<li>EPOLL_CTL_ADD 注册新的fd到epfd中；</li>
<li>EPOLL_CTL_MOD 修改已经注册的fd的监听事件；</li>
<li>EPOLL_CTL_DEL 从epfd中删除一个fd；</li>
</ul>
<p>fd 是要监听的fd</p>
<p>event 是要监听什么样的事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef union epoll_data &#123;</span><br><span class="line"> void *ptr;</span><br><span class="line"> int fd;</span><br><span class="line"> uint32_t u32;</span><br><span class="line"> uint64_t u64;</span><br><span class="line">&#125; epoll_data_t;</span><br><span class="line">struct epoll_event &#123;</span><br><span class="line"> uint32_t events; /* Epoll events */</span><br><span class="line"> epoll_data_t data; /* User data variable */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>events可以是以下几个宏的集合：</p>
<ul>
<li>EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</li>
<li>EPOLLOUT：表示对应的文件描述符可以写；</li>
<li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</li>
<li>EPOLLERR：表示对应的文件描述符发生错误；</li>
<li>EPOLLHUP：表示对应的文件描述符被挂断；</li>
<li>EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</li>
<li>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</li>
</ul>
<p>epoll_wait</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int epoll_wait(int epfd, struct epoll_event *events,</span><br><span class="line"> int maxevents, int timeout);</span><br></pre></td></tr></table></figure>

<p>等待事件的产生，类似于select()调用。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个 maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p>
<h3 id="ET、LT两种工作模式"><a href="#ET、LT两种工作模式" class="headerlink" title="ET、LT两种工作模式"></a>ET、LT两种工作模式</h3><ul>
<li>EPOLLLT：完全靠Linux-kernel-epoll驱动，应用程序只需要处理从epoll_wait返回的fds， 这些fds我们认为它们处于就绪状态。此时epoll可以认为是更快速的poll。</li>
<li>EPOLLET：此模式下，系统仅仅通知应用程序哪些fds变成了就绪状态，一旦fd变成就绪状态，epoll将不再关注这个fd的任何状态信息(从epoll队列移除), 直到应用程序通过读写操作（非阻塞）触发EAGAIN状态，epoll认为这个fd又变为空闲状态，那么epoll又重新关注这个fd的状态变化(重新加入epoll队列)。 随着epoll_wait的返回，队列中的fds是在减少的，所以在大并发的系统中，EPOLLET更有优势，但是对程序员的要求也更高。</li>
</ul>
<p><strong>举例</strong></p>
<p>假设现在对方发送了2k的数据，而我们先读取了1k，然后这时调用了epoll_wait，如果是边沿触发ET，那么这个fd变成就绪状态就会从epoll 队列移除，则epoll_wait 会一直阻塞，忽略尚未读取的1k数据; 而如果是水平触发LT，那么epoll_wait 还会检测到可读事件而返回，我们可以继续读取剩下的1k 数据。</p>
<p><strong>总结:</strong> LT模式可能触发的次数更多, 一旦触发的次数多, 也就意味着效率会下降; 但这样也不能就说LT模式就比ET模式效率更低, 因为ET的使用对编程人员提出了更高更精细的要求,一旦使用者编程水平不够, 那ET模式还不如LT模式。</p>
<p>ET模式仅当状态发生变化的时候才获得通知,这里所谓的状态的变化并不包括缓冲区中还有未处理的数据,也就是说,如果要采用ET模式,需要一直read/write直到出错为止,很多人反映为什么采用ET模式只接收了一部分数据就再也得不到通知了,大多因为这样;而LT模式是只要有数据没有处理就会一直通知下去的.</p>
<h3 id="epoll-IO多路复用模型实现机制"><a href="#epoll-IO多路复用模型实现机制" class="headerlink" title="epoll IO多路复用模型实现机制"></a>epoll IO多路复用模型实现机制</h3><p>设想一下如下场景：有100万个客户端同时与一个服务器进程保持着TCP连接。而每一时刻，通常只有几百上千个TCP连接是活跃的(事实上大部分场景都是这种情况)。如何实现这样的高并发？</p>
<p>在select/poll时代，服务器进程每次都把这100万个连接告诉操作系统(从用户态复制句柄数据结构到内核态)，让操作系统内核去查询这些套接字上是否有事件发生，轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll一般只能处理几千的并发连接。</p>
<p>epoll的设计和实现与select完全不同。epoll通过在Linux内核中申请一个简易的文件系统，把原先的select/poll调用分成了3个部分：</p>
<ul>
<li>调用epoll_create()建立一个epoll对象(在epoll文件系统中为这个句柄对象分配资源)</li>
<li>调用epoll_ctl向epoll对象中添加这100万个连接的套接字</li>
<li>调用epoll_wait收集发生的事件的连接</li>
</ul>
<p>只需要在进程启动时建立一个epoll对象，然后在需要的时候向这个epoll对象中添加或者删除连接。同时，epoll_wait的效率也非常高，因为调用epoll_wait时，并没有一股脑的向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的连接。</p>
<p>Linux内核具体的epoll机制实现思路。</p>
<p>当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * This structure is stored inside the &quot;private_data&quot; member of the file</span><br><span class="line"> * structure and rapresent the main data sructure for the eventpoll</span><br><span class="line"> * interface.</span><br><span class="line"> */</span><br><span class="line">struct eventpoll &#123;</span><br><span class="line"> /* Protect the this structure access */</span><br><span class="line"> spinlock_t lock;</span><br><span class="line"> /*</span><br><span class="line"> * This mutex is used to ensure that files are not removed</span><br><span class="line"> * while epoll is using them. This is held during the event</span><br><span class="line"> * collection loop, the file cleanup path, the epoll file exit</span><br><span class="line"> * code and the ctl operations.</span><br><span class="line"> */</span><br><span class="line"> struct mutex mtx;</span><br><span class="line"> /* Wait queue used by sys_epoll_wait() */</span><br><span class="line"> wait_queue_head_t wq;</span><br><span class="line"> /* Wait queue used by file-&gt;poll() */</span><br><span class="line"> wait_queue_head_t poll_wait;</span><br><span class="line"> /* List of ready file descriptors */</span><br><span class="line">/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/ </span><br><span class="line"> struct list_head rdllist;</span><br><span class="line">/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span><br><span class="line"> /* RB tree root used to store monitored fd structs */</span><br><span class="line"> struct rb_root rbr;</span><br><span class="line"> /*</span><br><span class="line"> * This is a single linked list that chains all the &quot;struct epitem&quot; that</span><br><span class="line"> * happened while transfering ready events to userspace w/out</span><br><span class="line"> * holding -&gt;lock.</span><br><span class="line"> */</span><br><span class="line"> struct epitem *ovflist;</span><br><span class="line"> /* The user that created the eventpoll descriptor */</span><br><span class="line"> struct user_struct *user;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每一个epoll对象都有一个独立的eventpoll结构体，用于存放通过epoll_ctl方法向epoll对象中添加进来的事件。这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来(红黑树的插入时间效率是lgn，其中n为树的高度)。</p>
<p>而所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法。这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中。</p>
<p>在epoll中，对于每一个事件，都会建立一个epitem结构体，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Each file descriptor added to the eventpoll interface will</span><br><span class="line"> * have an entry of this type linked to the &quot;rbr&quot; RB tree.</span><br><span class="line"> */</span><br><span class="line">struct epitem &#123;</span><br><span class="line"> /* RB tree node used to link this structure to the eventpoll RB tree */</span><br><span class="line">//红黑树节点 </span><br><span class="line"> struct rb_node rbn;</span><br><span class="line"> /* List header used to link this structure to the eventpoll ready list */</span><br><span class="line">//双向链表节点 </span><br><span class="line"> struct list_head rdllink;</span><br><span class="line"> /*</span><br><span class="line"> * Works together &quot;struct eventpoll&quot;-&gt;ovflist in keeping the</span><br><span class="line"> * single linked chain of items.</span><br><span class="line"> */</span><br><span class="line"> struct epitem *next;</span><br><span class="line"> /* The file descriptor information this item refers to */</span><br><span class="line">//事件句柄信息</span><br><span class="line"> struct epoll_filefd ffd;</span><br><span class="line"> /* Number of active wait queue attached to poll operations */</span><br><span class="line"> int nwait;</span><br><span class="line"> /* List containing poll wait queues */</span><br><span class="line"> struct list_head pwqlist;</span><br><span class="line"> /* The &quot;container&quot; of this item */</span><br><span class="line">//指向其所属的eventpoll对象 </span><br><span class="line"> struct </span><br><span class="line">![Uploading EPOLL_663944.jpg . . .]</span><br><span class="line">eventpoll *ep;</span><br><span class="line"> /* List header used to link this item to the &quot;struct file&quot; items list */</span><br><span class="line"> struct list_head fllink;</span><br><span class="line"> /* The structure that describe the interested events and the source fd */</span><br><span class="line"> //期待发生的事件类型 </span><br><span class="line"> struct epoll_event event;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。</p>
<p><img src="https://pic1.zhimg.com/80/v2-47c2346f42a179a09c73d96df45eb510_720w.jpg" alt="img"></p>
<p>通过红黑树和双链表数据结构，并结合回调机制，造就了epoll的高效。</p>
<p>下面我们按照epoll三部曲的顺序进行分析。</p>
<h2 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage long sys_epoll_create(int size)</span><br><span class="line">&#123;</span><br><span class="line">    int error, fd;</span><br><span class="line">    struct inode *inode;</span><br><span class="line">    struct file *file;</span><br><span class="line"></span><br><span class="line">    error = ep_getfd(&amp;fd, &amp;inode, &amp;file);</span><br><span class="line">    error = ep_file_init(file);</span><br><span class="line"></span><br><span class="line">    return fd;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现create函数似乎很简单。</p>
<p>1、操作系统中，进程和文件系统是通过fd=&gt;file=&gt;node联系起来的。ep_getfd就是在建立这个联系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static int ep_getfd(int *efd, struct inode **einode, struct file **efile)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    // 获取一个file结构体</span><br><span class="line">    file = get_empty_filp();</span><br><span class="line">    // epoll在底层本身对应一个文件系统，从这个文件系统中获取一个inode</span><br><span class="line">    inode = ep_eventpoll_inode();</span><br><span class="line">    // 获取一个文件描述符</span><br><span class="line">    fd = get_unused_fd();</span><br><span class="line"></span><br><span class="line">    sprintf(name, &quot;[%lu]&quot;, inode-&gt;i_ino);</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.len = strlen(name);</span><br><span class="line">    this.hash = inode-&gt;i_ino;</span><br><span class="line">    // 申请一个entry</span><br><span class="line">    dentry = d_alloc(eventpoll_mnt-&gt;mnt_sb-&gt;s_root, &amp;this);</span><br><span class="line">    dentry-&gt;d_op = &amp;eventpollfs_dentry_operations;</span><br><span class="line">    file-&gt;f_dentry = dentry;</span><br><span class="line"></span><br><span class="line">    // 建立file和inode的联系</span><br><span class="line">    d_add(dentry, inode);</span><br><span class="line">    // 建立fd=&gt;file的关联</span><br><span class="line">    fd_install(fd, file);</span><br><span class="line"></span><br><span class="line">    *efd = fd;</span><br><span class="line">    *einode = inode;</span><br><span class="line">    *efile = file;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>形成一个这种的结构。</p>
<p>2、通过ep_file_init建立file和epoll的关联。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static int ep_file_init(struct file *file)</span><br><span class="line">&#123;</span><br><span class="line">    struct eventpoll *ep;</span><br><span class="line"></span><br><span class="line">    ep = kmalloc(sizeof(struct eventpoll), GFP_KERNEL)</span><br><span class="line">    memset(ep, 0, sizeof(*ep));</span><br><span class="line">    // 一系列初始化</span><br><span class="line">    file-&gt;private_data = ep;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>epoll_create函数主要是建立一个数据结构。并返回一个文件描述符供后面使用。</p>
<h2 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage long</span><br><span class="line">sys_epoll_ctl(int epfd, int op, int fd, struct epoll_event __user *event)</span><br><span class="line">&#123;</span><br><span class="line">    int error;</span><br><span class="line">    struct file *file, *tfile;</span><br><span class="line">    struct eventpoll *ep;</span><br><span class="line">    struct epitem *epi;</span><br><span class="line">    struct epoll_event epds;</span><br><span class="line"></span><br><span class="line">    error = -EFAULT;</span><br><span class="line">    // 不是删除操作则复制用户数据到内核</span><br><span class="line">    if (</span><br><span class="line">        EP_OP_HASH_EVENT(op) &amp;&amp;</span><br><span class="line">        copy_from_user(&amp;epds, event, sizeof(struct epoll_event))</span><br><span class="line">      )</span><br><span class="line">        goto eexit_1;</span><br><span class="line"></span><br><span class="line">    // 根据一种的图，拿到epoll对应的file结构体</span><br><span class="line">    file = fget(epfd);</span><br><span class="line"></span><br><span class="line">    // 拿到操作的文件的file结构体</span><br><span class="line">    tfile = fget(fd);</span><br><span class="line">    // 通过file拿到epoll_event结构体，见上面的图</span><br><span class="line">    ep = file-&gt;private_data;</span><br><span class="line">    // 看这个文件描述符是否已经存在，epoll用红黑树维护这个数据</span><br><span class="line">    epi = ep_find(ep, tfile, fd);</span><br><span class="line"></span><br><span class="line">    switch (op) &#123;</span><br><span class="line">    // 新增</span><br><span class="line">    case EPOLL_CTL_ADD:</span><br><span class="line">        // 还没有则新增，有则报错</span><br><span class="line">        if (!epi) &#123;</span><br><span class="line">            epds.events |= POLLERR | POLLHUP;</span><br><span class="line">            // 插入红黑树</span><br><span class="line">            error = ep_insert(ep, &amp;epds, tfile, fd);</span><br><span class="line">        &#125; else</span><br><span class="line">            error = -EEXIST;</span><br><span class="line">        break;</span><br><span class="line">    // 删除</span><br><span class="line">    case EPOLL_CTL_DEL:</span><br><span class="line">        // 存在则删除，否则报错</span><br><span class="line">        if (epi)</span><br><span class="line">            error = ep_remove(ep, epi);</span><br><span class="line">        else</span><br><span class="line">            error = -ENOENT;</span><br><span class="line">        break;</span><br><span class="line">    // 修改</span><br><span class="line">    case EPOLL_CTL_MOD:</span><br><span class="line">        // 存在则修改，否则报错</span><br><span class="line">        if (epi) &#123;</span><br><span class="line">            epds.events |= POLLERR | POLLHUP;</span><br><span class="line">            error = ep_modify(ep, epi, &amp;epds);</span><br><span class="line">        &#125; else</span><br><span class="line">            error = -ENOENT;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>epoll_ctl函数看起来也没有很复杂，就是根据用户传进来的信息去操作红黑树。对于红黑树的增删改查，查和删除就不分析了。就是去操作红黑树。增和改是类似的逻辑，所以我们只分析增操作就可以了。在此之前，我们先了解一些epoll中其他的数据结构。</p>
<p>当我们新增一个需要监听的文件描述符的时候，系统会申请一个epitem去表示。epitem是保存了文件描述符、事件等信息的结构体。然后把epitem插入到eventpoll结构体维护的红黑树中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static int ep_insert(struct eventpoll *ep, struct epoll_event *event,</span><br><span class="line">             struct file *tfile, int fd)</span><br><span class="line">&#123;</span><br><span class="line">    int error, revents, pwake = 0;</span><br><span class="line">    unsigned long flags;</span><br><span class="line">    struct epitem *epi;</span><br><span class="line">    struct ep_pqueue epq;</span><br><span class="line"></span><br><span class="line">    // 申请一个epitem</span><br><span class="line">    epi = EPI_MEM_ALLOC()</span><br><span class="line">    // 省略一系列初始化工作</span><br><span class="line">    // 记录所属的epoll</span><br><span class="line">    epi-&gt;ep = ep;</span><br><span class="line">    // 在epitem中保存文件描述符fd和file</span><br><span class="line">    EP_SET_FFD(&amp;epi-&gt;ffd, tfile, fd);</span><br><span class="line">    // 监听的事件</span><br><span class="line">    epi-&gt;event = *event;</span><br><span class="line">    epi-&gt;nwait = 0;</span><br><span class="line"></span><br><span class="line">    epq.epi = epi;</span><br><span class="line">    init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);</span><br><span class="line">    revents = tfile-&gt;f_op-&gt;poll(tfile, &amp;epq.pt);</span><br><span class="line"></span><br><span class="line">    // 把epitem插入红黑树</span><br><span class="line">    ep_rbtree_insert(ep, epi);</span><br><span class="line"></span><br><span class="line">    // 如果监听的事件在新增的时候就已经触发，则直接插入到epoll就绪队列</span><br><span class="line">    if ((revents &amp; event-&gt;events) &amp;&amp; !EP_IS_LINKED(&amp;epi-&gt;rdllink)) &#123;</span><br><span class="line">        // 把epitem插入就绪队列rdllist</span><br><span class="line">        list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">        //  有事件触发，唤醒阻塞在epoll_wait的进程队列</span><br><span class="line">        if (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">            wake_up(&amp;ep-&gt;wq);</span><br><span class="line">        if (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">            pwake++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增操作的大致流程是：</p>
<ol>
<li>申请了一个新的epitem表示待观察的实体。他保存了文件描述符、感兴趣的事件等信息。</li>
<li>插入红黑树</li>
<li>判断新增的节点中对应的文件描述符和事件是否已经触发了，是则加入到就绪队列（由eventpoll-&gt;rdllist维护的一个队列）</li>
</ol>
<p>下面具体看一下如何判断感兴趣的事件在对应的文件描述符中是否已经触发。相关代码在ep_insert中。下面单独拎出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    struct ep_pqueue &#123;</span><br><span class="line">        // 函数指针</span><br><span class="line">        poll_table pt;</span><br><span class="line">        // epitem</span><br><span class="line">        struct epitem *epi;</span><br><span class="line">    &#125;;</span><br><span class="line">*/</span><br><span class="line">struct ep_pqueue epq;</span><br><span class="line">epq.epi = epi;</span><br><span class="line">init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);</span><br><span class="line">revents = tfile-&gt;f_op-&gt;poll(tfile, &amp;epq.pt);</span><br><span class="line"></span><br><span class="line">static inline void init_poll_funcptr(poll_table *pt, poll_queue_proc qproc)</span><br><span class="line">&#123;</span><br><span class="line">    pt-&gt;qproc = qproc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是定义了一个struct ep_pqueue 结构体，然后设置他的一个字段为ep_ptable_queue_proc。然后执行tfile-&gt;f_op-&gt;poll。poll函数由各个文件系统或者网络协议实现。我们以管道为例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static unsigned int</span><br><span class="line">pipe_poll(struct file *filp, poll_table *wait)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int mask;</span><br><span class="line">    // 监听的文件描述符对应的inode</span><br><span class="line">    struct inode *inode = filp-&gt;f_dentry-&gt;d_inode;</span><br><span class="line">    struct pipe_inode_info *info = inode-&gt;i_pipe;</span><br><span class="line">    int nrbufs;</span><br><span class="line">    /*</span><br><span class="line">    static inline void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p)</span><br><span class="line">    &#123;</span><br><span class="line">        if (p &amp;&amp; wait_address)</span><br><span class="line">            p-&gt;qproc(filp, wait_address, p);</span><br><span class="line">    &#125;</span><br><span class="line">    */</span><br><span class="line">    poll_wait(filp, PIPE_WAIT(*inode), wait);</span><br><span class="line"></span><br><span class="line">    // 判断哪些事件触发了</span><br><span class="line">    nrbufs = info-&gt;nrbufs;</span><br><span class="line">    mask = 0;</span><br><span class="line">    if (filp-&gt;f_mode &amp; FMODE_READ) &#123;</span><br><span class="line">        mask = (nrbufs &gt; 0) ? POLLIN | POLLRDNORM : 0;</span><br><span class="line">        if (!PIPE_WRITERS(*inode) &amp;&amp; filp-&gt;f_version != PIPE_WCOUNTER(*inode))</span><br><span class="line">            mask |= POLLHUP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (filp-&gt;f_mode &amp; FMODE_WRITE) &#123;</span><br><span class="line">        mask |= (nrbufs &lt; PIPE_BUFFERS) ? POLLOUT | POLLWRNORM : 0;</span><br><span class="line">        if (!PIPE_READERS(*inode))</span><br><span class="line">            mask |= POLLERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到具体的poll函数里会首先执行poll_wait函数。这个函数只是简单执行struct ep_pqueue epq结构体中的函数，即刚才设置的ep_ptable_queue_proc。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//  监听的文件描述符对应的file结构体，whead是等待监听的文件描述符对应的inode可用的队列</span><br><span class="line">static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,</span><br><span class="line">                 poll_table *pt)</span><br><span class="line">&#123;</span><br><span class="line">    struct epitem *epi = EP_ITEM_FROM_EPQUEUE(pt);</span><br><span class="line">    struct eppoll_entry *pwq;</span><br><span class="line"></span><br><span class="line">    if (epi-&gt;nwait &gt;= 0 &amp;&amp; (pwq = PWQ_MEM_ALLOC())) &#123;</span><br><span class="line">        pwq-&gt;wait-&gt;flags = 0;</span><br><span class="line">        pwq-&gt;wait-&gt;task = NULL;</span><br><span class="line">        // 设置回调</span><br><span class="line">        pwq-&gt;wait-&gt;func = ep_poll_callback;</span><br><span class="line">        pwq-&gt;whead = whead;</span><br><span class="line">        pwq-&gt;base = epi;</span><br><span class="line">        // 插入等待监听的文件描述符的inode可用的队列，回调函数是ep_poll_callback</span><br><span class="line">        add_wait_queue(whead, &amp;pwq-&gt;wait);</span><br><span class="line">        list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);</span><br><span class="line">        epi-&gt;nwait++;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /* We have to signal that an error occurred */</span><br><span class="line">        epi-&gt;nwait = -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要的逻辑是把当前进程插入监听的文件的等待队列中，等待唤醒。</p>
<h2 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage long sys_epoll_wait(int epfd, struct epoll_event __user *events,</span><br><span class="line">                   int maxevents, int timeout)</span><br><span class="line">&#123;</span><br><span class="line">    int error;</span><br><span class="line">    struct file *file;</span><br><span class="line">    struct eventpoll *ep;</span><br><span class="line">    // 通过epoll的fd拿到对应的file结构体</span><br><span class="line">    file = fget(epfd);</span><br><span class="line">    // 通过file结构体拿到eventpoll结构体</span><br><span class="line">    ep = file-&gt;private_data;</span><br><span class="line">    error = ep_poll(ep, events, maxevents, timeout);</span><br><span class="line">    return error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,</span><br><span class="line">           int maxevents, long timeout)</span><br><span class="line">&#123;</span><br><span class="line">    int res, eavail;</span><br><span class="line">    unsigned long flags;</span><br><span class="line">    long jtimeout;</span><br><span class="line">    wait_queue_t wait;</span><br><span class="line"></span><br><span class="line">    // 计算超时时间</span><br><span class="line">    jtimeout = timeout == -1 || timeout &gt; (MAX_SCHEDULE_TIMEOUT - 1000) / HZ ?</span><br><span class="line">        MAX_SCHEDULE_TIMEOUT: (timeout * HZ + 999) / 1000;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line"></span><br><span class="line">    res = 0;</span><br><span class="line">    // 就绪队列为空</span><br><span class="line">    if (list_empty(&amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">        // 加入阻塞队列</span><br><span class="line">        init_waitqueue_entry(&amp;wait, current);</span><br><span class="line">        add_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line"></span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            // 挂起</span><br><span class="line">            set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">            // 超时或者有就绪事件了，则跳出返回</span><br><span class="line">            if (!list_empty(&amp;ep-&gt;rdllist) || !jtimeout)</span><br><span class="line">                break;</span><br><span class="line">            // 被信号唤醒返回EINTR</span><br><span class="line">            if (signal_pending(current)) &#123;</span><br><span class="line">                res = -EINTR;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 设置定时器，然后进程挂起，等待超时唤醒（超时或者信号唤醒）</span><br><span class="line">            jtimeout = schedule_timeout(jtimeout);</span><br><span class="line">        &#125;</span><br><span class="line">        // 移出阻塞队列</span><br><span class="line">        remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line">        // 设置就绪</span><br><span class="line">        set_current_state(TASK_RUNNING);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 是否有事件就绪，唤醒的原因有几个，被唤醒不代表就有就绪事件</span><br><span class="line">    eavail = !list_empty(&amp;ep-&gt;rdllist);</span><br><span class="line"></span><br><span class="line">    write_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line">    // 处理就绪事件返回</span><br><span class="line">    if (!res &amp;&amp; eavail &amp;&amp;</span><br><span class="line">        !(res = ep_events_transfer(ep, events, maxevents)) &amp;&amp; jtimeout)</span><br><span class="line">        goto retry;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说epoll_wait的逻辑主要是处理就绪队列的节点。</p>
<ol>
<li>如果就绪队列为空，则根据timeout做下一步处理，可能定时阻塞。</li>
<li>如果就绪队列非空则处理就绪队列，返回给用户。处理就绪队列的函数是ep_events_transfer。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static int ep_events_transfer(struct eventpoll *ep,</span><br><span class="line">                  struct epoll_event __user *events, int maxevents)</span><br><span class="line">&#123;</span><br><span class="line">    int eventcnt = 0;</span><br><span class="line">    struct list_head txlist;</span><br><span class="line"></span><br><span class="line">    INIT_LIST_HEAD(&amp;txlist);</span><br><span class="line"></span><br><span class="line">    if (ep_collect_ready_items(ep, &amp;txlist, maxevents) &gt; 0) &#123;</span><br><span class="line">        eventcnt = ep_send_events(ep, &amp;txlist, events);</span><br><span class="line">        ep_reinject_items(ep, &amp;txlist);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return eventcnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是三个函数，我们一个个看。</p>
<p>1、ep_collect_ready_items收集就绪事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static int ep_collect_ready_items(struct eventpoll *ep, struct list_head *txlist, int maxevents)</span><br><span class="line">&#123;</span><br><span class="line">    int nepi;</span><br><span class="line">    unsigned long flags;</span><br><span class="line">    // 就绪事件的队列</span><br><span class="line">    struct list_head *lsthead = &amp;ep-&gt;rdllist, *lnk;</span><br><span class="line">    struct epitem *epi;</span><br><span class="line"></span><br><span class="line">    for (nepi = 0, lnk = lsthead-&gt;next; lnk != lsthead &amp;&amp; nepi &lt; maxevents;) &#123;</span><br><span class="line">        // 通过结构体字段的地址拿到结构体首地址</span><br><span class="line">        epi = list_entry(lnk, struct epitem, rdllink);</span><br><span class="line"></span><br><span class="line">        lnk = lnk-&gt;next;</span><br><span class="line"></span><br><span class="line">        /* If this file is already in the ready list we exit soon */</span><br><span class="line">        if (!EP_IS_LINKED(&amp;epi-&gt;txlink)) &#123;</span><br><span class="line"></span><br><span class="line">            epi-&gt;revents = epi-&gt;event.events;</span><br><span class="line">            // 插入txlist队列，然后处理完再返回给用户</span><br><span class="line">            list_add(&amp;epi-&gt;txlink, txlist);</span><br><span class="line">            nepi++;</span><br><span class="line">            // 从就绪队列中删除</span><br><span class="line">            EP_LIST_DEL(&amp;epi-&gt;rdllink);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nepi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、ep_send_events判断哪些事件触发了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static int ep_send_events(struct eventpoll *ep, struct list_head *txlist,</span><br><span class="line">              struct epoll_event __user *events)</span><br><span class="line">&#123;</span><br><span class="line">    int eventcnt = 0;</span><br><span class="line">    unsigned int revents;</span><br><span class="line">    struct list_head *lnk;</span><br><span class="line">    struct epitem *epi;</span><br><span class="line">    // 遍历就绪队列，记录触发的事件</span><br><span class="line">    list_for_each(lnk, txlist) &#123;</span><br><span class="line">        epi = list_entry(lnk, struct epitem, txlink);</span><br><span class="line">        // 判断哪些事件触发了</span><br><span class="line">        revents = epi-&gt;ffd.file-&gt;f_op-&gt;poll(epi-&gt;ffd.file, NULL);</span><br><span class="line"></span><br><span class="line">        epi-&gt;revents = revents &amp; epi-&gt;event.events;</span><br><span class="line">        // 复制到用户空间</span><br><span class="line">        if (epi-&gt;revents) &#123;</span><br><span class="line">            if (__put_user(epi-&gt;revents,</span><br><span class="line">                       &amp;events[eventcnt].events) ||</span><br><span class="line">                __put_user(epi-&gt;event.data,</span><br><span class="line">                       &amp;events[eventcnt].data))</span><br><span class="line">                return -EFAULT;</span><br><span class="line">            // 只监听一次，触发完设置成对任何事件都不感兴趣</span><br><span class="line">            if (epi-&gt;event.events &amp; EPOLLONESHOT)</span><br><span class="line">                epi-&gt;event.events &amp;= EP_PRIVATE_BITS;</span><br><span class="line">            eventcnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return eventcnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、ep_reinject_items重新插入就绪队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static void ep_reinject_items(struct eventpoll *ep, struct list_head *txlist)</span><br><span class="line">&#123;</span><br><span class="line">    int ricnt = 0, pwake = 0;</span><br><span class="line">    unsigned long flags;</span><br><span class="line">    struct epitem *epi;</span><br><span class="line"></span><br><span class="line">    while (!list_empty(txlist)) &#123;</span><br><span class="line">        epi = list_entry(txlist-&gt;next, struct epitem, txlink);</span><br><span class="line">        EP_LIST_DEL(&amp;epi-&gt;txlink);</span><br><span class="line">        //  水平触发模式则一直通知，即重新加入就绪队列</span><br><span class="line">        if (EP_RB_LINKED(&amp;epi-&gt;rbn) &amp;&amp; !(epi-&gt;event.events &amp; EPOLLET) &amp;&amp;</span><br><span class="line">            (epi-&gt;revents &amp; epi-&gt;event.events) &amp;&amp; !EP_IS_LINKED(&amp;epi-&gt;rdllink)) &#123;</span><br><span class="line">            list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">            ricnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，并有没有在epoll_wait的时候去收集就绪事件，那么就绪队列是谁处理的呢？我们回顾一下插入红黑树的时候，做了一个事情，就是在文件对应的inode上注册一个回调。当文件满足条件的时候，就会唤醒因为epoll_wait而阻塞的进程。epoll_wait会收集事件返回给用户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static int ep_poll_callback(wait_queue_t *wait, unsigned mode, int sync, void *key)</span><br><span class="line">&#123;</span><br><span class="line">    int pwake = 0;</span><br><span class="line">    unsigned long flags;</span><br><span class="line">    struct epitem *epi = EP_ITEM_FROM_WAIT(wait);</span><br><span class="line">    struct eventpoll *ep = epi-&gt;ep;</span><br><span class="line">    // 插入就绪队列</span><br><span class="line">    list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">    // 唤醒因epoll_wait而阻塞的进程</span><br><span class="line">    if (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">        wake_up(&amp;ep-&gt;wq);</span><br><span class="line">    if (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">        pwake++;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>epoll的实现涉及的内容比较多，先分析一下大致的原理。有机会再深入分析。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/computer-network/linux-srcode-tcp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Focus-1">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus-1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/computer-network/linux-srcode-tcp/" itemprop="url">linux下深入理解TCP/IP协议的实现（基于linux1.2.13）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-25T00:00:00+08:00">
                2020-04-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computer-network/" itemprop="url" rel="index">
                    <span itemprop="name">computer-network</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computer-network/tcp/" itemprop="url" rel="index">
                    <span itemprop="name">tcp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <br>

<h1 id="bind实现"><a href="#bind实现" class="headerlink" title="bind实现"></a>bind实现</h1><p>按照socket网络编程的顺序，我们这一篇来分析bind函数。我们通过socket函数拿到了一个socket结构体。bind函数的逻辑其实比较简单，他就是给socket结构体绑定一个地址，简单来说，就是给他的某些字段赋值。talk is cheap。show me the code。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static int sock_bind(int fd, struct sockaddr *umyaddr, int addrlen)</span><br><span class="line">&#123;</span><br><span class="line">    struct socket *sock;</span><br><span class="line">    int i;</span><br><span class="line">    char address[MAX_SOCK_ADDR];</span><br><span class="line">    int err;</span><br><span class="line"></span><br><span class="line">    // 通过文件描述符找到对应的socket   </span><br><span class="line">    if (!(sock = sockfd_lookup(fd, NULL))) </span><br><span class="line">        return(-ENOTSOCK);</span><br><span class="line"></span><br><span class="line">    if((err=move_addr_to_kernel(umyaddr,addrlen,address))&lt;0)</span><br><span class="line">        return err;</span><br><span class="line"></span><br><span class="line">    if ((i = sock-&gt;ops-&gt;bind(sock, (struct sockaddr *)address, addrlen)) &lt; 0) </span><br><span class="line">    &#123;</span><br><span class="line">        return(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是两个函数，我们一个个来。</p>
<h3 id="1、sockfd-lookup"><a href="#1、sockfd-lookup" class="headerlink" title="1、sockfd_lookup"></a>1、sockfd_lookup</h3><p>通过之前一些文章的分析，我们应该数socket和文件的内存布局比较熟悉了。下面的代码不难理解。就是根据文件描述符从pcb中找到inode节点。因为inode节点里保存了socket结构体，所以最后返回fd对应的socke结构体就行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 通过fd找到file结构体，从而找到inode节点，最后找到socket结构体</span><br><span class="line">static inline struct socket *sockfd_lookup(int fd, struct file **pfile)</span><br><span class="line">&#123;</span><br><span class="line">    struct file *file;</span><br><span class="line">    struct inode *inode;</span><br><span class="line"></span><br><span class="line">    if (fd &lt; 0 || fd &gt;= NR_OPEN || !(file = current-&gt;files-&gt;fd[fd])) </span><br><span class="line">        return NULL;</span><br><span class="line"></span><br><span class="line">    inode = file-&gt;f_inode;</span><br><span class="line">    if (!inode || !inode-&gt;i_sock)</span><br><span class="line">        return NULL;</span><br><span class="line"></span><br><span class="line">    if (pfile) </span><br><span class="line">        *pfile = file;</span><br><span class="line"></span><br><span class="line">    return socki_lookup(inode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// inode和socket互相引用</span><br><span class="line">inline struct socket *socki_lookup(struct inode *inode)</span><br><span class="line">&#123;</span><br><span class="line">    return &amp;inode-&gt;u.socket_i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、sock-gt-ops-gt-bind"><a href="#2、sock-gt-ops-gt-bind" class="headerlink" title="2、sock-&gt;ops-&gt;bind"></a>2、sock-&gt;ops-&gt;bind</h3><p>我们回顾socket那篇文章可以知道socket结构体里保存了一些列的操作函数，假设是协议簇是ipv4，那么bind函数就是inet_bind函数（省略了部分代码）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">// 给socket绑定一个地址</span><br><span class="line">static int inet_bind(struct socket *sock, struct sockaddr *uaddr,</span><br><span class="line">           int addr_len)</span><br><span class="line">&#123;</span><br><span class="line">    struct sockaddr_in *addr=(struct sockaddr_in *)uaddr;</span><br><span class="line">    // 拿到底层的sock结构体</span><br><span class="line">    struct sock *sk=(struct sock *)sock-&gt;data, *sk2;</span><br><span class="line">    unsigned short snum = 0 /* Stoopid compiler.. this IS ok */;</span><br><span class="line">    int chk_addr_ret;</span><br><span class="line"></span><br><span class="line">    // raw协议的这些数据由用户填充  </span><br><span class="line">    if(sock-&gt;type != SOCK_RAW)</span><br><span class="line">    &#123;   // 已经绑定了端口</span><br><span class="line">        if (sk-&gt;num != 0) </span><br><span class="line">            return(-EINVAL);</span><br><span class="line"></span><br><span class="line">        snum = ntohs(addr-&gt;sin_port);</span><br><span class="line"></span><br><span class="line">        // 端口无效则随机获取一个非root才能使用的端口</span><br><span class="line">        if (snum == 0) </span><br><span class="line">        &#123;</span><br><span class="line">            snum = get_new_socknum(sk-&gt;prot, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        // 小于1024的端口需要超级用户权限</span><br><span class="line">        if (snum &lt; PROT_SOCK &amp;&amp; !suser()) </span><br><span class="line">            return(-EACCES);</span><br><span class="line">    &#125;</span><br><span class="line">    // 判断ip</span><br><span class="line">    chk_addr_ret = ip_chk_addr(addr-&gt;sin_addr.s_addr);</span><br><span class="line">    // 非法地址</span><br><span class="line">    if (addr-&gt;sin_addr.s_addr != 0 &amp;&amp; chk_addr_ret != IS_MYADDR &amp;&amp; chk_addr_ret != IS_MULTICAST)</span><br><span class="line">        return(-EADDRNOTAVAIL); /* Source address MUST be ours! */</span><br><span class="line">     // 记录ip    </span><br><span class="line">    if (chk_addr_ret || addr-&gt;sin_addr.s_addr == 0)</span><br><span class="line">        sk-&gt;saddr = addr-&gt;sin_addr.s_addr;</span><br><span class="line">    if(sock-&gt;type != SOCK_RAW)</span><br><span class="line">    &#123;</span><br><span class="line">        /* Make sure we are allowed to bind here. */</span><br><span class="line">        cli();</span><br><span class="line">        // 遍历哈希表，哈希表冲突解决法是链地址法，校验绑定的端口的合法性</span><br><span class="line">        for(sk2 = sk-&gt;prot-&gt;sock_array[snum &amp; (SOCK_ARRAY_SIZE -1)];</span><br><span class="line">                    sk2 != NULL; sk2 = sk2-&gt;next) </span><br><span class="line">        &#123;</span><br><span class="line">            // 端口还没有绑定过，直接校验下一个</span><br><span class="line">            if (sk2-&gt;num != snum) </span><br><span class="line">                continue;</span><br><span class="line">            // 端口已经被使用，没有设置可重用标记，比如断开连接后在2msl内是否可以重用，通过setsockopt函数设置</span><br><span class="line">            if (!sk-&gt;reuse)</span><br><span class="line">            &#123;</span><br><span class="line">                sti();</span><br><span class="line">                return(-EADDRINUSE);</span><br><span class="line">            &#125;</span><br><span class="line">            // 端口一样，但是ip不一样，ok，下一个</span><br><span class="line">            if (sk2-&gt;saddr != sk-&gt;saddr) </span><br><span class="line">                continue;   /* socket per slot ! -FB */</span><br><span class="line">            // 端口和ip都一样。被监听的端口不能同时被使用</span><br><span class="line">            if (!sk2-&gt;reuse || sk2-&gt;state==TCP_LISTEN) </span><br><span class="line">            &#123;</span><br><span class="line">                sti();</span><br><span class="line">                return(-EADDRINUSE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sti();</span><br><span class="line">        // 保证该sk不在sock_array队列里</span><br><span class="line">        remove_sock(sk);</span><br><span class="line">        // 挂载到sock_array里</span><br><span class="line">        put_sock(snum, sk);</span><br><span class="line">        // tcp头中的源端口</span><br><span class="line">        sk-&gt;dummy_th.source = ntohs(sk-&gt;num);</span><br><span class="line">        sk-&gt;daddr = 0;</span><br><span class="line">        sk-&gt;dummy_th.dest = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bind函数主要是对待绑定的ip和端口做一个校验，合法的时就记录在sock结构体中。并且把sock结构体挂载到一个全局的哈希表里。</p>
<br>

<h1 id="listen-实现"><a href="#listen-实现" class="headerlink" title="listen 实现"></a>listen 实现</h1><p>listen函数的逻辑比bind还简单。bind主要是校验和绑定ip、端口。listen则是修改socket的状态，并记录一些设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">static int sock_listen(int fd, int backlog)</span><br><span class="line">&#123;</span><br><span class="line">    struct socket *sock;</span><br><span class="line"></span><br><span class="line">    if (fd &lt; 0 || fd &gt;= NR_OPEN || current-&gt;files-&gt;fd[fd] == NULL)</span><br><span class="line">        return(-EBADF);</span><br><span class="line">    if (!(sock = sockfd_lookup(fd, NULL))) </span><br><span class="line">        return(-ENOTSOCK);</span><br><span class="line"></span><br><span class="line">    if (sock-&gt;state != SS_UNCONNECTED) </span><br><span class="line">    &#123;</span><br><span class="line">        return(-EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (sock-&gt;ops &amp;&amp; sock-&gt;ops-&gt;listen)</span><br><span class="line">        sock-&gt;ops-&gt;listen(sock, backlog);</span><br><span class="line">    // 设置socket的监听属性，accept函数时用到    </span><br><span class="line">    sock-&gt;flags |= SO_ACCEPTCON;</span><br><span class="line">    return(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int inet_listen(struct socket *sock, int backlog)</span><br><span class="line">&#123;</span><br><span class="line">    struct sock *sk = (struct sock *) sock-&gt;data;</span><br><span class="line">    // 如果没有绑定端口则绑定一个，并把sock加到sock_array中</span><br><span class="line">    if(inet_autobind(sk)!=0)</span><br><span class="line">        return -EAGAIN;</span><br><span class="line"></span><br><span class="line">    if ((unsigned) backlog &gt; 128)</span><br><span class="line">        backlog = 128;</span><br><span class="line">    // tcp接收队列的长度上限，不同系统实现不一样，具体参考tcp.c的使用</span><br><span class="line">    sk-&gt;max_ack_backlog = backlog;</span><br><span class="line">    // 修改socket状态，防止多次调用listen</span><br><span class="line">    if (sk-&gt;state != TCP_LISTEN)</span><br><span class="line">    &#123;   </span><br><span class="line">        sk-&gt;ack_backlog = 0;</span><br><span class="line">        sk-&gt;state = TCP_LISTEN;</span><br><span class="line">    &#125;</span><br><span class="line">    return(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 绑定一个随机的端口，更新sk的源端口字段，并把sk挂载到端口对应的队列中，见bind函数的分析</span><br><span class="line">static int inet_autobind(struct sock *sk)</span><br><span class="line">&#123;</span><br><span class="line">    /* We may need to bind the socket. */</span><br><span class="line">    if (sk-&gt;num == 0) </span><br><span class="line">    &#123;</span><br><span class="line">        sk-&gt;num = get_new_socknum(sk-&gt;prot, 0);</span><br><span class="line">        if (sk-&gt;num == 0) </span><br><span class="line">            return(-EAGAIN);</span><br><span class="line">        put_sock(sk-&gt;num, sk);</span><br><span class="line">        sk-&gt;dummy_th.source = ntohs(sk-&gt;num);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="accept-实现"><a href="#accept-实现" class="headerlink" title="accept 实现"></a>accept 实现</h1><p>我们继续分析tcp/ip协议的实现，这一篇讲一下accept，accept就是从已完成三次握手的连接队列里，摘下一个节点。我们可以了解到三次握手的实现和过程。很多同学都了解三次握手是什么，但是可能很少同学会深入思考或者看他的实现，众所周知，一个服务器启动的时候，会监听一个端口。其实就是新建了一个socket。那么如果有一个连接到来的时候，我们通过accept就能拿到这个新连接对应的socket。那么这个socket和监听的socket是不是同一个呢？其实socket分为监听型和通信型的。表面上，服务器用一个端口实现了多个连接，但是这个端口是用于监听的，底层用于和客户端通信的其实是另一个socket。所以每一个连接过来，负责监听的socket发现是一个建立连接的包（syn包），他就会生成一个新的socket与之通信（accept的时候返回的那个）。我们将会从代码中看到这个实现。<br>我们从accept函数开始，详细分析这个过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">static int sock_accept(int fd, struct sockaddr *upeer_sockaddr, int *upeer_addrlen)</span><br><span class="line">&#123;</span><br><span class="line">    struct file *file;</span><br><span class="line">    struct socket *sock, *newsock;</span><br><span class="line">    int i;</span><br><span class="line">    char address[MAX_SOCK_ADDR];</span><br><span class="line">    int len;</span><br><span class="line"></span><br><span class="line">    if (fd &lt; 0 || fd &gt;= NR_OPEN || ((file = current-&gt;files-&gt;fd[fd]) == NULL))</span><br><span class="line">        return(-EBADF);</span><br><span class="line">    // 根据文件描述符找到对应的file结构体和socket结构</span><br><span class="line">      if (!(sock = sockfd_lookup(fd, &amp;file))) </span><br><span class="line">        return(-ENOTSOCK);</span><br><span class="line">    if (sock-&gt;state != SS_UNCONNECTED) </span><br><span class="line">    &#123;</span><br><span class="line">        return(-EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line">    // socket没有调用过listen，报错，该标记位在listen中设置</span><br><span class="line">    if (!(sock-&gt;flags &amp; SO_ACCEPTCON)) </span><br><span class="line">    &#123;</span><br><span class="line">        return(-EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line">    // 分配一个新的socket结构体</span><br><span class="line">    if (!(newsock = sock_alloc())) </span><br><span class="line">    &#123;</span><br><span class="line">        printk(&quot;NET: sock_accept: no more sockets\n&quot;);</span><br><span class="line">        return(-ENOSR); /* Was: EAGAIN, but we are out of system</span><br><span class="line">                   resources! */</span><br><span class="line">    &#125;</span><br><span class="line">    newsock-&gt;type = sock-&gt;type;</span><br><span class="line">    newsock-&gt;ops = sock-&gt;ops;</span><br><span class="line">    // 创建一个底层的sock结构体和新的socket结构体互相关联</span><br><span class="line">    if ((i = sock-&gt;ops-&gt;dup(newsock, sock)) &lt; 0) </span><br><span class="line">    &#123;</span><br><span class="line">        sock_release(newsock);</span><br><span class="line">        return(i);</span><br><span class="line">    &#125;</span><br><span class="line">    // accept返回一个新的sock和socket关联</span><br><span class="line">    i = newsock-&gt;ops-&gt;accept(sock, newsock, file-&gt;f_flags);</span><br><span class="line">    if ( i &lt; 0) </span><br><span class="line">    &#123;</span><br><span class="line">        sock_release(newsock);</span><br><span class="line">        return(i);</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回一个新的文件描述符</span><br><span class="line">    if ((fd = get_fd(SOCK_INODE(newsock))) &lt; 0) </span><br><span class="line">    &#123;</span><br><span class="line">        sock_release(newsock);</span><br><span class="line">        return(-EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line">    // 是否需要获取socket对应的地址</span><br><span class="line">    if (upeer_sockaddr)</span><br><span class="line">    &#123;</span><br><span class="line">        newsock-&gt;ops-&gt;getname(newsock, (struct sockaddr *)address, &amp;len, 1);</span><br><span class="line">        move_addr_to_user(address,len, upeer_sockaddr, upeer_addrlen);</span><br><span class="line">    &#125;</span><br><span class="line">    return(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们一步步来分析这个函数。<br>1 通过fd找到对应的socket结构体，然后申请一个新的socket结构体和sock结构体，并且把他们两互相关联。这个在前面的文章分析过。<br>2 然后把监听的socket和准备用于通信的结构体作为参数，调用accept函数。<br>3 最后返回通信socket对应的文件描述符。</p>
<p>下面我们开始分析accept函数的真正实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static int inet_accept(struct socket *sock, struct socket *newsock, int flags)</span><br><span class="line">&#123;</span><br><span class="line">    struct sock *sk1, *sk2;</span><br><span class="line">    int err;</span><br><span class="line">    sk1 = (struct sock *) sock-&gt;data;</span><br><span class="line">    // 返回一个新的sock结构体</span><br><span class="line">    sk2 = sk1-&gt;prot-&gt;accept(sk1,flags);</span><br><span class="line">    // 互相关联</span><br><span class="line">    newsock-&gt;data = (void *)sk2;</span><br><span class="line">    sk2-&gt;socket = newsock;</span><br><span class="line">    newsock-&gt;conn = NULL;</span><br><span class="line">    // 设置sock为已经建立连接状态</span><br><span class="line">    newsock-&gt;state = SS_CONNECTED;</span><br><span class="line">    return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数主要是调底层的accept函数，底层accept函数会返回一个新的sock结构体，socket和sock结构体的区别和背景在之前的文章里已经分析过。总的来说，accept函数就是申请一个新的通信socket，这个socket关联了一个新的sock结构体。下面我们看看tcp层的accept函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static struct sock *tcp_accept(struct sock *sk, int flags)</span><br><span class="line">&#123;</span><br><span class="line">    struct sock *newsk;</span><br><span class="line">    struct sk_buff *skb;</span><br><span class="line"></span><br><span class="line">    // 是一个listen的套接字</span><br><span class="line">    if (sk-&gt;state != TCP_LISTEN) </span><br><span class="line">    &#123;</span><br><span class="line">        sk-&gt;err = EINVAL;</span><br><span class="line">        return(NULL); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cli();</span><br><span class="line">    // 从sock的receive_queue队列摘取已建立连接的节点，</span><br><span class="line">    while((skb = tcp_dequeue_established(sk)) == NULL) </span><br><span class="line">    &#123;   </span><br><span class="line">        // 没有已经建立连接的节点，但是设置了非阻塞模式，直接返回</span><br><span class="line">        if (flags &amp; O_NONBLOCK) </span><br><span class="line">        &#123;</span><br><span class="line">            sti();</span><br><span class="line">            release_sock(sk);</span><br><span class="line">            sk-&gt;err = EAGAIN;</span><br><span class="line">            return(NULL);</span><br><span class="line">        &#125;</span><br><span class="line">        release_sock(sk);</span><br><span class="line">        //阻塞进程，如果后续建立了连接，则进程被唤醒的时候，就会跳出while循环</span><br><span class="line">        interruptible_sleep_on(sk-&gt;sleep);</span><br><span class="line">      &#125;</span><br><span class="line">    sti();</span><br><span class="line"></span><br><span class="line">    // 拿到一个新的sock结构，由建立连接的时候创建的</span><br><span class="line">    newsk = skb-&gt;sk;</span><br><span class="line"></span><br><span class="line">    // 返回新的sock结构体</span><br><span class="line">    return(newsk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数主要的逻辑是从监听型socket的已完成三次握手的队列里摘下一个节点。这个节点是一个sk_buff结构体，sk_buff是一个表示网络数据包的数据结构。</p>
<p><img src="https://pic2.zhimg.com/80/v2-f3220906a0bf893d6a6c4b62d56c00d1_720w.jpg" alt="img"></p>
<p>accept函数就分析完了。下一篇我们分析三次握手。看看accept函数摘下的这个节点是如果生成的。</p>
<br>

<h1 id="connect-实现"><a href="#connect-实现" class="headerlink" title="connect 实现"></a>connect 实现</h1><p>分析完了服务器端，我们继续分析客户端，在socket编程中，客户端的流程是比较简单的，申请一个socket，然后调connect去发起连接就行。我们先看一下connect函数的定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    socket 通过socket函数申请的结构体</span><br><span class="line">    address 需要连接的目的地地址信息</span><br><span class="line">*/</span><br><span class="line">int connect(int socket, const struct sockaddr *address,socklen_t address_len);</span><br></pre></td></tr></table></figure>

<p>我们通过层层调用揭开connect的迷雾。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static int sock_connect(int fd, struct sockaddr *uservaddr, int addrlen)</span><br><span class="line">&#123;</span><br><span class="line">    struct socket *sock;</span><br><span class="line">    struct file *file;</span><br><span class="line">    int i;</span><br><span class="line">    char address[MAX_SOCK_ADDR];</span><br><span class="line">    int err;</span><br><span class="line"></span><br><span class="line">    if (fd &lt; 0 || fd &gt;= NR_OPEN || (file=current-&gt;files-&gt;fd[fd]) == NULL)</span><br><span class="line">        return(-EBADF);</span><br><span class="line">    if (!(sock = sockfd_lookup(fd, &amp;file)))</span><br><span class="line">        return(-ENOTSOCK);</span><br><span class="line"></span><br><span class="line">    i = sock-&gt;ops-&gt;connect(sock, (struct sockaddr *)address, addrlen, file-&gt;f_flags);</span><br><span class="line">    if (i &lt; 0) </span><br><span class="line">    &#123;</span><br><span class="line">        return(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有太多逻辑，通过fd找到关联的socket结构体。然后调底层函数。底层的函数是inet_connect，这个函数逻辑比较多，我们分开分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (sock-&gt;state == SS_CONNECTING &amp;&amp; sk-&gt;protocol == IPPROTO_TCP &amp;&amp; (flags &amp; O_NONBLOCK)) &#123;</span><br><span class="line">    if (sk-&gt;err != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        err=sk-&gt;err;</span><br><span class="line">        sk-&gt;err=0;</span><br><span class="line">        return -err;</span><br><span class="line">    &#125;</span><br><span class="line">    return -EALREADY;   /* Connecting is currently in progress */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正在连接，并且是非阻塞的，直接返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (sock-&gt;state != SS_CONNECTING) </span><br><span class="line">    &#123;</span><br><span class="line">        // 如果绑过就不需要绑了</span><br><span class="line">        if(inet_autobind(sk)!=0)</span><br><span class="line">            return(-EAGAIN);</span><br><span class="line">        // 调用底层的连接函数，发一个syn包</span><br><span class="line">        err = sk-&gt;prot-&gt;connect(sk, (struct sockaddr_in *)uaddr, addr_len);</span><br><span class="line">        if (err &lt; 0) </span><br><span class="line">            return(err);</span><br><span class="line">        // 发送成功设置状态为连接中</span><br><span class="line">          sock-&gt;state = SS_CONNECTING;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>继续调用底层的函数，这里是tcp，所以是发送一个sync包（一会分析）。然后把socket状态修改为连接中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (sk-&gt;state != TCP_ESTABLISHED &amp;&amp;(flags &amp; O_NONBLOCK)) </span><br><span class="line">    return(-EINPROGRESS);</span><br></pre></td></tr></table></figure>

<p>还没建立连接成功并且是非阻塞的方式，直接返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 连接建立中，阻塞当前进程</span><br><span class="line">while(sk-&gt;state == TCP_SYN_SENT || sk-&gt;state == TCP_SYN_RECV) </span><br><span class="line">&#123;   </span><br><span class="line">    // 可中断式睡眠，即可被信号唤醒</span><br><span class="line">    interruptible_sleep_on(sk-&gt;sleep);</span><br><span class="line">    // 被唤醒后，判断是因为被信号唤醒的还是因为建立建立了。</span><br><span class="line">    if (current-&gt;signal &amp; ~current-&gt;blocked) </span><br><span class="line">    &#123;</span><br><span class="line">        sti();</span><br><span class="line">        return(-ERESTARTSYS);</span><br><span class="line">    &#125;</span><br><span class="line">    // 连接失败</span><br><span class="line">    if(sk-&gt;err &amp;&amp; sk-&gt;protocol == IPPROTO_TCP)</span><br><span class="line">    &#123;</span><br><span class="line">        sti();</span><br><span class="line">        sock-&gt;state = SS_UNCONNECTED;</span><br><span class="line">        err = -sk-&gt;err;</span><br><span class="line">        sk-&gt;err=0;</span><br><span class="line">        return err; /* set by tcp_err() */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>connect的时候如果没有设置阻塞标记，则进程会被挂起。tcp层建立连接后会唤醒进程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 连接建立</span><br><span class="line">    sock-&gt;state = SS_CONNECTED;</span><br><span class="line"></span><br><span class="line">    if (sk-&gt;state != TCP_ESTABLISHED &amp;&amp; sk-&gt;err) </span><br><span class="line">    &#123;</span><br><span class="line">        sock-&gt;state = SS_UNCONNECTED;</span><br><span class="line">        err=sk-&gt;err;</span><br><span class="line">        sk-&gt;err=0;</span><br><span class="line">        return(-err);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最后被连接建立唤醒后，设置socket的状态。connect就完成了。</p>
<p>下面我们看一下tcp层的connect的实现，其实就是从客户端视角看三次握手的过程。代码比较多，只看一下核心的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">static int tcp_connect(struct sock *sk, struct sockaddr_in *usin, int addr_len)</span><br><span class="line">&#123;</span><br><span class="line">    struct sk_buff *buff;</span><br><span class="line">    struct device *dev=NULL;</span><br><span class="line">    unsigned char *ptr;</span><br><span class="line">    int tmp;</span><br><span class="line">    int atype;</span><br><span class="line">    struct tcphdr *t1;</span><br><span class="line">    struct rtable *rt;</span><br><span class="line"></span><br><span class="line">    if (usin-&gt;sin_family &amp;&amp; usin-&gt;sin_family != AF_INET) </span><br><span class="line">        return(-EAFNOSUPPORT);</span><br><span class="line"></span><br><span class="line">      // 不传ip则取本机ip</span><br><span class="line">      if(usin-&gt;sin_addr.s_addr==INADDR_ANY)</span><br><span class="line">        usin-&gt;sin_addr.s_addr=ip_my_addr();</span><br><span class="line">    // 禁止广播和多播</span><br><span class="line">    if ((atype=ip_chk_addr(usin-&gt;sin_addr.s_addr)) == IS_BROADCAST || atype==IS_MULTICAST) </span><br><span class="line">        return -ENETUNREACH;</span><br><span class="line"></span><br><span class="line">    sk-&gt;inuse = 1;</span><br><span class="line">    // 连接的远端地址</span><br><span class="line">    sk-&gt;daddr = usin-&gt;sin_addr.s_addr;</span><br><span class="line">    // 第一个字节的序列号</span><br><span class="line">    sk-&gt;write_seq = tcp_init_seq();</span><br><span class="line">    sk-&gt;window_seq = sk-&gt;write_seq;</span><br><span class="line">    sk-&gt;rcv_ack_seq = sk-&gt;write_seq -1;</span><br><span class="line">    sk-&gt;err = 0;</span><br><span class="line">    // 远端端口</span><br><span class="line">    sk-&gt;dummy_th.dest = usin-&gt;sin_port;</span><br><span class="line">    release_sock(sk);</span><br><span class="line">    // 分配一个skb</span><br><span class="line">    buff = sk-&gt;prot-&gt;wmalloc(sk,MAX_SYN_SIZE,0, GFP_KERNEL);</span><br><span class="line">    sk-&gt;inuse = 1;</span><br><span class="line">    // tcp头和选项，告诉对方自己的接收窗口大小1</span><br><span class="line">    buff-&gt;len = 24;</span><br><span class="line">    buff-&gt;sk = sk;</span><br><span class="line">    buff-&gt;free = 0;</span><br><span class="line">    buff-&gt;localroute = sk-&gt;localroute;</span><br><span class="line">    t1 = (struct tcphdr *) buff-&gt;data;</span><br><span class="line">    // 查找路由</span><br><span class="line">    rt=ip_rt_route(sk-&gt;daddr, NULL, NULL);</span><br><span class="line">    // 构建ip和mac头</span><br><span class="line">    tmp = sk-&gt;prot-&gt;build_header(buff, sk-&gt;saddr, sk-&gt;daddr, &amp;dev,</span><br><span class="line">                    IPPROTO_TCP, NULL, MAX_SYN_SIZE,sk-&gt;ip_tos,sk-&gt;ip_ttl);</span><br><span class="line">    buff-&gt;len += tmp;</span><br><span class="line">    t1 = (struct tcphdr *)((char *)t1 +tmp);</span><br><span class="line">    memcpy(t1,(void *)&amp;(sk-&gt;dummy_th), sizeof(*t1));</span><br><span class="line">    // 序列号为初始化的序列号</span><br><span class="line">    t1-&gt;seq = ntohl(sk-&gt;write_seq++);</span><br><span class="line">    // 下一个数据包中第一个字节的序列号 </span><br><span class="line">    sk-&gt;sent_seq = sk-&gt;write_seq;</span><br><span class="line">    buff-&gt;h.seq = sk-&gt;write_seq;</span><br><span class="line">    t1-&gt;ack = 0;</span><br><span class="line">    t1-&gt;window = 2;</span><br><span class="line">    t1-&gt;res1=0;</span><br><span class="line">    t1-&gt;res2=0;</span><br><span class="line">    t1-&gt;rst = 0;</span><br><span class="line">    t1-&gt;urg = 0;</span><br><span class="line">    t1-&gt;psh = 0;</span><br><span class="line">    // 是一个syn包</span><br><span class="line">    t1-&gt;syn = 1;</span><br><span class="line">    t1-&gt;urg_ptr = 0;</span><br><span class="line">    // TCP头包括24个字节，因为还有4个字节的选项</span><br><span class="line">    t1-&gt;doff = 6;</span><br><span class="line"></span><br><span class="line">    // 执行tcp头后面的第一个字节</span><br><span class="line">    ptr = (unsigned char *)(t1+1);</span><br><span class="line">    // 选项的类型是2，通知对方TCP报文中数据部分的最大值</span><br><span class="line">    ptr[0] = 2;</span><br><span class="line">    // 选项内容长度是4个字节</span><br><span class="line">    ptr[1] = 4;</span><br><span class="line">    // 组成MSS</span><br><span class="line">    ptr[2] = (sk-&gt;mtu) &gt;&gt; 8;</span><br><span class="line">    ptr[3] = (sk-&gt;mtu) &amp; 0xff;</span><br><span class="line">    // tcp头的校验和</span><br><span class="line">    tcp_send_check(t1, sk-&gt;saddr, sk-&gt;daddr,sizeof(struct tcphdr) + 4, sk);</span><br><span class="line"></span><br><span class="line">    // 设置套接字为syn_send状态</span><br><span class="line">    tcp_set_state(sk,TCP_SYN_SENT);</span><br><span class="line">    // 设置数据包往返时间需要的时间</span><br><span class="line">    sk-&gt;rto = TCP_TIMEOUT_INIT;</span><br><span class="line">    // 设置超时回调</span><br><span class="line">    sk-&gt;retransmit_timer.function=&amp;retransmit_timer;</span><br><span class="line">    sk-&gt;retransmit_timer.data = (unsigned long)sk;</span><br><span class="line">    // 设置超时时间</span><br><span class="line">    reset_xmit_timer(sk, TIME_WRITE, sk-&gt;rto);  </span><br><span class="line">    // 设置syn包的重试次数</span><br><span class="line">    sk-&gt;retransmits = TCP_SYN_RETRIES;</span><br><span class="line">    // 发送</span><br><span class="line">    sk-&gt;prot-&gt;queue_xmit(sk, dev, buff, 0);  </span><br><span class="line">    reset_xmit_timer(sk, TIME_WRITE, sk-&gt;rto);</span><br><span class="line">    release_sock(sk);</span><br><span class="line">    return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很长，主要是构建一个sync包发出去。在这个代码里我们大概能看到tcp协议的相关实现。上面的代码完成了第一次握手。下面再看一下第二次握手的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 发送了syn包</span><br><span class="line">if(sk-&gt;state==TCP_SYN_SENT)</span><br><span class="line">&#123;</span><br><span class="line">    // 发送了syn包，收到ack包说明可能是建立连接的ack包</span><br><span class="line">    if(th-&gt;ack)</span><br><span class="line">    &#123;</span><br><span class="line">        // 尝试连接但是对端回复了重置包</span><br><span class="line">        if(th-&gt;rst)</span><br><span class="line">            return tcp_std_reset(sk,skb);</span><br><span class="line">        // 建立连接的回包 </span><br><span class="line">        syn_ok=1;   </span><br><span class="line">        // 期待收到对端下一个的序列号</span><br><span class="line">        sk-&gt;acked_seq=th-&gt;seq+1;</span><br><span class="line">        sk-&gt;fin_seq=th-&gt;seq;</span><br><span class="line">        // 发送第三次握手的ack包，进入连接建立状态</span><br><span class="line">        tcp_send_ack(sk-&gt;sent_seq,sk-&gt;acked_seq,sk,th,sk-&gt;daddr);</span><br><span class="line">        tcp_set_state(sk, TCP_ESTABLISHED);</span><br><span class="line">        // 解析tcp选项</span><br><span class="line">        tcp_options(sk,th);</span><br><span class="line">        // 记录对端地址</span><br><span class="line">        sk-&gt;dummy_th.dest=th-&gt;source;</span><br><span class="line">        // 可以读取但是还没读取的序列号</span><br><span class="line">        sk-&gt;copied_seq = sk-&gt;acked_seq;</span><br><span class="line">        // 唤醒阻塞在connect函数的进程</span><br><span class="line">        if(!sk-&gt;dead)</span><br><span class="line">        &#123;</span><br><span class="line">            sk-&gt;state_change(sk);</span><br><span class="line">            sock_wake_async(sk-&gt;socket, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码完成了第二次握手。tcp_send_ack完成第三次握手。这里不打算深入分析tcp层的代码，后续再深入分析。</p>
<br>



<br>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/redis/redis-list-blpop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Focus-1">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus-1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/redis/redis-list-blpop/" itemprop="url">线上redis blpop连接超时引发的血案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-13T00:00:00+08:00">
                2020-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <br>

<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p><code>REDIS_LIST</code> （列表）是 <a href="http://redis.readthedocs.org/en/latest/list/lpush.html#lpush" target="_blank" rel="noopener">LPUSH</a> 、 <a href="http://redis.readthedocs.org/en/latest/list/lrange.html#lrange" target="_blank" rel="noopener">LRANGE</a> 等命令的操作对象， 它使用 <code>REDIS_ENCODING_ZIPLIST</code> 和 <code>REDIS_ENCODING_LINKEDLIST</code> 这两种方式编码：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200617134225.png" alt></p>
<br>

<h2 id="编码的选择"><a href="#编码的选择" class="headerlink" title="编码的选择"></a>编码的选择</h2><p>创建新列表时 Redis 默认使用 <code>REDIS_ENCODING_ZIPLIST</code> 编码， 当以下任意一个条件被满足时， 列表会被转换成 <code>REDIS_ENCODING_LINKEDLIST</code> 编码：</p>
<ul>
<li>试图往列表新添加一个字符串值，且这个字符串的长度超过 <code>server.list_max_ziplist_value</code> （默认值为 <code>64</code> ）。</li>
<li><code>ziplist</code> 包含的节点超过 <code>server.list_max_ziplist_entries</code> （默认值为 <code>512</code> ）。</li>
</ul>
<br>

<h2 id="列表命令的实现"><a href="#列表命令的实现" class="headerlink" title="列表命令的实现"></a>列表命令的实现</h2><p>因为两种底层实现的抽象方式和列表的抽象方式非常接近， 所以列表命令几乎就是通过一对一地映射到底层数据结构的操作来实现的。</p>
<p>既然这些映射都非常直观， 这里就不做赘述了， 在以下的内容中， 我们将焦点放在 <a href="http://redis.readthedocs.org/en/latest/list/blpop.html#blpop" target="_blank" rel="noopener">BLPOP</a> 、 <a href="http://redis.readthedocs.org/en/latest/list/brpop.html#brpop" target="_blank" rel="noopener">BRPOP</a> 和 <a href="http://redis.readthedocs.org/en/latest/list/brpoplpush.html#brpoplpush" target="_blank" rel="noopener">BRPOPLPUSH</a> 这个几个阻塞命令的实现原理上。</p>
<br>

<h2 id="阻塞的条件"><a href="#阻塞的条件" class="headerlink" title="阻塞的条件"></a>阻塞的条件</h2><p><a href="http://redis.readthedocs.org/en/latest/list/blpop.html#blpop" target="_blank" rel="noopener">BLPOP</a> 、 <a href="http://redis.readthedocs.org/en/latest/list/brpop.html#brpop" target="_blank" rel="noopener">BRPOP</a> 和 <a href="http://redis.readthedocs.org/en/latest/list/brpoplpush.html#brpoplpush" target="_blank" rel="noopener">BRPOPLPUSH</a> 三个命令都可能造成客户端被阻塞， 以下将这些命令统称为列表的阻塞原语。</p>
<p>阻塞原语并不是一定会造成客户端阻塞：</p>
<ul>
<li>只有当这些命令被用于空列表时， 它们才会阻塞客户端。</li>
<li>如果被处理的列表不为空的话， 它们就执行无阻塞版本的 <a href="http://redis.readthedocs.org/en/latest/list/lpop.html#lpop" target="_blank" rel="noopener">LPOP</a> 、 <a href="http://redis.readthedocs.org/en/latest/list/rpop.html#rpop" target="_blank" rel="noopener">RPOP</a> 或 <a href="http://redis.readthedocs.org/en/latest/list/rpoplpush.html#rpoplpush" target="_blank" rel="noopener">RPOPLPUSH</a> 命令。</li>
</ul>
<p>作为例子，以下流程图展示了 <a href="http://redis.readthedocs.org/en/latest/list/blpop.html#blpop" target="_blank" rel="noopener">BLPOP</a> 决定是否对客户端进行阻塞过程：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200617134244.png" alt></p>
<br>

<h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>当一个阻塞原语的处理目标为空键时， 执行该阻塞原语的客户端就会被阻塞。</p>
<p>阻塞一个客户端需要执行以下步骤：</p>
<ol>
<li>将客户端的状态设为“正在阻塞”，并记录阻塞这个客户端的各个键，以及阻塞的最长时限（timeout）等数据。</li>
<li>将客户端的信息记录到 <code>server.db[i]-&gt;blocking_keys</code> 中（其中 <code>i</code> 为客户端所使用的数据库号码）。</li>
<li>继续维持客户端和服务器之间的网络连接，但不再向客户端传送任何信息，造成客户端阻塞。</li>
</ol>
<p>步骤 2 是将来解除阻塞的关键， <code>server.db[i]-&gt;blocking_keys</code> 是一个字典， 字典的键是那些造成客户端阻塞的键， 而字典的值是一个链表， 链表里保存了所有因为这个键而被阻塞的客户端 （被同一个键所阻塞的客户端可能不止一个）：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200617134302.png" alt></p>
<p>在上图展示的 <code>blocking_keys</code> 例子中， <code>client2</code> 、 <code>client5</code> 和 <code>client1</code> 三个客户端就正被 <code>key1</code> 阻塞， 而其他几个客户端也正在被别的两个 key 阻塞。</p>
<p>当客户端被阻塞之后，脱离阻塞状态有以下三种方法：</p>
<ol>
<li>被动脱离：有其他客户端为造成阻塞的键推入了新元素。</li>
<li>主动脱离：到达执行阻塞原语时设定的最大阻塞时间。</li>
<li>强制脱离：客户端强制终止和服务器的连接，或者服务器停机。</li>
</ol>
<p>以下内容将分别介绍被动脱离和主动脱离的实现方式。</p>
<br>

<h2 id="阻塞因-LPUSH-、-RPUSH-、-LINSERT-等添加命令而被取消"><a href="#阻塞因-LPUSH-、-RPUSH-、-LINSERT-等添加命令而被取消" class="headerlink" title="阻塞因 LPUSH 、 RPUSH 、 LINSERT 等添加命令而被取消"></a>阻塞因 LPUSH 、 RPUSH 、 LINSERT 等添加命令而被取消</h2><p>通过将新元素推入造成客户端阻塞的某个键中， 可以让相应的客户端从阻塞状态中脱离出来 （取消阻塞的客户端数量取决于推入元素的数量）。</p>
<p><a href="http://redis.readthedocs.org/en/latest/list/lpush.html#lpush" target="_blank" rel="noopener">LPUSH</a> 、 <a href="http://redis.readthedocs.org/en/latest/list/rpush.html#rpush" target="_blank" rel="noopener">RPUSH</a> 和 <a href="http://redis.readthedocs.org/en/latest/list/linsert.html#linsert" target="_blank" rel="noopener">LINSERT</a> 这三个添加新元素到列表的命令， 在底层都由一个 <code>pushGenericCommand</code> 的函数实现， 这个函数的运作流程如下图：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200617134319.png" alt></p>
<p>当向一个空键推入新元素时， <code>pushGenericCommand</code> 函数执行以下两件事：</p>
<ol>
<li>检查这个键是否存在于前面提到的 <code>server.db[i]-&gt;blocking_keys</code> 字典里， 如果是的话， 那么说明有至少一个客户端因为这个 key 而被阻塞，程序会为这个键创建一个 <code>redis.h/readyList</code> 结构， 并将它添加到 <code>server.ready_keys</code> 链表中。</li>
<li>将给定的值添加到列表键中。</li>
</ol>
<p><code>readyList</code> 结构的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">readyList</span> &#123;</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">    robj *key;</span><br><span class="line">&#125; readyList;</span><br></pre></td></tr></table></figure>

<p><code>readyList</code> 结构的 <code>key</code> 属性指向造成阻塞的键，而 <code>db</code> 则指向该键所在的数据库。</p>
<p>举个例子， 假设某个非阻塞客户端正在使用 <code>0</code> 号数据库， 而这个数据库当前的 <code>blocking_keys</code> 属性的值如下：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200617134338.png" alt></p>
<p>如果这时客户端对该数据库执行 <code>PUSH key3 value</code> ， 那么 <code>pushGenericCommand</code> 将创建一个 <code>db</code> 属性指向 <code>0</code> 号数据库、 <code>key</code> 属性指向 <code>key3</code> 键对象的 <code>readyList</code> 结构 ， 并将它添加到服务器 <code>server.ready_keys</code> 属性的链表中：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200617134353.png" alt></p>
<p>在我们这个例子中， 到目前为止， <code>pushGenericCommand</code> 函数完成了以下两件事：</p>
<ol>
<li>将 <code>readyList</code> 添加到服务器。</li>
<li>将新元素 <code>value</code> 添加到键 <code>key3</code> 。</li>
</ol>
<p>虽然 <code>key3</code> 已经不再是空键， 但到目前为止， 被 <code>key3</code> 阻塞的客户端还没有任何一个被解除阻塞状态。</p>
<p>为了做到这一点， Redis 的主进程在执行完 <code>pushGenericCommand</code> 函数之后， 会继续调用 <code>handleClientsBlockedOnLists</code> 函数， 这个函数执行以下操作：</p>
<ol>
<li>如果 <code>server.ready_keys</code> 不为空，那么弹出该链表的表头元素，并取出元素中的 <code>readyList</code> 值。</li>
<li>根据 <code>readyList</code> 值所保存的 <code>key</code> 和 <code>db</code> ，在 <code>server.blocking_keys</code> 中查找所有因为 <code>key</code> 而被阻塞的客户端（以链表的形式保存）。</li>
<li>如果 <code>key</code> 不为空，那么从 <code>key</code> 中弹出一个元素，并弹出客户端链表的第一个客户端，然后将被弹出元素返回给被弹出客户端作为阻塞原语的返回值。</li>
<li>根据 <code>readyList</code> 结构的属性，删除 <code>server.blocking_keys</code> 中相应的客户端数据，取消客户端的阻塞状态。</li>
<li>继续执行步骤 3 和 4 ，直到 <code>key</code> 没有元素可弹出，或者所有因为 <code>key</code> 而阻塞的客户端都取消阻塞为止。</li>
<li>继续执行步骤 1 ，直到 <code>ready_keys</code> 链表里的所有 <code>readyList</code> 结构都被处理完为止。</li>
</ol>
<p>用一段伪代码描述以上操作可能会更直观一些：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def handleClientsBlockedOnLists():</span><br><span class="line"></span><br><span class="line">    # 执行直到 ready_keys 为空</span><br><span class="line">    <span class="keyword">while</span> server.ready_keys != <span class="literal">NULL</span>:</span><br><span class="line"></span><br><span class="line">        # 弹出链表中的第一个 readyList</span><br><span class="line">        rl = server.ready_keys.pop_first_node()</span><br><span class="line"></span><br><span class="line">        # 遍历所有因为这个键而被阻塞的客户端</span><br><span class="line">        <span class="keyword">for</span> client in all_client_blocking_by_key(rl.key, rl.db):</span><br><span class="line"></span><br><span class="line">            # 只要还有客户端被这个键阻塞，就一直从键中弹出元素</span><br><span class="line">            # 如果被阻塞客户端执行的是 BLPOP ，那么对键执行 LPOP</span><br><span class="line">            # 如果执行的是 BRPOP ，那么对键执行 RPOP</span><br><span class="line">            element = rl.key.pop_element()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> element == <span class="literal">NULL</span>:</span><br><span class="line">                # 键为空，跳出 <span class="keyword">for</span> 循环</span><br><span class="line">                # 余下的未解除阻塞的客户端只能等待下次新元素的进入了</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                # 清除客户端的阻塞信息</span><br><span class="line">                server.blocking_keys.remove_blocking_info(client)</span><br><span class="line">                # 将元素返回给客户端，脱离阻塞状态</span><br><span class="line">                client.reply_list_item(element)</span><br></pre></td></tr></table></figure>

<br>

<h2 id="先阻塞先服务（FBFS）策略"><a href="#先阻塞先服务（FBFS）策略" class="headerlink" title="先阻塞先服务（FBFS）策略"></a>先阻塞先服务（FBFS）策略</h2><p>值得一提的是， 当程序添加一个新的被阻塞客户端到 <code>server.blocking_keys</code> 字典的链表中时， 它将该客户端放在链表的最后， 而当 <code>handleClientsBlockedOnLists</code> 取消客户端的阻塞时， 它从链表的最前面开始取消阻塞： 这个链表形成了一个 FIFO 队列， 最先被阻塞的客户端总是最先脱离阻塞状态， Redis 文档称这种模式为先阻塞先服务（FBFS，first-block-first-serve）。</p>
<p>举个例子，在下图所示的阻塞状况中， 如果客户端对数据库执行 <code>PUSH key3 value</code> ， 那么只有 <code>client3</code> 会被取消阻塞， <code>client6</code> 和 <code>client4</code> 仍然阻塞； 如果客户端对数据库执行 <code>PUSH key3 value1 value2</code> ， 那么 <code>client3</code> 和 <code>client4</code> 的阻塞都会被取消， 而客户端 <code>client6</code> 依然处于阻塞状态：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200617134413.png" alt></p>
<br>

<h2 id="阻塞因超过最大等待时间而被取消"><a href="#阻塞因超过最大等待时间而被取消" class="headerlink" title="阻塞因超过最大等待时间而被取消"></a>阻塞因超过最大等待时间而被取消</h2><p>前面提到过， 当客户端被阻塞时， 所有造成它阻塞的键， 以及阻塞的最长时限会被记录在客户端里面， 并且该客户端的状态会被设置为“正在阻塞”。</p>
<p>每次 Redis 服务器常规操作函数（server cron job）执行时， 程序都会检查所有连接到服务器的客户端， 查看那些处于“正在阻塞”状态的客户端的最大阻塞时限是否已经过期， 如果是的话， 就给客户端返回一个空白回复， 然后撤销对客户端的阻塞。</p>
<p>可以用一段伪代码来描述这个过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def server_cron_job():</span><br><span class="line"></span><br><span class="line">    # 其他操作 ...</span><br><span class="line"></span><br><span class="line">    # 遍历所有已连接客户端</span><br><span class="line">    for client in server.all_connected_client:</span><br><span class="line"></span><br><span class="line">        # 如果客户端状态为“正在阻塞”，并且最大阻塞时限已到达</span><br><span class="line">        if client.state == BLOCKING and \</span><br><span class="line">           client.max_blocking_timestamp &lt; current_timestamp():</span><br><span class="line"></span><br><span class="line">            # 那么给客户端发送空回复,脱离阻塞状态</span><br><span class="line">            client.send_empty_reply()</span><br><span class="line"></span><br><span class="line">            # 并清除客户端在服务器上的阻塞信息</span><br><span class="line">            server.blocking_keys.remove_blocking_info(client)</span><br><span class="line"></span><br><span class="line">    # 其他操作 ...</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/flink/flink-on-k8s/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Focus-1">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus-1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/flink/flink-on-k8s/" itemprop="url">Flink on K8s 部署</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-05T00:00:00+08:00">
                2020-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flink/" itemprop="url" rel="index">
                    <span itemprop="name">flink</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <br>

<blockquote>
<p>参考文档：</p>
</blockquote>
<blockquote>
<p>官网文档：</p>
<p><a href="https://ci.apache.org/projects/flink/flink-docs-stable/zh/ops/deployment/kubernetes.html" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-stable/zh/ops/deployment/kubernetes.html</a></p>
<p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/zh/ops/deployment/native_kubernetes.html" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-release-1.11/zh/ops/deployment/native_kubernetes.html</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/computer-network/tcpdump-tcp-3-and-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Focus-1">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus-1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/computer-network/tcpdump-tcp-3-and-4/" itemprop="url">TCP三次握手与Tcpdump抓包分析过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-22T14:51:54+08:00">
                2020-03-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<br>

<h2 id="一、TCP连接建立（三次握手）"><a href="#一、TCP连接建立（三次握手）" class="headerlink" title="一、TCP连接建立（三次握手）"></a>一、TCP连接建立（三次握手）</h2><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a><em>过程</em></h4><p>客户端A，服务器B，初始序号seq，确认号ack</p>
<p>初始状态：B处于监听状态，A处于打开状态</p>
<ul>
<li>A -&gt; B : seq = x （A向B发送连接请求报文段，A进入同步发送状态SYN-SENT）</li>
<li>B -&gt; A : ack = x + 1,seq = y （B收到报文段，向A发送确认，B进入同步收到状态SYN-RCVD）</li>
<li>A -&gt; B : ack = y+1 （A收到B的确认后，再次确认，A进入连接状态ESTABLISHED）</li>
</ul>
<p>连接后的状态：B收到A的确认后，进入连接状态ESTABLISHED</p>
<h4 id="为什么要握手要三次"><a href="#为什么要握手要三次" class="headerlink" title="为什么要握手要三次"></a><em>为什么要握手要三次</em></h4><p>防止失效的连接请求突然传到服务器端，让服务器端误认为要建立连接。</p>
<h2 id="二、TCP连接释放（四次挥手）"><a href="#二、TCP连接释放（四次挥手）" class="headerlink" title="二、TCP连接释放（四次挥手）"></a>二、TCP连接释放（四次挥手）</h2><h4 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a><em>过程</em></h4><p>A -&gt; B : seq = u （A发出连接释放报文段，进入终止等待1状态FIN-WAIT-1）</p>
<p>B -&gt; A : ack = u + 1,seq = v （B收到报文段，发出确认，TCP处于半关闭，B还可向A发数据，B进入关闭等待状态WAIT）</p>
<p>B -&gt; A : ack = u + 1,seq = w （B重复发送确认号，进入最后确认状态LAST-ACK）</p>
<p>A -&gt; B : ack = w + 1,seq = u + 1 （A发出确认，进入时间等待状态TIME-WAIT）</p>
<p>经过时间等待计时器设置的时间2MSL后，A才进入CLOSED状态</p>
<h4 id="为什么A进入TIME-WAIT后必须等待2MSL"><a href="#为什么A进入TIME-WAIT后必须等待2MSL" class="headerlink" title="为什么A进入TIME-WAIT后必须等待2MSL"></a><em>为什么A进入TIME-WAIT后必须等待2MSL</em></h4><ul>
<li>保证A发送的最后一个ACK报文段能达到B</li>
<li>防止失效的报文段出现在连接中</li>
</ul>
<h2 id="三、需要思考的问题"><a href="#三、需要思考的问题" class="headerlink" title="三、需要思考的问题"></a>三、需要思考的问题</h2><p>问题1: 请详细描述三次握手和四次挥手的过程<br>要求熟悉三次握手和四次挥手的机制，要求画出状态图。</p>
<p>问题2: 四次挥手中TIME_WAIT状态存在的目的是什么?<br>这个问题是画出四次挥手状态图，会引申问你。不排除还会问为什么四次挥手是四次不是二次等问题。最好是把相关问题均掌握。</p>
<p>问题3: TCP是通过什么机制保障可靠性的?<br>从四个方面进行回答，ACK确认机制、超时重传、滑动窗口以及流量控制，深入的话要求详细讲出流量控制的机制。</p>
<h2 id="四、Tcpdump使用"><a href="#四、Tcpdump使用" class="headerlink" title="四、Tcpdump使用"></a>四、Tcpdump使用</h2><p>tcpdump是对网络上的数据包进行截获的包分析工具，它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来去掉无用的信息。</p>
<h4 id="监视指定主机的数据包"><a href="#监视指定主机的数据包" class="headerlink" title="监视指定主机的数据包"></a><em>监视指定主机的数据包</em></h4><p><code>tcpdump host</code>：截获该IP的主机收到的和发出的所有的数据包<br><code>tcpdump host  and</code>：截获两个IP对应主机之间的通信</p>
<h4 id="监视指定端口的数据包"><a href="#监视指定端口的数据包" class="headerlink" title="监视指定端口的数据包"></a><em>监视指定端口的数据包</em></h4><p><code>tcpdump port &lt;端口号&gt;</code>：截获本机80端口的数据包</p>
<h2 id="五、抓包分析握手过程"><a href="#五、抓包分析握手过程" class="headerlink" title="五、抓包分析握手过程"></a>五、抓包分析握手过程</h2><p>抓包方法：首先使用tcpdump命令截获本机与某远程主机的数据包，然后打开某远程主机对应的网站，这里用我的域名<code>www.fonxian.cn</code>来做试验。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyping www.fonxian.cn</span><br></pre></td></tr></table></figure>

<p>得到域名对应的ip：<code>151.101.100.133</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyifconfg</span><br></pre></td></tr></table></figure>

<p>得到本机内网ip：<code>192.168.0.108</code></p>
<p>-S 参数的目的是获得ack的绝对值，不加该参数，第三次握手的ack为相对值1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copysudo tcpdump -S host 192.168.0.108 and 151.101.100.133</span><br></pre></td></tr></table></figure>

<p>得到下图<br><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200322152925.png" alt></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/computer-network/traceroute-icmp-and-tcp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Focus-1">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus-1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/computer-network/traceroute-icmp-and-tcp/" itemprop="url">ping通tcp不通</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-21T23:08:22+08:00">
                2020-03-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<br>

<h1 id="linux-机器"><a href="#linux-机器" class="headerlink" title="linux 机器"></a>linux 机器</h1><h3 id="TraceRoute-实现原理"><a href="#TraceRoute-实现原理" class="headerlink" title="TraceRoute 实现原理"></a>TraceRoute 实现原理</h3><p>Traceroute是用来侦测主机到目的主机之间所经路由情况的重要工具。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200322010041.png" alt></p>
<ol>
<li>从源地址发出一个UDP探测包到目的地址，并将TTL设置为1；</li>
<li>到达路由器时，将TTL减1；</li>
<li>当TTL变为0时，包被丢弃，路由器向源地址发回一个ICMP超时通知（ICMP Time Exceeded Message），内含发送IP包的源地址，IP包的所有内容及路由器的IP地址；</li>
<li>当源地址收到该ICMP包时，显示这一跳路由信息；</li>
<li>重复1～5，并每次设置TTL加1；</li>
<li>直至目标地址收到探测数据包，并返回端口不可达通知（ICMP Port Unreachable）；</li>
<li>当源地址收到ICMP Port Unreachable包时停止traceroute。</li>
</ol>
<blockquote>
<ol>
<li>Linux和Mac OS等系统使用UDP包进行探测，目标端口号默认为33434，每次探测目标端口号加1。Traceroute故意使用了一个大于 30000 的目标端口号，以保证目标地址收到数据包后能够返回一个“端口不可达”的 ICMP 报文，于是源地址就可将端口不可达报文当作跟踪结束的标志。</li>
<li>Traceroute每跳默认发送3个探测包（发包的数量可通过-q进行设置），探测包的返回会受到网络情况的影响。如果防火墙封掉了ICMP的返回信息，那么相应的延时位置会以*显示。如果某台网关阻塞或者某台DNS出现问题，那么相应行的延时会变长。可以加-n 参数来避免DNS解析，以IP格式输出数据。</li>
<li>每个探测包都有唯一的标识号，使得Traceroute能够识别返回的包。UDP数据包使用递增的目标端口号进行标识。</li>
</ol>
</blockquote>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200322003733.png" alt></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute [-n] -T -p &lt;目标端口号&gt; Host</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">traceroute [-46dFITUnreAV] [-f first_ttl] [-g gate,...]</span><br><span class="line">        [-i device] [-m max_ttl] [-p port] [-s src_addr]</span><br><span class="line">        [-q nqueries] [-N squeries] [-t tos]</span><br><span class="line">        [-l flow_label] [-w waittime] [-z sendwait] [-UL] [-D]</span><br><span class="line">        [-P proto] [--sport=port] [-M method] [-O mod_options]</span><br><span class="line">        [--mtu] [--back]</span><br><span class="line">        host [packet_len]</span><br><span class="line">traceroute6  [options]</span><br><span class="line">       </span><br><span class="line">Host 目标服务器域名或 IP。</span><br><span class="line">-4, -6 指定使用 IPv4 or IPv6</span><br><span class="line">-I 使用icmp探测</span><br><span class="line">-T 通过 TCP 探测</span><br><span class="line">-n 直接使用 IP 地址而非主机名称（禁用 DNS 反查）。</span><br><span class="line">-p port</span><br><span class="line">   对于UDP跟踪，指定将使用的目标端口基traceroute（目标端口号将由每个探测递增）。</span><br><span class="line">   对于ICMP跟踪，指定初始ICMP序列值（也由每个探测递增）。</span><br><span class="line">   对于TCP和其他端口，只指定要连接的（常量）目标端口。</span><br><span class="line">-r 绕过常规路由表，直接发送到连接网络上的主机。如果主机不在直接连接的网络上，则返回错误。此选项可用于通过没有路由的接口ping本地主机。</span><br><span class="line">-m max_ttl 默认最多30跳</span><br><span class="line">-w waittime 每一跳最多等待多长时间，默认5秒</span><br><span class="line">-g gateway 指定包出口网关</span><br><span class="line">-i interface 指定网卡名</span><br><span class="line">-s source_addr 指定源ip（必须是某个网卡ip）</span><br><span class="line">-z sendwait 指定每一跳的时间间隔（默认0）</span><br><span class="line">-e, --extensions 显示ICMP扩展（rfc4884）。一般形式是类/类型：后跟十六进制转储。MPLS（rfc4950）以如下形式显示：MPLS:L=label，E=exp_use，S=stack_bottom，T=TTL（更多由/）分隔的对象。</span><br><span class="line">-A 在路由注册表中执行路径查找，并在相应地址后直接打印结果。</span><br><span class="line">-q num, 每个网关发送num个数据包</span><br><span class="line"></span><br><span class="line">-------------</span><br><span class="line">--sport=port 选择一个源端口</span><br><span class="line">--fwmark=mark 设置一个防火墙标记</span><br><span class="line">-U, --udp 使用udp协议探测目标端口</span><br><span class="line">-UL, 使用 UDPLITE 进行探测</span><br><span class="line">-D, 使用DCCP（数据包拥塞控制协议）请求进行探测</span><br><span class="line">-P protocol，使用指定协议的原始数据包进行跟踪路由。默认协议是253</span><br><span class="line">--mtu 路径MTU是指一条因特网传输路径中，从源地址到目的地址所经过的“路径”上的所有IP跳的最大传输单元的最小值。或者从另外一个角度来看，就是无需进行分片处理就能穿过这条“路径”的最大传输单元的最大值。</span><br><span class="line">--back 响应包可能与探测包路径不同，打印响应包的跳数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">更多关于 traceroute 的用法，您可以通过man帮助查阅。</span><br></pre></td></tr></table></figure>

<p>异常节点判定方法：如果相关端口在某一跳被阻断，则其后各跳均不会返回数据。据此就可以判定出异常节点</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@10-1-53-21 ~]# traceroute -n -T -p 443 183.3.217.36</span><br><span class="line">traceroute to 183.3.217.36 (183.3.217.36), 30 hops max, 60 byte packets</span><br><span class="line"> 1  172.23.0.43  0.099 ms  0.051 ms  0.035 ms</span><br><span class="line"> 2  172.23.0.254  4.176 ms  4.487 ms  4.789 ms</span><br><span class="line"> 3  10.1.255.6  0.307 ms  0.425 ms  0.420 ms</span><br><span class="line"> 4  122.115.48.65  3.080 ms  3.535 ms  3.806 ms</span><br><span class="line"> 5  10.78.3.5  6.626 ms  7.133 ms  7.533 ms</span><br><span class="line"> 6  172.16.0.1  1.333 ms  1.355 ms  1.454 ms</span><br><span class="line"> 7  219.142.20.49  1.731 ms  1.738 ms  1.690 ms</span><br><span class="line"> 8  * * *</span><br><span class="line"> 9  * * *</span><br><span class="line">10  219.141.152.53  2.621 ms * *</span><br><span class="line">11  * * *</span><br><span class="line">12  * 119.147.222.122  42.294 ms 119.147.220.74  39.959 ms</span><br><span class="line">13  113.106.51.70  39.030 ms  38.859 ms 113.106.51.86  35.560 ms</span><br><span class="line">14  113.106.52.134  39.720 ms  40.552 ms  41.223 ms</span><br><span class="line">15  183.3.217.36  34.676 ms  36.169 ms  36.221 ms</span><br><span class="line">16  * * *</span><br><span class="line">17  * * *</span><br><span class="line">18  183.3.217.36  38.777 ms  39.290 ms  39.291 ms</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[root@10-1-53-21 ~]# traceroute -n -T -p 443 183.3.217.36</span><br><span class="line">traceroute to 183.3.217.36 (183.3.217.36), 30 hops max, 60 byte packets</span><br><span class="line"> 1  172.23.0.43  0.127 ms  0.101 ms  0.084 ms</span><br><span class="line"> 2  172.23.0.254  5.911 ms  7.257 ms  7.248 ms</span><br><span class="line"> 3  10.1.255.6  0.451 ms  0.441 ms  0.426 ms</span><br><span class="line"> 4  122.115.48.65  3.120 ms  3.574 ms  3.813 ms</span><br><span class="line"> 5  10.78.3.5  6.859 ms  7.208 ms  7.575 ms</span><br><span class="line"> 6  172.16.0.1  1.258 ms  1.364 ms  1.429 ms</span><br><span class="line"> 7  219.142.20.49  10.966 ms  10.785 ms  10.764 ms</span><br><span class="line"> 8  * * *</span><br><span class="line"> 9  * * *</span><br><span class="line">10  219.141.152.61  3.043 ms 219.141.152.65  6.084 ms *</span><br><span class="line">11  * * *</span><br><span class="line">12  * * *</span><br><span class="line">13  113.106.51.86  36.000 ms  35.589 ms 113.106.51.82  36.043 ms</span><br><span class="line">14  113.106.52.130  41.988 ms 113.106.52.134  38.881 ms  39.337 ms</span><br><span class="line">15  183.3.217.36  35.303 ms  36.716 ms  36.751 ms</span><br><span class="line">16  * * *</span><br><span class="line">17  * * *</span><br><span class="line">18  * * *</span><br><span class="line">19  * * *</span><br><span class="line">20  * * *</span><br><span class="line">21  * * *</span><br><span class="line">22  * * *</span><br><span class="line">23  * * *</span><br><span class="line">24  * * *</span><br><span class="line">25  * * *</span><br><span class="line">26  * * *</span><br><span class="line">27  * * *</span><br><span class="line">28  * * *</span><br><span class="line">29  * * *</span><br><span class="line">30  * * *</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">yum install -y sshpass</span><br><span class="line"></span><br><span class="line">nc 183.3.217.36 443</span><br><span class="line">nc -vz jzjyszdx01.jzsec.com 443</span><br><span class="line">nc -vz 183.3.217.36 443</span><br><span class="line">traceroute 183.3.217.36</span><br><span class="line">ping 183.3.217.36</span><br><span class="line">sshpass -p 'sdfsfsdfsgg' ssh root@10.198.45.139</span><br><span class="line">sshpass -p 'sdfsfsdfsgg' ssh root@10.198.45.141</span><br><span class="line">traceroute -n -T -p 443 183.3.217.36</span><br><span class="line">traceroute -4nTe -p 443 -m 40 183.3.217.36</span><br><span class="line">traceroute -4nIe -m 40 183.3.217.36</span><br><span class="line">traceroute -4nUe -p 443 -m 40 183.3.217.36</span><br><span class="line">traceroute -4nTe -m 40 -p 22 10.198.45.139</span><br><span class="line"></span><br><span class="line">nc 112.95.153.36 443</span><br><span class="line">nc -vz jzjyszlt01.jzsec.com 443</span><br><span class="line">nc -vz 112.95.153.36 443</span><br><span class="line">traceroute -m 40 112.95.153.36</span><br><span class="line">traceroute -n -T -p 443 112.95.153.36</span><br><span class="line">traceroute -4nTe -p 443 -m 40 112.95.153.36</span><br><span class="line">sshpass -p 'sdfsfsdfsgg' ssh root@10.198.45.140</span><br><span class="line">sshpass -p 'sdfsfsdfsgg' ssh root@10.198.45.142</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@10-1-53-21 ~]# nc 183.3.217.36 443</span><br><span class="line">123ewq</span><br><span class="line">[root@10-1-53-21 ~]# netstat -atn | grep "ES" | grep 183.3.217.36</span><br><span class="line">[root@10-1-53-21 ~]# netstat -atn | grep "ES" | grep 112.95.153.36</span><br><span class="line">[root@10-198-45-139 ~]# tcpdump 'tcp and src 122.115.48.123 and dst port 443 and (((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) &lt; 20)' -XX</span><br><span class="line">[root@10-198-45-139 ~]# tcpdump 'tcp and src 43.227.140.124 and dst port 443 and (((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) &lt; 20)' -XX</span><br><span class="line">tcpdump 'tcp and dst port 443 and (0 &lt; ((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2))) and (((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) &lt; 20)' -XX</span><br></pre></td></tr></table></figure>

<h1 id="windows-机器"><a href="#windows-机器" class="headerlink" title="windows 机器"></a>windows 机器</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracetcp &lt;目标服务器域名或 IP&gt;:&lt;待探测端口号&gt;</span><br></pre></td></tr></table></figure>

<p>异常节点判定方法：如果相关端口在某一跳被阻断，则其后各跳均不会返回数据。据此就可以判定出异常节点</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20200322010343.png" alt></p>
<h3 id="Tracert实现原理"><a href="#Tracert实现原理" class="headerlink" title="Tracert实现原理"></a>Tracert实现原理</h3><ol>
<li><p>从源地址发出一个ICMP请求回显（ICMP Echo Request）数据包到目的地址，并将TTL设置为1；</p>
</li>
<li><p>到达路由器时，将TTL减1；</p>
</li>
<li><p>当TTL变为0时，包被丢弃，路由器向源地址发回一个ICMP超时通知（ICMP Time Exceeded Message），内含发送IP包的源地址，IP包的所有内容及路由器的IP地址；</p>
</li>
<li><p>当源地址收到该ICMP包时，显示这一跳路由信息；</p>
</li>
<li><p>重复1～5，并每次设置TTL加1；</p>
</li>
<li><p>直至目标地址收到探测数据包，并返回ICMP回应答复（ICMPEcho Reply）；</p>
</li>
<li><p>当源地址收到ICMP Echo Reply包时停止tracert。</p>
</li>
</ol>
<blockquote>
<p><strong>注：</strong></p>
<p>1.Windows系统使用ICMP请求回显（ICMP Echo Request）数据包进行探测，源地址以目的地址返回的ICMP回应答复（ICMP Echo Reply）作为跟踪结束标志。</p>
<p>2.Traceroute每跳默认发送3个探测包。在未能到达路由器或未返回ICMP超时通知的情况下，相应的延时位置会以*显示。</p>
<p>3.每个探测包都有唯一的标识号，ICMP数据包使用seq进行标识。</p>
</blockquote>
<h3 id="tracetcp"><a href="#tracetcp" class="headerlink" title="tracetcp"></a>tracetcp</h3><p>安装依赖</p>
<p><a href="https://www.winpcap.org/" target="_blank" rel="noopener">https://www.winpcap.org/</a></p>
<p>下载tracetcp，解压后放在c:/windows下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.github.com/simulatedsimian/tracetcp</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">tracetcp host [options]</span><br><span class="line">    where host = hostName|ipAddress[:portNumber|serviceName]</span><br><span class="line">    if portNumber or serviceName is not present then port 80 (http) </span><br><span class="line">    is assumed.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">    -?            Displays help information.</span><br><span class="line"></span><br><span class="line">    -c            Select condensed output mode</span><br><span class="line"></span><br><span class="line">    -h start_hop  Starts trace at hop specified.</span><br><span class="line"></span><br><span class="line">    -m max_hops   Maximum number of hops to reach target.</span><br><span class="line"></span><br><span class="line">    -n            No reverse DNS lookups for each node.</span><br><span class="line"></span><br><span class="line">    -p num_pings  # of pings per hop (default 3).</span><br><span class="line"></span><br><span class="line">    -r p1 p2      Multiple traces from port p1 to p2.</span><br><span class="line"></span><br><span class="line">    -t timeout    Wait timeout milliseconds for each reply.</span><br><span class="line"></span><br><span class="line">    -v            Displays version information.</span><br><span class="line"></span><br><span class="line">    -s p1 p2      Easy port scan mode. gives the same result as</span><br><span class="line">                  setting the following options:</span><br><span class="line">                  -cnr p1 p2 -h 128 -m 1 -p 1</span><br><span class="line"></span><br><span class="line">    -F            Disables the Anti-flood timer. Normally tracetcp</span><br><span class="line">                  waits *at least* 0.5 seconds between sending out </span><br><span class="line">                  each packet, because if the packets are sent too </span><br><span class="line">                  fast some host seem to detect this as some form of </span><br><span class="line">                  flood and stop responding for a time. This option </span><br><span class="line">                  disables the 0.5 second timer, so the traces occur</span><br><span class="line">                  faster.</span><br><span class="line"></span><br><span class="line">    -R            Use raw socket interface to send/receive packets</span><br><span class="line">                  this will not work on XP sp2. </span><br><span class="line">                  (you still need winpcap installed)</span><br><span class="line"></span><br><span class="line">    -g address    use the specified host as a a gateway to remote</span><br><span class="line">                  systems rather than the default gateway.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">    tracetcp www.microsoft.com:80 -m 60</span><br><span class="line">    tracetcp post.sponge.com:smtp</span><br><span class="line">    tracetcp 192.168.0.1 -n -t 500</span><br></pre></td></tr></table></figure>

<h3 id="itracert"><a href="#itracert" class="headerlink" title="itracert"></a>itracert</h3><h3 id="tcping"><a href="#tcping" class="headerlink" title="tcping"></a>tcping</h3><h3 id="httpping"><a href="#httpping" class="headerlink" title="httpping"></a>httpping</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/micro-service/spring-cloud/nacos/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Focus-1">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus-1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/micro-service/spring-cloud/nacos/" itemprop="url">Nacos 快速开始</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-14T00:00:00+08:00">
                2020-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/springcloud/" itemprop="url" rel="index">
                    <span itemprop="name">springcloud</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<blockquote>
<p>官网：<a href="https://nacos.io/zh-cn/docs/quick-start.html" target="_blank" rel="noopener">https://nacos.io/zh-cn/docs/quick-start.html</a></p>
</blockquote>
<h1 id="Nacos-Server-安装"><a href="#Nacos-Server-安装" class="headerlink" title="Nacos Server 安装"></a>Nacos Server 安装</h1><p>这个快速开始手册是帮忙您快速在您的电脑上，下载、安装并使用 Nacos。</p>
<h2 id="0-版本选择"><a href="#0-版本选择" class="headerlink" title="0.版本选择"></a>0.版本选择</h2><p>您可以在Nacos的<a href="https://github.com/alibaba/nacos/releases" target="_blank" rel="noopener">release notes</a>及<a href="https://nacos.io/zh-cn/blog/index.html" target="_blank" rel="noopener">博客</a>中找到每个版本支持的功能的介绍，当前推荐的稳定版本为1.1.4。</p>
<h2 id="1-预备环境准备"><a href="#1-预备环境准备" class="headerlink" title="1.预备环境准备"></a>1.预备环境准备</h2><p>Nacos 依赖 <a href="https://docs.oracle.com/cd/E19182-01/820-7851/inst_cli_jdk_javahome_t/" target="_blank" rel="noopener">Java</a> 环境来运行。如果您是从代码开始构建并运行Nacos，还需要为此配置 <a href="https://maven.apache.org/index.html" target="_blank" rel="noopener">Maven</a>环境，请确保是在以下版本环境中安装使用:</p>
<ol>
<li>64 bit OS，支持 Linux/Unix/Mac/Windows，推荐选用 Linux/Unix/Mac。</li>
<li>64 bit JDK 1.8+；<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">下载</a> &amp; <a href="https://docs.oracle.com/cd/E19182-01/820-7851/inst_cli_jdk_javahome_t/" target="_blank" rel="noopener">配置</a>。</li>
<li>Maven 3.2.x+；<a href="https://maven.apache.org/download.cgi" target="_blank" rel="noopener">下载</a> &amp; <a href="https://maven.apache.org/settings.html" target="_blank" rel="noopener">配置</a>。</li>
</ol>
<h2 id="2-下载源码或者安装包"><a href="#2-下载源码或者安装包" class="headerlink" title="2.下载源码或者安装包"></a>2.下载源码或者安装包</h2><p>你可以通过源码和发行包两种方式来获取 Nacos。</p>
<h3 id="从-Github-上下载源码方式"><a href="#从-Github-上下载源码方式" class="headerlink" title="从 Github 上下载源码方式"></a>从 Github 上下载源码方式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/alibaba/nacos.git</span><br><span class="line"><span class="built_in">cd</span> nacos/</span><br><span class="line">mvn -Prelease-nacos -Dmaven.test.skip=<span class="literal">true</span> clean install -U  </span><br><span class="line">ls -al distribution/target/</span><br><span class="line"></span><br><span class="line">// change the <span class="variable">$version</span> to your actual path</span><br><span class="line"><span class="built_in">cd</span> distribution/target/nacos-server-<span class="variable">$version</span>/nacos/bin</span><br></pre></td></tr></table></figure>

<h3 id="下载编译后压缩包方式"><a href="#下载编译后压缩包方式" class="headerlink" title="下载编译后压缩包方式"></a>下载编译后压缩包方式</h3><p>您可以从 <a href="https://github.com/alibaba/nacos/releases" target="_blank" rel="noopener">最新稳定版本</a> 下载 <code>nacos-server-$version.zip</code> 包。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unzip nacos-server-<span class="variable">$version</span>.zip 或者 tar -xvf nacos-server-<span class="variable">$version</span>.tar.gz</span><br><span class="line"><span class="built_in">cd</span> nacos/bin</span><br></pre></td></tr></table></figure>

<h2 id="3-启动服务器"><a href="#3-启动服务器" class="headerlink" title="3.启动服务器"></a>3.启动服务器</h2><h3 id="Linux-Unix-Mac"><a href="#Linux-Unix-Mac" class="headerlink" title="Linux/Unix/Mac"></a>Linux/Unix/Mac</h3><p>启动命令(standalone代表着单机模式运行，非集群模式):</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh startup.sh -m standalone</span><br></pre></td></tr></table></figure>

<p>如果您使用的是ubuntu系统，或者运行脚本报错提示[[符号找不到，可尝试如下运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash startup.sh -m standalone</span><br></pre></td></tr></table></figure>

<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>启动命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd startup.cmd</span><br></pre></td></tr></table></figure>

<p>或者双击startup.cmd运行文件。</p>
<h2 id="4-服务注册-amp-发现和配置管理"><a href="#4-服务注册-amp-发现和配置管理" class="headerlink" title="4.服务注册&amp;发现和配置管理"></a>4.服务注册&amp;发现和配置管理</h2><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST 'http://127.0.0.1:8848/nacos/v1/ns/instance?serviceName=nacos.naming.serviceName&amp;ip=20.18.7.10&amp;port=8080'</span><br></pre></td></tr></table></figure>

<h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET 'http://127.0.0.1:8848/nacos/v1/ns/instance/list?serviceName=nacos.naming.serviceName'</span><br></pre></td></tr></table></figure>

<h3 id="发布配置"><a href="#发布配置" class="headerlink" title="发布配置"></a>发布配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST "http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test&amp;content=HelloWorld"</span><br></pre></td></tr></table></figure>

<h3 id="获取配置"><a href="#获取配置" class="headerlink" title="获取配置"></a>获取配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET "http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test"</span><br></pre></td></tr></table></figure>

<h2 id="5-关闭服务器"><a href="#5-关闭服务器" class="headerlink" title="5.关闭服务器"></a>5.关闭服务器</h2><h3 id="Linux-Unix-Mac-1"><a href="#Linux-Unix-Mac-1" class="headerlink" title="Linux/Unix/Mac"></a>Linux/Unix/Mac</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh shutdown.sh</span><br></pre></td></tr></table></figure>

<h3 id="Windows-1"><a href="#Windows-1" class="headerlink" title="Windows"></a>Windows</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd shutdown.cmd</span><br></pre></td></tr></table></figure>

<p>或者双击shutdown.cmd运行文件。</p>
<h2 id="6-浏览器访问"><a href="#6-浏览器访问" class="headerlink" title="6.浏览器访问"></a>6.浏览器访问</h2><blockquote>
<p><a href="http://localhost:8848/nacos/" target="_blank" rel="noopener">http://localhost:8848/nacos/</a></p>
<p>nacos/nacos</p>
</blockquote>
<h2 id="7-配置mysql"><a href="#7-配置mysql" class="headerlink" title="7.配置mysql"></a>7.配置mysql</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create database nacos_config;</span><br><span class="line">show variables like 'innodb_large_prefix'</span><br><span class="line">show variables like 'innodb_file_format'</span><br><span class="line">set global innodb_large_prefix  = 1;</span><br><span class="line">set global innodb_file_format=BARRACUDA</span><br></pre></td></tr></table></figure>

<p>问题解决</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Err] 1071 - Specified key was too long; max key length is 767 bytes</span><br><span class="line">[Err] 1709 - Index column size too large. The maximum column size is 767 bytes.</span><br><span class="line"></span><br><span class="line">1、set global innodb_large_prefix=on</span><br><span class="line">2、set global variable innodb_file_format=BARRACUDA</span><br><span class="line">3、使用 Innodb引擎在建表语句后加入ROW_FORMAT=DYNAMIC or ROW_FORMAT=COMPRESSED ，默认是ROW_FORMAT=COMPACT</span><br><span class="line"></span><br><span class="line">vim /etc/my.cnf</span><br><span class="line">innodb_large_prefix=on</span><br><span class="line">innodb_file_format=BARRACUDA</span><br></pre></td></tr></table></figure>

<h1 id="Nacos-Docker安装"><a href="#Nacos-Docker安装" class="headerlink" title="Nacos Docker安装"></a>Nacos Docker安装</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --env MODE=standalone --name nacos -d -p 8848:8848 docker.io/nacos/nacos-server:latest</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/nacos-group/nacos-docker/blob/master/build/Dockerfile</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cd /data/components/nacos-docker/</span><br><span class="line">docker-compose -f example/standalone-mysql-5.7.yaml up -d</span><br><span class="line">docker-compose -f example/standalone-mysql-5.7.yaml down</span><br><span class="line"></span><br><span class="line">docker-compose -f example/standalone-mysql.yaml up -d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(base) [root@dev-10-1-171-41 env]# route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         10.1.171.1      0.0.0.0         UG    100    0        0 eth0</span><br><span class="line">10.1.171.0      0.0.0.0         255.255.255.0   U     100    0        0 eth0</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class="line">172.18.1.84     10.1.171.1      255.255.255.255 UGH   0      0        0 eth0</span><br><span class="line"></span><br><span class="line">(base) [root@dev-10-1-171-41 nacos-docker]# docker network ls</span><br><span class="line">NETWORK ID          NAME                  DRIVER              SCOPE</span><br><span class="line">4d95fdb44032        bridge                bridge              local</span><br><span class="line">b19a30233e5d        example_ncosnetwork   bridge              local</span><br><span class="line">2b9e87501791        host                  host                local</span><br><span class="line">dbc75370a996        none                  null                local</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/go/go-echo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Focus-1">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus-1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/go-echo/" itemprop="url">go web服务器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-02T00:00:00+08:00">
                2020-03-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index">
                    <span itemprop="name">go</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <br>

<blockquote>
<p>官网：<a href="https://echo.labstack.com/guide" target="_blank" rel="noopener">https://echo.labstack.com/guide</a></p>
<p>github：<a href="https://github.com/labstack/echo.git" target="_blank" rel="noopener">https://github.com/labstack/echo.git</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/devops/docker/docker-iptables-bad-rule/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Focus-1">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus-1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/devops/docker/docker-iptables-bad-rule/" itemprop="url">Centos7 中 firewalld导致docker网络异常</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-02T00:00:00+08:00">
                2020-03-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/devops/" itemprop="url" rel="index">
                    <span itemprop="name">devops</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/devops/docker/" itemprop="url" rel="index">
                    <span itemprop="name">docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <br>

<h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>宿主机访问docker中的服务时，时而正常，时而超时</p>
<p>排查工具：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httping http://kess-uat_host/WebServiceProxy/ProxyService</span><br></pre></td></tr></table></figure>

<p>Centos7 自带防火墙是firewalld。在某下情况下可能导致docker 的某些网络问题。</p>
<p>docker 有4种网络模式：</p>
<ol>
<li>bridge模式（默认）：网桥模式，通过虚拟网桥使容器通信。容器有自己的独立ip和端口。</li>
<li>host模式：主机模式，与主机共用一个网络，容器ip是主机的ip，端口占用主机的端口范围。</li>
<li>container模式：与指定容器共享一个网络，类似host模式，但是是两个容器间共用一个ip。</li>
<li>none模式：无网络模式，容器有自己的内部网络，但是没有分配ip，路由等信息，需要自己分配。</li>
</ol>
<p>默认是bridge 网桥模式，docker会在宿住机配置一个虚拟网卡，并将容器连接到该网卡，而docker网络与宿住机外部网络的通信，是借助nat来实现的。所以当Iptable出现问题时，就会导致docker容器网络异常</p>
<h1 id="查看firewalld-日志"><a href="#查看firewalld-日志" class="headerlink" title="查看firewalld 日志"></a>查看firewalld 日志</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -10 /var/log/firewalld</span><br></pre></td></tr></table></figure>

<p>在日志中可以看到一些警告信息，是docker添加的nat规则，但是因为chain不存在，所以添加失败。一般情况下是没有什么问题，但是某些情况，比如容器内需要访问宿住机的服务，则可能出现问题。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">WARNING: COMMAND_FAILED: '/usr/sbin/iptables -w2 -t nat -D PREROUTING' failed: iptables: Bad rule (does a matching rule exist in that chain?).</span><br><span class="line">WARNING: COMMAND_FAILED: '/usr/sbin/iptables -w2 -t nat -D OUTPUT' failed: iptables: Bad rule (does a matching rule exist in that chain?).</span><br><span class="line">WARNING: COMMAND_FAILED: '/usr/sbin/iptables -w2 -t nat -F DOCKER' failed: iptables: No chain/target/match by that name.</span><br><span class="line">WARNING: COMMAND_FAILED: '/usr/sbin/iptables -w2 -t nat -X DOCKER' failed: iptables: No chain/target/match by that name.</span><br><span class="line">WARNING: COMMAND_FAILED: '/usr/sbin/iptables -w2 -t filter -F DOCKER' failed: iptables: No chain/target/match by that name.</span><br><span class="line">WARNING: COMMAND_FAILED: '/usr/sbin/iptables -w2 -t filter -X DOCKER' failed: iptables: No chain/target/match by that name.</span><br><span class="line">WARNING: COMMAND_FAILED: '/usr/sbin/iptables -w2 -t filter -F DOCKER-ISOLATION' failed: iptables: No chain/target/match by that name.</span><br><span class="line">WARNING: COMMAND_FAILED: '/usr/sbin/iptables -w2 -t filter -X DOCKER-ISOLATION' failed: iptables: No chain/target/match by that name.</span><br><span class="line">WARNING: COMMAND_FAILED: '/usr/sbin/iptables -w2 -t nat -n -L DOCKER' failed: iptables: No chain/target/match by that name.</span><br><span class="line">WARNING: COMMAND_FAILED: '/usr/sbin/iptables -w2 -t filter -n -L DOCKER' failed: iptables: No chain/target/match by that name.</span><br><span class="line">WARNING: COMMAND_FAILED: '/usr/sbin/iptables -w2 -t filter -n -L DOCKER-ISOLATION' failed: iptables: No chain/target/match by that name.</span><br><span class="line">WARNING: COMMAND_FAILED: '/usr/sbin/iptables -w2 -t filter -C DOCKER-ISOLATION -j RETURN' failed: iptables: Bad rule (does a matching rule exist in that chain?).</span><br><span class="line">WARNING: COMMAND_FAILED: '/usr/sbin/iptables -w2 -t nat -C POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE' failed: iptables: No chain/target/match by that name.</span><br><span class="line">WARNING: COMMAND_FAILED: '/usr/sbin/iptables -w2 -t nat -C DOCKER -i docker0 -j RETURN' failed: iptables: Bad rule (does a matching rule exist in that chain?).</span><br><span class="line">WARNING: COMMAND_FAILED: '/usr/sbin/iptables -w2 -D FORWARD -i docker0 -o docker0 -j DROP' failed: iptables: Bad rule (does a matching rule exist in that chain?).</span><br><span class="line">WARNING: COMMAND_FAILED: '/usr/sbin/iptables -w2 -t filter -C FORWARD -i docker0 -o docker0 -j ACCEPT' failed: iptables: Bad rule (does a matching rule exist in that chain?).</span><br><span class="line">WARNING: COMMAND_FAILED: '/usr/sbin/iptables -w2 -t filter -C FORWARD -i docker0 ! -o docker0 -j ACCEPT' failed: iptables: Bad rule (does a matching rule exist in that chain?).</span><br><span class="line">WARNING: COMMAND_FAILED: '/usr/sbin/iptables -w2 -t filter -C FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT' failed: iptables: Bad rule (does a matching rule exist in that chain?).</span><br><span class="line">WARNING: COMMAND_FAILED: '/usr/sbin/iptables -w2 -t nat -C PREROUTING -m addrtype --dst-type LOCAL -j DOCKER' failed: iptables: No chain/target/match by that name.</span><br><span class="line">WARNING: COMMAND_FAILED: '/usr/sbin/iptables -w2 -t nat -C OUTPUT -m addrtype --dst-type LOCAL -j DOCKER ! --dst 127.0.0.0/8' failed: iptables: No chain/target/match by that name.</span><br><span class="line">WARNING: COMMAND_FAILED: '/usr/sbin/iptables -w2 -t filter -C FORWARD -o docker0 -j DOCKER' failed: iptables: No chain/target/match by that name.</span><br></pre></td></tr></table></figure>

<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h3 id="1-修改docker网络模式为host"><a href="#1-修改docker网络模式为host" class="headerlink" title="1. 修改docker网络模式为host"></a>1. 修改docker网络模式为host</h3><p>在运行容器时添加参数 –net=host，但是不能从根本上解决问题。</p>
<h3 id="2-将firewalld换成iptables（推荐）"><a href="#2-将firewalld换成iptables（推荐）" class="headerlink" title="2. 将firewalld换成iptables（推荐）"></a>2. 将firewalld换成iptables（推荐）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看firewalld是否启用</span></span><br><span class="line">systemctl status firewalld</span><br><span class="line"><span class="meta">#</span><span class="bash">停止firewalld</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="meta">#</span><span class="bash">禁用firewalld（否则重启系统后会再次启动）</span></span><br><span class="line">systemctl disable firewalld</span><br><span class="line"><span class="meta">#</span><span class="bash">查看是否安装iptables</span></span><br><span class="line">yum list installed | grep iptables-services</span><br><span class="line"><span class="meta">#</span><span class="bash">如果没安装则安装下</span></span><br><span class="line">yum install iptables-services -y</span><br><span class="line"><span class="meta">#</span><span class="bash">重启iptables</span></span><br><span class="line">systemctl restart iptables</span><br><span class="line"><span class="meta">#</span><span class="bash">设置开机自启</span></span><br><span class="line">systemctl enable iptables</span><br><span class="line"><span class="meta">#</span><span class="bash">重启docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<h3 id="3-关闭防火墙"><a href="#3-关闭防火墙" class="headerlink" title="3. 关闭防火墙"></a>3. 关闭防火墙</h3><p>不推荐，特别是在生产环境</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看firewalld是否启用</span></span><br><span class="line">systemctl status firewalld</span><br><span class="line"><span class="meta">#</span><span class="bash">停止firewalld</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="meta">#</span><span class="bash">禁用firewalld（否则重启系统后会再次启动）</span></span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/devops/istio/istio-doc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Focus-1">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus-1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/devops/istio/istio-doc/" itemprop="url">Istio文档</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-02T00:00:00+08:00">
                2020-03-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/service-mesh/" itemprop="url" rel="index">
                    <span itemprop="name">service-mesh</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/service-mesh/istio/" itemprop="url" rel="index">
                    <span itemprop="name">istio</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <br>



<p>文档：<a href="https://istio.io/latest/zh/docs/concepts/traffic-management/" target="_blank" rel="noopener">https://istio.io/latest/zh/docs/concepts/traffic-management/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Focus-1</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">250</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">63</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">102</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://gitee.com/carloz" title="repository - https://gitee.com/carloz" target="_blank">repository - https://gitee.com/carloz</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Focus-1</span>

  
</div>








  <div class="footer-custom">Hosted by <a target="_blank" href="https://gitee.com/carloz">Gitee Repo</a></div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
