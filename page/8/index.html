<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  
    
      
    

    
  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=consolas:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="keywords" content="Java Kafka Docker JVM NIO Netty">
<meta property="og:type" content="website">
<meta property="og:title" content="CarloZ">
<meta property="og:url" content="https://carlo-z.com/page/8/index.html">
<meta property="og:site_name" content="CarloZ">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CarloZ">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://carlo-z.com/page/8/">





  <title>CarloZ</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CarloZ</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/mysql/mysql-innodb-locking-and-transaction-model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="-CarloZ">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CarloZ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/mysql/mysql-innodb-locking-and-transaction-model/" itemprop="url">mysql 锁和事务模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-18T00:00:00+08:00">
                2018-12-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<br>

<h1 id="一、Locking-锁"><a href="#一、Locking-锁" class="headerlink" title="一、Locking 锁"></a>一、Locking 锁</h1><h3 id="1、锁分类"><a href="#1、锁分类" class="headerlink" title="1、锁分类"></a>1、锁分类</h3><h4 id="1-1、共享锁和独占锁"><a href="#1-1、共享锁和独占锁" class="headerlink" title="1.1、共享锁和独占锁"></a>1.1、共享锁和独占锁</h4><p>InnoDB实现了两种标准行级锁，一种是共享锁 (<strong><em>shared locks，S锁</em></strong>)，另一种是独占锁，或者叫排它锁 (<strong><em>exclusive locks，X锁</em></strong>)。</p>
<p>共享锁：允许 事务 持有 read 一行 的锁；</p>
<p>独占锁：允许 事务 持有 update 或 delete 一行的锁；</p>
<p><u><strong>S锁</strong></u></p>
<p>如果事务T1持有了行r上的<code>S锁</code>，则其他事务可以同时持有行r的<code>S锁</code>，但是不能对行r加<code>X锁</code>。</p>
<p><u><strong>X锁</strong></u></p>
<p>如果事务T1持有了行r上的<code>X锁</code>，则其他任何事务不能持有行r的<code>X锁</code>，必须等待T1在行r上的<code>X锁</code>释放。</p>
<p>如果事务T1在行r上保持<code>S锁</code>，则另一个事务T2对行r的锁的请求按如下方式处理：</p>
<ul>
<li>T2可以同时持有S锁</li>
<li>T2如果想在行r上获取<code>X锁</code>，必须等待其他事务对该行添加的<code>S锁</code>或<code>X锁</code>的释放。</li>
</ul>
<br>

<h4 id="1-2、Intention-Locks-意向锁"><a href="#1-2、Intention-Locks-意向锁" class="headerlink" title="1.2、Intention Locks 意向锁"></a>1.2、Intention Locks 意向锁</h4><p>​        InnoDB 支持 多颗粒度加锁，允许 行锁 和 表锁 共存。例如， <a href="https://dev.mysql.com/doc/refman/5.6/en/lock-tables.html" target="_blank" rel="noopener"><code>LOCK TABLES ... WRITE</code></a> 就是在指定表上加独占锁。为了支持多颗粒度加锁，InnoDB设计了 意向锁。意向锁 是 一种 表级锁，用来 指示 一个事务对表中的一行数据需要加 哪种类型（<code>shared 或 exclusive</code>）的锁。</p>
<p>意向锁有两种：</p>
<ul>
<li><p><code>intention shared lock (IS)</code>意向共享锁：表示 一个事务 倾向于 对一行数据 使用共享锁；在 transaction 获取一个 共享锁（S） 之前 必须先获得一个 IS 锁；</p>
</li>
<li><p><code>intention exclusive lock (IX)</code>意向独占锁：表示 一个事务 倾向于 对一行数据 使用独占锁；在 transaction 获取一个 独占锁（X） 之前 必须先获得一个 IX 锁；</p>
</li>
</ul>
<p>例如：<a href="https://dev.mysql.com/doc/refman/5.6/en/select.html" target="_blank" rel="noopener"><code>SELECT ... LOCK IN SHARE MODE</code></a>  使用的就是 IS 锁， <a href="https://dev.mysql.com/doc/refman/5.6/en/select.html" target="_blank" rel="noopener"><code>SELECT ... FOR UPDATE</code></a> 使用的是 IX 锁；</p>
<br>

<h4 id="1-3、锁的兼容性"><a href="#1-3、锁的兼容性" class="headerlink" title="1.3、锁的兼容性"></a>1.3、锁的兼容性</h4><p>锁的兼容矩阵如下：</p>
<table>
<thead>
<tr>
<th align="left">—</th>
<th align="center">排它锁(X)</th>
<th align="center">意向排它锁(IX)</th>
<th align="center">共享锁(S)</th>
<th align="center">意向共享锁(IS)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">排它锁(X)</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
</tr>
<tr>
<td align="left">意向排它锁(IX)</td>
<td align="center">N</td>
<td align="center">OK</td>
<td align="center">N</td>
<td align="center">OK</td>
</tr>
<tr>
<td align="left">共享锁(S)</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">OK</td>
<td align="center">OK</td>
</tr>
<tr>
<td align="left">意向共享锁(IS)</td>
<td align="center">N</td>
<td align="center">OK</td>
<td align="center">OK</td>
<td align="center">OK</td>
</tr>
</tbody></table>
<p>按照上面的兼容性，如果不同事务之间的锁兼容，则当前加锁事务可以持有锁，如果有冲突则会等待其他事务的锁释放。</p>
<p><strong>如果一个事务请求锁时，请求的锁与已经持有的锁冲突而无法获取时，互相等待就可能会产生死锁。</strong></p>
<p>意向锁不会阻止除了全表锁定请求之外的任何锁请求。<br>意向锁的主要目的是显示事务正在锁定某行或者正意图锁定某行。</p>
<br>

<h3 id="2、InnoDB-中的锁"><a href="#2、InnoDB-中的锁" class="headerlink" title="2、InnoDB 中的锁"></a>2、InnoDB 中的锁</h3><h4 id="2-1、准备工作"><a href="#2-1、准备工作" class="headerlink" title="2.1、准备工作"></a>2.1、准备工作</h4><p>示例的基础是一个只有两列的数据库表。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> create database test;</span><br><span class="line"><span class="meta">mysql&gt;</span> use test;</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span> CREATE TABLE test (</span><br><span class="line">id int(11) NOT NULL,</span><br><span class="line">code int(11) NOT NULL, </span><br><span class="line">PRIMARY KEY(id), </span><br><span class="line">KEY (code)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; </span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span> INSERT INTO test(id,code) values(1,1),(10,10);</span><br></pre></td></tr></table></figure>

<p>数据表<code>test</code>只有两列，<code>id</code>是主键索引，<code>code</code>是普通的索引(注意，一定不要是唯一索引)，并初始化了两条记录，分别是(1,1),(10,10)。<br>这样，我们验证唯一键索引就可以使用id列，验证普通索引(非唯一键二级索引)时就使用code列。</p>
<h4 id="2-2、查看锁状态的方法"><a href="#2-2、查看锁状态的方法" class="headerlink" title="2.2、查看锁状态的方法"></a>2.2、查看锁状态的方法</h4><p>要看到锁的情况，必须<u><strong>手动开启多个事务</strong></u>，其中一些锁的状态的查看则必须使锁处于<code>waiting</code>状态，这样才能在mysql的引擎状态日志中看到。</p>
<p>命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> show engine innodb status;</span><br></pre></td></tr></table></figure>

<p>这条命令能显示最近几个事务的状态、查询和写入情况等信息。当出现死锁时，命令能给出最近的死锁明细。</p>
<h4 id="2-3、Record-Locks-记录锁"><a href="#2-3、Record-Locks-记录锁" class="headerlink" title="2.3、Record Locks 记录锁"></a>2.3、Record Locks 记录锁</h4><p><code>record lock</code> 是 对 index record 加锁的一种锁。例如 <code>SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;</code> 阻止其他事务 插入、更新、删除 <code>t.c1=10</code> 的行；</p>
<p>record lock 总是对 index 加锁，即使表没有定义任何索引。在这种情况下 InnoDB 会添加一个隐藏主键；</p>
<blockquote>
<h4 id="查看记录锁"><a href="#查看记录锁" class="headerlink" title="查看记录锁"></a>查看记录锁</h4><p>开启第一个事务，不提交，测试完之后回滚。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; mysql&gt; start transaction;</span><br><span class="line">&gt; Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">&gt; </span><br><span class="line">&gt; mysql&gt; update test set id=2 where id=1;</span><br><span class="line">&gt; Query OK, 1 row affected (0.00 sec)</span><br><span class="line">&gt; Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>事务加锁情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; mysql&gt; show engine innodb status\G;</span><br><span class="line">&gt; ... </span><br><span class="line">&gt; ------------</span><br><span class="line">&gt; TRANSACTIONS</span><br><span class="line">&gt; ------------</span><br><span class="line">&gt; ---TRANSACTION 366811, ACTIVE 690 sec</span><br><span class="line">&gt; 2 lock struct(s), heap size 1136, 1 row lock(s), undo log entries 2</span><br><span class="line">&gt; MySQL thread id 785, OS thread handle 123145432457216, query id 729076 localhost 127.0.0.1 root</span><br><span class="line">&gt; ...</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>可以看到有一行被加了锁。由之前对锁的描述可以推测出，update语句给<code>id=1</code>这一行上加了一个<code>X锁</code>。</p>
<blockquote>
<p>注意：X锁广义上是一种抽象意义的排它锁，即锁一般分为<code>X模式</code>和<code>S模式</code>，狭义上指row或者index上的锁，而Record锁是索引上的锁。<br>为了不修改数据，可以用<code>select ... for update</code>语句，加锁行为和<code>update</code>、<code>delete</code>是一样的，<code>insert</code>加锁机制较为复杂，后面的章节会提到。</p>
</blockquote>
<p>第一个事务保持原状，不要提交或者回滚，现在开启第二个事务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; mysql&gt; start transaction;</span><br><span class="line">&gt; Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">&gt; </span><br><span class="line">&gt; mysql&gt; update test set id=3 where id=1;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>执行<code>update</code>时，sql语句的执行被阻塞了。查看下事务状态:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; mysql&gt; show engine innodb status\G;</span><br><span class="line">&gt; ...</span><br><span class="line">&gt; ------- TRX HAS BEEN WAITING 4 SEC FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">&gt; RECORD LOCKS space id 62 page no 3 n bits 72 index PRIMARY of table `test`.`test` trx id 366820 lock_mode X locks rec but not gap waiting</span><br><span class="line">&gt; Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 32</span><br><span class="line">&gt;  0: len 8; hex 0000000000000001; asc         ;;</span><br><span class="line">&gt;  1: len 6; hex 0000000598e3; asc       ;;</span><br><span class="line">&gt;  2: len 7; hex 7e000001a80896; asc ~      ;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; ------------------</span><br><span class="line">&gt; ...</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>喜闻乐见，我们看到了这个锁的状态。状态标题是’事务正在等待获取锁’，描述中的<code>lock_mode X locks rec but not gap</code>就是本章节中的record记录锁，直译一下’X锁模式锁住了记录’。后面还有一句<code>but not gap</code>意思是只对record本身加锁，并不对间隙加锁，间隙锁的叙述见下一个章节。</p>
</blockquote>
<br>

<h4 id="2-4、Gap-Locks-间隙锁"><a href="#2-4、Gap-Locks-间隙锁" class="headerlink" title="2.4、Gap Locks 间隙锁"></a>2.4、Gap Locks 间隙锁</h4><p>​    <code>gap lock</code> 作用在索引记录之间的间隔，又或者作用在第一个索引之前，最后一个索引之后的间隙。不包括索引本身。例如，<code>SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;</code>这条语句阻止其他事务插入10和20之间的数字，无论这个数字是否存在。<code>gap lock</code> 是性能和并发权衡的产物，只存在于部分事务隔离级别。</p>
<p><code>SELECT * FROM child WHERE id = 100;</code> </p>
<ul>
<li>如果id本身是唯一索引，那么 gap lock 是不生效的；</li>
<li>如果 id 和 其他的列 组成的联合索引是 唯一索引， 那么 gap lock 是生效的，锁定了 <code>child[100][x] ~ child[100][y]</code> 之间的记录； </li>
<li>如果 id 上 没有加索引 或者 不是唯一索引，gap lock 生效；</li>
</ul>
<p>简单来说就是 <u><strong>gap lock 锁定的是一个范围（0~N条记录），而不是单条记录</strong></u>；</p>
<p>​    InnoDB中的Gap锁是“纯粹的抑制性锁”，这意味着它们的<u><strong>唯一目的</strong></u>是<u><strong>防止其他事务插入到Gap中</strong></u>。间隙锁可以共存。一个事务所采取的间隙锁并不会阻止另一个事务对同一间隙采取间隙锁。共享锁和独占锁之间没有区别。它们彼此不冲突，并且执行相同的功能。</p>
<p>禁用gap lock：</p>
<ul>
<li>将 隔离级别 设为 <code>READ COMMITTED</code> ；</li>
<li>启用 innodb_locks_unsafe_for_binlog</li>
</ul>
<br>

<blockquote>
<h4 id="查看间隙锁"><a href="#查看间隙锁" class="headerlink" title="查看间隙锁"></a>查看间隙锁</h4><p>按照官方文档，<code>where</code>子句查询条件是唯一键且指定了值时，只有record锁，没有gap锁。<br>如果<code>where</code>语句指定了范围，gap锁是存在的。<br>这里只测试验证一下当指定非唯一键索引的时候，gap锁的位置，按照文档的说法，会锁定当前索引及索引之前的间隙。(<strong><em>指定了非唯一键索引,例如code=10，间隙锁仍然存在\</em></strong>)</p>
<p>开启第一个事务，锁定一条非唯一的普通索引记录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;mysql&gt; start transaction;</span><br><span class="line">&gt;Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">&gt;</span><br><span class="line">&gt;mysql&gt; select * from test where code = 10 for update;</span><br><span class="line">&gt;+----+------+</span><br><span class="line">&gt;| id | code |</span><br><span class="line">&gt;+----+------+</span><br><span class="line">&gt;| 10 |   10 |</span><br><span class="line">&gt;+----+------+</span><br><span class="line">&gt;1 row in set (0.00 sec)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>由于预存了两条数据，row(1,1)和row(10,10)，此时这个间隙应该是`1。我们先插入row(2,2)来验证下gap锁的存在，再插入row(0,0)来验证gap的边界。</p>
<blockquote>
<p>按照间隙锁的官方文档定义，<code>select * from test where code = 10 for update;</code>会锁定<code>code=10</code>这个索引，并且会锁定<code>code&lt;10</code>的间隙。</p>
</blockquote>
<p>开启第二个事务，在<code>code=10</code>之前的间隙中插入一条数据，看下这条数据是否能够插入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;mysql&gt; start transaction;</span><br><span class="line">&gt;Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">&gt;</span><br><span class="line">&gt;mysql&gt; insert into test values(2,2);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>插入的时候，执行被阻塞，查看引擎状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;mysql&gt; show engine innodb status\G;</span><br><span class="line">&gt;...</span><br><span class="line">&gt;---TRANSACTION 366864, ACTIVE 5 sec inserting</span><br><span class="line">&gt;mysql tables in use 1, locked 1</span><br><span class="line">&gt;LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s), undo log entries 1</span><br><span class="line">&gt;MySQL thread id 793, OS thread handle 123145434963968, query id 730065 localhost 127.0.0.1 root update</span><br><span class="line">&gt;insert into test values(2,2)</span><br><span class="line">&gt;------- TRX HAS BEEN WAITING 5 SEC FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">&gt;RECORD LOCKS space id 63 page no 4 n bits 72 index code of table `test`.`test` trx id 366864 lock_mode X locks gap before rec insert intention waiting</span><br><span class="line">&gt;Record lock, heap no 3 PHYSICAL RECORD: n_fields 2; compact format; info bits 0</span><br><span class="line">&gt; 0: len 8; hex 800000000000000a; asc         ;;</span><br><span class="line">&gt; 1: len 8; hex 000000000000000a; asc         ;;</span><br><span class="line">&gt;</span><br><span class="line">&gt;------------------</span><br><span class="line">&gt;...</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>插入语句被阻塞了，<code>lock_mode X locks gap before rec</code>，由于第一个事务锁住了1到10之间的gap，需要等待获取锁之后才能插入。</p>
<p>如果再开启一个事务，插入(0,0)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;mysql&gt; start transaction;</span><br><span class="line">&gt;mysql&gt; insert into test values(0,0);</span><br><span class="line">&gt;Query OK, 1 row affected (0.00 sec)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>可以看到：<strong><em>指定的非唯一建索引的gap锁的边界是当前索引到上一个索引之间的gap\</em></strong>。</p>
<p>最后给出锁定区间的示例,首先插入一条记录(5,5)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;mysql&gt; insert into test values(5,5);</span><br><span class="line">&gt;Query OK, 1 row affected (0.00 sec)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>开启第一个事务:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;mysql&gt; start transaction;</span><br><span class="line">&gt;Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">&gt;</span><br><span class="line">&gt;mysql&gt; select * from test where code between 1 and 10 for update;</span><br><span class="line">&gt;+----+------+</span><br><span class="line">&gt;| id | code |</span><br><span class="line">&gt;+----+------+</span><br><span class="line">&gt;|  1 |    1 |</span><br><span class="line">&gt;|  5 |    5 |</span><br><span class="line">&gt;| 10 |   10 |</span><br><span class="line">&gt;+----+------+</span><br><span class="line">&gt;3 rows in set (0.00 sec)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>第二个事务，试图去更新code=5的行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;mysql&gt; begin;</span><br><span class="line">&gt;Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">&gt;</span><br><span class="line">&gt;mysql&gt; update test set code=4 where code=5;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>执行到这里，如果第一个事务不提交或者回滚的话，第二个事务一直等待直至mysql中设定的超时时间。</p>
</blockquote>
<br>

<h4 id="2-5、Next-Key-Locks"><a href="#2-5、Next-Key-Locks" class="headerlink" title="2.5、Next-Key Locks"></a>2.5、Next-Key Locks</h4><p>Next-key 锁实际上是Record锁和gap锁的组合。Next-key锁是在 下一个索引记录本身 和 索引之前的gap 加上S锁或是X锁(如果是读就加上S锁，如果是写就加X锁)。</p>
<p>​    默认情况下，InnoDB的事务隔离级别为RR，系统参数 <code>innodb_locks_unsafe_for_binlog</code> 的值为<code>false</code>。InnoDB使用next-key锁对索引进行扫描和搜索，这样就读取不到幻象行，避免了<code>幻读</code>的发生。</p>
<blockquote>
<p>幻读是指在同一事务下，连续执行两次同样的SQL语句，第二次的SQL语句可能会返回之前不存在的行。</p>
</blockquote>
<p>​    当查询的索引是唯一索引时，Next-key lock会进行优化，降级为Record Lock，此时Next-key lock仅仅作用在索引本身，而不会作用于gap和下一个索引上。</p>
<br>

<blockquote>
<h4 id="查看Next-key锁"><a href="#查看Next-key锁" class="headerlink" title="查看Next-key锁"></a>查看Next-key锁</h4><h5 id="Next-key锁的作用范围"><a href="#Next-key锁的作用范围" class="headerlink" title="Next-key锁的作用范围"></a>Next-key锁的作用范围</h5><p>如上述例子，数据表<code>test</code>初始化了row(1,1),row(10,10)，然后插入了row(5,5)。数据表如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; mysql&gt; select * from test;</span><br><span class="line">&gt; +----+------+</span><br><span class="line">&gt; | id | code |</span><br><span class="line">&gt; +----+------+</span><br><span class="line">&gt; |  1 |    1 |</span><br><span class="line">&gt; |  5 |    5 |</span><br><span class="line">&gt; | 10 |   10 |</span><br><span class="line">&gt; +----+------+</span><br><span class="line">&gt; 3 rows in set (0.00 sec)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>由于<code>id</code>是主键、唯一索引，mysql会做优化，因此使用<code>code</code>这个非唯一键的二级索引来举例说明。</p>
<p>对于<code>code</code>，可能的next-key锁的范围是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; (-∞,1]</span><br><span class="line">&gt; (1,5]</span><br><span class="line">&gt; (5,10]</span><br><span class="line">&gt; (10,+∞)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>开启第一个事务，在<code>code=5</code>的索引上请求更新:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; mysql&gt; start transaction;</span><br><span class="line">&gt; Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">&gt; </span><br><span class="line">&gt; mysql&gt; select * from test where code=5 for update;</span><br><span class="line">&gt; +----+------+</span><br><span class="line">&gt; | id | code |</span><br><span class="line">&gt; +----+------+</span><br><span class="line">&gt; |  5 |    5 |</span><br><span class="line">&gt; +----+------+</span><br><span class="line">&gt; 1 row in set (8.81 sec)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>之前在gap锁的章节中介绍了，<code>code=5 for update</code>会在<code>code=5</code>的索引上加一个record锁，还会在1&lt;gap&lt;5的间隙上加gap锁。现在不再验证，直接插入一条(8,8)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; mysql&gt; start transaction;</span><br><span class="line">&gt; Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">&gt; mysql&gt; insert into test values(8,8);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><code>insert</code>处于等待执行的状态，这就是<code>next-key锁</code>生效而导致的结果。第一个事务，锁定了区间(1,5]，由于RR的隔离级别下<code>next-key锁</code>处于开启生效状态，又锁定了(5,10]区间。所以插入SQL语句的执行被阻塞。</p>
<blockquote>
<p>解释：在这种情况下，被锁定的区域是<code>code=5</code>前一个索引到它的间隙，以及next-key的区域。<code>code=5 for update</code>对索引的锁定用区间表示，gap锁锁定了(1,5)，record锁锁定了{5}索引记录，next-key锁锁住了(5,10]，也就是说整个(1,10]的区间被锁定了。由于是<code>for update</code>，所以这里的锁都是X锁，因此阻止了其他事务中带有冲突锁定的操作执行。</p>
</blockquote>
<p>如果我们在第一个事务中，执行了<code>code &gt; 8 for update</code>，在扫描过程中，找到了<code>code=10</code>，此时就会锁住10之前的间隙(5到10之间的gap)，10本身(record)，和10之后的间隙(next-key)。此时另一个事务插入(6,6),(9,9)和(11,11)都是不被允许的，只有在前一个索引5及5之前的索引和间隙才能执行插入(更新和删除也会被阻塞)。</p>
</blockquote>
<br>

<h4 id="2-6、Insert-Intention-Locks"><a href="#2-6、Insert-Intention-Locks" class="headerlink" title="2.6、Insert Intention Locks"></a>2.6、Insert Intention Locks</h4><p>插入意向锁在行插入之前由INSERT设置一种间隙锁，是意向排它锁的一种。<br>在多事务同时写入不同数据至同一索引间隙的时，不会发生锁等待，事务之间互相不影响其他事务的完成，这和间隙锁的定义是一致的。</p>
<p>假设一个记录索引包含4和7，其他不同的事务分别插入5和6，此时只要行不冲突，插入意向锁不会互相等待，可以直接获取。参照锁兼容/冲突矩阵。<br>插入意向锁的例子不再列举，可以查看gap锁的第一个例子。</p>
<br>

<h4 id="2-7、AUTO-INC-Locks"><a href="#2-7、AUTO-INC-Locks" class="headerlink" title="2.7、AUTO-INC Locks"></a>2.7、AUTO-INC Locks</h4><p>​    auto-inc lock 是一种特殊的表级锁。如果一个事务正在向表中插入值，那么任何其他事务都必须等待，以便由第一个事务插入的行接收连续的主键值。</p>
<p>​    我们一般把主键设置为<code>AUTO_INCREMENT</code>的列，默认情况下这个字段的值为0，InnoDB会在<code>AUTO_INCREMENT</code>修饰下的数据列所关联的索引末尾设置独占锁。在访问自增计数器时，InnoDB使用自增锁，但是锁定仅仅持续到当前SQL语句的末尾，而不是整个事务的结束，毕竟自增锁是表级别的锁，如果长期锁定会大大降低数据库的性能。由于是表锁，在使用期间，其他会话无法插入表中。</p>
<br>



<h1 id="二、不同sql语句设置的锁"><a href="#二、不同sql语句设置的锁" class="headerlink" title="二、不同sql语句设置的锁"></a>二、不同sql语句设置的锁</h1><p>​    如果一个SQL语句要对二级索引(非主键索引)设置X模式的Record锁，InnoDB还会检索出相应的聚簇索引(主键索引)并对它们设置锁定。</p>
<h3 id="1、-SELECT-…-FROM…不加锁"><a href="#1、-SELECT-…-FROM…不加锁" class="headerlink" title="1、 SELECT … FROM…不加锁"></a>1、 SELECT … FROM…不加锁</h3><p><code>SELECT ... FROM</code>是快照读取，除了<strong><code>SERIALIZABLE</code></strong>的事务隔离级别，该SQL语句执行时不会加任何锁。</p>
<p><strong><code>SERIALIZABLE</code></strong>级别下，<code>SELECT</code>语句的执行会在遇到的索引记录上设置S模式的next-key锁。但是对于唯一索引，只锁定索引记录，而不会锁定gap。</p>
<br>

<h3 id="2、-UPDATE系列"><a href="#2、-UPDATE系列" class="headerlink" title="2、 UPDATE系列"></a>2、 UPDATE系列</h3><p>S锁读取(<code>SELECT ... LOCK IN SHARE MODE</code>)，X锁读取(<code>SELECT ... FOR UPDATE</code>)、更新<code>UPDATE</code>和删除<code>DELETE</code>这四类语句，采用的锁取决于搜索条件中使用的索引类型。</p>
<ul>
<li>如果使用唯一索引，InnoDB仅锁定索引记录本身，不锁定间隙。</li>
<li>如果使用非唯一索引，或者未命中索引，InnoDB使用间隙锁或者next-key锁来锁定索引范围，这样就可以阻止其他事务插入锁定范围。</li>
</ul>
<br>

<h4 id="2-1、-UPDATE语句"><a href="#2-1、-UPDATE语句" class="headerlink" title="2.1、 UPDATE语句"></a>2.1、 UPDATE语句</h4><p><code>UPDATE ... WHERE ...</code>在搜索遇到的每条记录上设置一个独占的next-key锁，如果是唯一索引只锁定记录。<br>当<code>UPDATE</code>修改聚簇索引时，将对受影响的二级索引采用隐式锁，隐式锁是在索引中对二级索引的记录逻辑加锁，实际上不产生锁对象，不占用内存空间。</p>
<blockquote>
<p>​    例如 <code>update test set code=100 where id=10;</code> 执行的时候 <code>code=10</code> 的索引(code是二级索引，见文中给出的建表语句)会被加隐式锁，只有隐式锁产生冲突时才会变成显式锁(如S锁、X锁)。即此时另一个事务也去更新 <code>id=10</code> 这条记录，隐式锁就会升级为显示锁。<br>​    这样做的好处是降低了锁的开销。</p>
</blockquote>
<p><code>UPDATE</code>可能会导致新的普通索引的插入。当新的索引插入之前，会首先执行一次<strong><em>重复索引检查</em></strong>。在重复检查和插入时，更新操作会对受影响的二级索引记录采用共享锁定(S锁)。</p>
<br>

<h4 id="2-2、-DELETE语句"><a href="#2-2、-DELETE语句" class="headerlink" title="2.2、 DELETE语句"></a>2.2、 DELETE语句</h4><p><code>DELETE FROM ... WHERE ...</code>在搜索遇到的每条记录上设置一个独占的next-key锁,如果是唯一索引只锁定记录。</p>
<br>

<h3 id="3、-INSERT"><a href="#3、-INSERT" class="headerlink" title="3、 INSERT"></a>3、 INSERT</h3><p><code>INSERT</code>区别于UPDATE系列单独列出，是因为它的处理方式较为特别。</p>
<p>插入行之前，会设置一种插入意向锁，插入意向锁表示插入的意图。如果其它事务在 <strong><em>要插入的位置</em></strong> 上设置了X锁，则无法获取插入意向锁，插入操作也因此阻塞。</p>
<p><code>INSERT</code>在插入的行上设置X锁。该锁是一个Record锁，并不是next-key锁，即只锁定记录本身，不锁定间隙，因此不会阻止其他 session 在这行记录前的间隙中插入新的记录。</p>
<br>

<h1 id="三、Deadlocks-死锁"><a href="#三、Deadlocks-死锁" class="headerlink" title="三、Deadlocks 死锁"></a>三、Deadlocks 死锁</h1><p>​    <u><strong>死锁</strong></u>是指由于每个事务都持有对方需要的锁而无法进行其他事务的情况。因为这两个事务都在等待资源变得可用，所以都不会释放它持有的锁。</p>
<h3 id="1、死锁示例"><a href="#1、死锁示例" class="headerlink" title="1、死锁示例"></a>1、死锁示例</h3><p>该示例涉及两个客户端A和B。</p>
<p>首先，客户端A创建一个包含一行的表，然后开始事务。在事务中，A通过<code>S</code>在共享模式下选择该行来获得对该行的 锁定：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> CREATE TABLE t (i INT) ENGINE = InnoDB;</span><br><span class="line">Query OK, 0 rows affected (1.07 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span> INSERT INTO t (i) VALUES(1);</span><br><span class="line">Query OK, 1 row affected (0.09 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span> START TRANSACTION;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span> SELECT * FROM t WHERE i = 1 LOCK IN SHARE MODE;</span><br><span class="line">+------+</span><br><span class="line">| i    |</span><br><span class="line">+------+</span><br><span class="line">|    1 |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure>

<p>接下来，客户端B开始事务并尝试从表中删除该行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> START TRANSACTION;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span> DELETE FROM t WHERE i = 1;</span><br></pre></td></tr></table></figure>

<p>删除操作需要一个<code>X</code>锁。无法授予该<code>S</code>锁，因为它与客户端A持有的锁不兼容 ，因此该请求进入针对行和客户端B块的锁请求队列中。</p>
<p>最后，客户端A还尝试从表中删除该行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> DELETE FROM t WHERE i = 1;</span><br><span class="line">ERROR 1213 (40001): Deadlock found when trying to get lock;</span><br><span class="line">try restarting transaction</span><br></pre></td></tr></table></figure>

<p>此处发生死锁是因为客户端A需要 <code>X</code>锁才能删除该行。但是，不能授予该锁定请求，因为客户端B已经有一个<code>X</code>锁定请求，并且正在等待客户端A释放其<code>S</code>锁定。由于B事先要求锁，所以<code>S</code>A持有的锁也不能 升级 <code>X</code>为<code>X</code>锁。结果， <code>InnoDB</code>为其中一个客户端生成错误并释放其锁。客户端返回此错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1213 (40001): Deadlock found when trying to get lock;</span><br><span class="line">try restarting transaction</span><br></pre></td></tr></table></figure>

<p>届时，可以授予对另一个客户端的锁定请求，并从表中删除该行。</p>
<br>

<h3 id="2、死锁检测和回滚"><a href="#2、死锁检测和回滚" class="headerlink" title="2、死锁检测和回滚"></a>2、死锁检测和回滚</h3><p>​        <code>InnoDB</code>自动检测事务 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_deadlock" target="_blank" rel="noopener">死锁</a>并回滚一个或多个事务以打破死锁。 <code>InnoDB</code>尝试选择要回滚的小事务，其中事务的大小由插入，更新或删除的行数确定。</p>
<p>​        如果死锁无法检测，通过设置 innodb_lock_wait_timeout 来解决；</p>
<p>​        如果 一个事务被完整的会滚，那么它所持有的所有锁都会被释放；但如果由于出错仅仅一条sql被会滚，那么某些锁可能不会被释放；这是因为 InnoDB存储行锁的格式 无法确定后续的锁会被哪些sql持有；</p>
<ul>
<li><p>要查看InnoDB用户事务中的最后一个死锁，请使用SHOW ENGINE INNODB STATUS命令。</p>
</li>
<li><p>如果频繁出现死锁，则说明事务结构或应用程序错误处理存在问题，请在innodb_print_all_deadlocks 启用该设置的情况下运行，以 将有关所有死锁的信息打印到 mysqld错误日志中</p>
</li>
</ul>
<br>

<h3 id="3、如何最小化并处理死锁"><a href="#3、如何最小化并处理死锁" class="headerlink" title="3、如何最小化并处理死锁"></a>3、如何最小化并处理死锁</h3><p><code>InnoDB</code>使用自动行级锁定。即使在仅插入或 删除 单行的事务中，也可能会遇到死锁。这是因为这些操作并不是真正的“ 原子 ”操作。它们会自动对插入或删除的行的（可能是多个）索引记录设置锁定。</p>
<p>您可以使用以下技术来处理死锁并减少发生死锁的可能性：</p>
<ul>
<li><p>在任何时候，发出 <a href="https://dev.mysql.com/doc/refman/5.6/en/show-engine.html" target="_blank" rel="noopener"><code>SHOW ENGINE INNODB STATUS</code></a>命令以确定最近死锁的原因。这可以帮助您调整应用程序以避免死锁。</p>
</li>
<li><p>如果频繁出现死锁警告引起关注，请通过启用<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_print_all_deadlocks" target="_blank" rel="noopener"><code>innodb_print_all_deadlocks</code></a> 配置选项来收集更广泛的调试信息 。有关每个死锁的信息，而不仅仅是最新的死锁，都记录在MySQL <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_error_log" target="_blank" rel="noopener">错误日志中</a>。完成调试后，请禁用此选项。</p>
</li>
<li><p>如果由于死锁而失败，请始终准备重新发出事务。死锁并不危险。请再试一次。</p>
</li>
<li><p>保持交易小巧且持续时间短，以使交易不易发生冲突。</p>
</li>
<li><p>进行一系列相关更改后立即提交事务，以减少冲突的发生。特别是，不要长时间未提交事务而使交互式 <a href="https://dev.mysql.com/doc/refman/5.6/en/mysql.html" target="_blank" rel="noopener"><strong>mysql</strong></a>会话保持打开状态。</p>
</li>
<li><p>如果您使用<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_locking_read" target="_blank" rel="noopener">锁定读取</a>（<a href="https://dev.mysql.com/doc/refman/5.6/en/select.html" target="_blank" rel="noopener"><code>SELECT ... FOR UPDATE</code></a>或 <code>SELECT ... LOCK IN SHARE MODE</code>），请尝试使用较低的隔离级别，例如 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-transaction-isolation-levels.html#isolevel_read-committed" target="_blank" rel="noopener"><code>READ COMMITTED</code></a>。</p>
</li>
<li><p>修改事务中的多个表或同一表中的不同行集时，每次都要以一致的顺序执行这些操作。然后，事务形成定义明确的队列，并且不会死锁。例如，组织数据库操作到功能在应用程序中，或调用存储程序，而不是编码的多个相似序列 <code>INSERT</code>，<code>UPDATE</code>以及 <code>DELETE</code>在不同的地方语句。</p>
</li>
<li><p>将选择好的索引添加到表中。然后，您的查询需要扫描更少的索引记录，并因此设置更少的锁。使用<a href="https://dev.mysql.com/doc/refman/5.6/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN SELECT</code></a>以确定哪些索引MySQL认为最适合您的查询。</p>
</li>
<li><p>使用较少的锁定。如果你能负担得起，以允许 <a href="https://dev.mysql.com/doc/refman/5.6/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>从一个旧的快照返回数据，不要添加条款<code>FOR UPDATE</code>或<code>LOCK IN SHARE MODE</code>给它。在<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-transaction-isolation-levels.html#isolevel_read-committed" target="_blank" rel="noopener"><code>READ COMMITTED</code></a>这里使用隔离级别是件好事，因为同一事务中的每个一致性读取均从其自己的新快照读取。</p>
</li>
<li><p>如果没有其他帮助，请使用表级锁序列化事务。<a href="https://dev.mysql.com/doc/refman/5.6/en/lock-tables.html" target="_blank" rel="noopener"><code>LOCK TABLES</code></a>与事务表（例如<code>InnoDB</code> 表）一起使用的正确方法 是，以<code>SET autocommit = 0</code>（not <a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>START TRANSACTION</code></a>）后跟来开始事务，直到明确提交事务后才<a href="https://dev.mysql.com/doc/refman/5.6/en/lock-tables.html" target="_blank" rel="noopener"><code>LOCK TABLES</code></a>调用 <a href="https://dev.mysql.com/doc/refman/5.6/en/lock-tables.html" target="_blank" rel="noopener"><code>UNLOCK TABLES</code></a>。例如，如果您需要写表 <code>t1</code>和从表中读取数据 <code>t2</code>，则可以执行以下操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span> t1 WRITE, t2 <span class="keyword">READ</span>, ...;... <span class="keyword">do</span> something <span class="keyword">with</span> <span class="keyword">tables</span> t1 <span class="keyword">and</span> t2 here ...</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">UNLOCK</span> <span class="keyword">TABLES</span>;</span><br></pre></td></tr></table></figure>

<p>表级锁可防止对表的并发更新，从而避免死锁，但代价是对繁忙系统的响应速度较慢。</p>
</li>
<li><p>序列化事务的另一种方法是创建一个仅包含一行的辅助“ 信号量 ”表。在访问其他表之前，让每个事务更新该行。这样，所有事务都以串行方式发生。请注意，<code>InnoDB</code> 在这种情况下，即时死锁检测算法也适用，因为序列化锁是行级锁。对于MySQL表级锁，必须使用超时方法来解决死锁。</p>
</li>
</ul>
<br>



<h1 id="四、Transaction-Model-事务模型"><a href="#四、Transaction-Model-事务模型" class="headerlink" title="四、Transaction Model 事务模型"></a>四、Transaction Model 事务模型</h1><p>​    InnoDB 的事务模型 的目标是 将 <code>multi-versioning</code> 和<code>two-phase locking</code> 的最佳属性结合起来。默认情况下 InnoDB 的查询以 <u><strong>“非锁定一致性读” 和 行级锁</strong></u> 的方式运行。</p>
<h3 id="1、autocommit-commit-rollback"><a href="#1、autocommit-commit-rollback" class="headerlink" title="1、autocommit, commit, rollback"></a>1、autocommit, commit, rollback</h3><p>​    在 InnoDB 中 所有的 用户操作都包裹在事务中；如果 启用了 autocommit，那么每条语句都是一个事务；默认情况下，每创建一个session，autocommit 都是启用的；如果SQL语句正确执行，那么就会自动条，否则会滚之前的操作，然后报错；</p>
<p>在 autocommit 情况下 如果 想把多条语句包裹在一个事务里，则需要如下格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line">SELECT @A:=SUM(salary) FROM table1 WHERE type=1;</span><br><span class="line">UPDATE table2 SET summary=@A WHERE type=1;</span><br><span class="line">COMMIT;</span><br><span class="line"><span class="meta">#</span> 不想提交，则执行 ROLLBACK;</span><br></pre></td></tr></table></figure>

<p>禁用 autocommit：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET autocommit=0;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="2、存在的问题"><a href="#2、存在的问题" class="headerlink" title="2、存在的问题"></a>2、存在的问题</h3><p>​        平常开发过程中免不了对数据库的操作，并且还会有多个线程同时开启事务后对数据库进行访问，那此时不可避免就会出现多个线程之间交叉访问而导致数据的不一致，通过对数据库的隔离级别进行设置可以保证各线程数据获取的准确性。</p>
<p>在介绍隔离级别之前先要弄清楚数据库在并发事务下会出现的一些状态：</p>
<h4 id="1-、脏读"><a href="#1-、脏读" class="headerlink" title="1)、脏读"></a>1)、脏读</h4><p>脏读就是一个事务读取了另外一个事务未提交的数据。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191122164157.png" alt></p>
<p>事务2读取了事务1未提交的数据。</p>
<h4 id="2-、不可重复读"><a href="#2-、不可重复读" class="headerlink" title="2)、不可重复读"></a>2)、不可重复读</h4><p>在同一事务中，两次读取同一数据，得到内容不同</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191122164449.png" alt></p>
<p>例如事务1读取了某个数据，然后事务2更新了这个数据并提交，然后事务1又来读取了一次，那这两次读取的结果就会不一样。</p>
<h4 id="3-、幻读"><a href="#3-、幻读" class="headerlink" title="3)、幻读"></a>3)、幻读</h4><p>在一个事务的两次查询中数据记录数不一致，例如有一个事务1查询了几列数据，而事务2在此时插入了新的几列数据，事务1在接下来的查询中，就会发现有几列数据是它先前所没有的。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191122164614.png" alt></p>
<p> 不可重复读是针对于多次读取同一条数据出现不同结果，幻读是多次读取而产生的记录数不一样 </p>
<br>

<h3 id="3、隔离级别（Isolation）"><a href="#3、隔离级别（Isolation）" class="headerlink" title="3、隔离级别（Isolation）"></a>3、隔离级别（Isolation）</h3><p>​    Isolation 是 ACID 中的 I；Isolation 是在多个事务同时进行更改和执行查询时，对性能与可靠性、一致性和结果再现性之间的平衡进行微调的设定。</p>
<p>​    InnoDB 提供了 4 种隔离级别：<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-transaction-isolation-levels.html#isolevel_read-uncommitted" target="_blank" rel="noopener"><code>READ UNCOMMITTED</code></a>, <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-transaction-isolation-levels.html#isolevel_read-committed" target="_blank" rel="noopener"><code>READ COMMITTED</code></a>, <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read" target="_blank" rel="noopener"><code>REPEATABLE READ</code></a>, 和 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-transaction-isolation-levels.html#isolevel_serializable" target="_blank" rel="noopener"><code>SERIALIZABLE</code></a>。默认的 隔离级别是 REPEATABLE READ。</p>
<p>​    InnoDB 使用不同的锁策略 来实现隔离级别。<code>REPEATABLE READ</code> 用来操作重要的数据，保证 ACID；如果使用 <code>READ UNCOMMITTED</code> 或<code>READ COMMITTED</code> 可以降低锁的开销；<code>SERIALIZABLE</code>是一种比 <code>SERIALIZABLE</code>更严格的规则，一般用在专门的场景，比如 XA事务 或者 解决并发问题和死锁。</p>
<h4 id="1-、read-uncommitted"><a href="#1-、read-uncommitted" class="headerlink" title="1)、read uncommitted"></a>1)、read uncommitted</h4><p>可以看到未提交的数据（脏读），举个例子：别人说的话你都相信了，但是可能他只是说说，并不实际做。</p>
<h4 id="2-、read-committed"><a href="#2-、read-committed" class="headerlink" title="2)、read committed"></a>2)、read committed</h4><p>读取提交的数据。但是，可能多次读取的数据结果不一致（不可重复读，幻读）。用读写的观点就是：读取的行数据，可以写。</p>
<h4 id="3-、repeatable-read-默认"><a href="#3-、repeatable-read-默认" class="headerlink" title="3)、repeatable read(默认)"></a>3)、repeatable read(默认)</h4><p>可以重复读取，但有幻读。读写观点：读取的数据行不可写，但是可以往表中新增数据。在MySQL中，其他事务新增的数据，看不到，不会产生幻读。采用多版本并发控制（MVCC）机制解决幻读问题。</p>
<h4 id="4-、serializable"><a href="#4-、serializable" class="headerlink" title="4)、serializable"></a>4)、serializable</h4><p>可读，不可写。像java中的锁，写数据必须等待另一个事务结束。</p>
<br>

<h3 id="4、查看隔离级别"><a href="#4、查看隔离级别" class="headerlink" title="4、查看隔离级别"></a>4、查看隔离级别</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.查看当前会话隔离级别</span></span><br><span class="line"><span class="keyword">select</span> @@tx_isolation;</span><br><span class="line"><span class="comment">-- 查看系统当前隔离级别</span></span><br><span class="line"><span class="keyword">select</span> @@global.tx_isolation;</span><br></pre></td></tr></table></figure>

<p>设置隔离级别</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置当前会话隔离级别</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> isolatin <span class="keyword">level</span> repeatable <span class="keyword">read</span>;</span><br><span class="line"><span class="comment">-- 设置系统当前隔离级别</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> repeatable <span class="keyword">read</span>;</span><br><span class="line"><span class="keyword">set</span> tx_isolation=<span class="string">'read-uncommitted'</span>;</span><br><span class="line"><span class="keyword">set</span> tx_isolation=<span class="string">'read-committed'</span>;</span><br><span class="line"><span class="keyword">set</span> tx_isolation=<span class="string">'repeatable-read'</span>;</span><br><span class="line"><span class="keyword">set</span> tx_isolation=<span class="string">'serializable'</span>;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="五、隔离级别实现原理"><a href="#五、隔离级别实现原理" class="headerlink" title="五、隔离级别实现原理"></a>五、隔离级别实现原理</h1><h2 id="1、MVCC"><a href="#1、MVCC" class="headerlink" title="1、MVCC"></a>1、MVCC</h2><p>参考： <a href="https://www.cnblogs.com/cjsblog/p/8365921.html" target="_blank" rel="noopener">https://www.cnblogs.com/cjsblog/p/8365921.html</a> </p>
<p>　　MVCC的全称是“多版本并发控制”。这项技术使得InnoDB的事务隔离级别下执行一致性读操作有了保证，换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值。这是一个可以用来增强并发性的强大的技术，因为这样的一来的话查询就不用等待另一个事务释放锁。这项技术在数据库领域并不是普遍使用的。一些其它的数据库产品，以及mysql其它的存储引擎并不支持它。</p>
<h4 id="1-1、说明"><a href="#1-1、说明" class="headerlink" title="1.1、说明"></a>1.1、说明</h4><p>​        网上看到大量的文章讲到MVCC都是说给每一行增加两个隐藏的字段分别表示行的创建时间以及过期时间，它们存储的并不是时间，而是事务版本号。</p>
<p>​        事实上，这种说法并不准确，严格的来讲，<u><strong>InnoDB会给数据库中的每一行增加三个字段</strong></u>，它们分别是<u><strong>DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID</strong></u>。</p>
<p>​        但是，为了理解的方便，我们可以这样去理解，索引接下来的讲解中也还是用这两个字段的方式去理解。</p>
<h4 id="1-2、增删查改"><a href="#1-2、增删查改" class="headerlink" title="1.2、增删查改"></a>1.2、增删查改</h4><p>​        在InnoDB中，给每行增加两个隐藏字段来实现MVCC，一个用来记录数据行的创建时间，另一个用来记录行的过期时间（删除时间）。在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。</p>
<p>于是乎，默认的隔离级别（REPEATABLE READ）下，增删查改变成了这样：</p>
<ul>
<li>SELECT：读取创建版本小于或等于当前事务版本号，并且删除版本为空或大于当前事务版本号的记录。这样可以保证在读取之前记录是存在的。</li>
<li>INSERT：将当前事务的版本号保存至行的创建版本号</li>
<li>UPDATE：新插入一行，并以当前事务的版本号作为新行的创建版本号，同时将原记录行的删除版本号设置为当前事务版本号</li>
<li>DELETE：将当前事务的版本号保存至行的删除版本号</li>
</ul>
<h4 id="1-3、快照读和当前读"><a href="#1-3、快照读和当前读" class="headerlink" title="1.3、快照读和当前读"></a>1.3、快照读和当前读</h4><ul>
<li><p>快照读：读取的是快照版本，也就是历史版本</p>
</li>
<li><p>当前读：读取的是最新版本</p>
</li>
</ul>
<p>​        普通的SELECT就是快照读，而UPDATE、DELETE、INSERT、SELECT …  LOCK IN SHARE MODE、SELECT … FOR UPDATE是当前读。</p>
<h2 id="2、一致性非锁定读和锁定读"><a href="#2、一致性非锁定读和锁定读" class="headerlink" title="2、一致性非锁定读和锁定读"></a>2、一致性非锁定读和锁定读</h2><h4 id="2-1、锁定读"><a href="#2-1、锁定读" class="headerlink" title="2.1、锁定读"></a>2.1、锁定读</h4><p>　　在一个事务中，标准的SELECT语句是不会加锁，但是有两种情况例外。SELECT … LOCK IN SHARE MODE 和 SELECT … FOR UPDATE。</p>
<ul>
<li><p><u><strong>SELECT … LOCK IN SHARE MODE</strong></u>：给记录假设共享锁，这样一来的话，其它事务只能读不能修改，直到当前事务提交；</p>
</li>
<li><p><u><strong>SELECT … FOR UPDATE</strong></u>：给索引记录加锁，这种情况下跟UPDATE的加锁情况是一样的；</p>
</li>
</ul>
<h4 id="2-2、一致性非锁定读"><a href="#2-2、一致性非锁定读" class="headerlink" title="2.2、一致性非锁定读"></a>2.2、一致性非锁定读</h4><p>一致性读（consistent read）意味着 InnoDB 对一个 query 展示的数据是 多版本中一个时间点的 snapshot。</p>
<ul>
<li><p>如果隔离级别是REPEATABLE READ，那么在同一个事务中的所有一致性读都读的是事务中<u><strong>第一个这样的读读到的快照</strong></u>；</p>
</li>
<li><p>如果是READ COMMITTED，那么一个事务中的每一个一致性读都会读到它自己<u><strong>刷新的快照版本</strong></u>。</p>
</li>
</ul>
<p>Consistent read（一致性读）是READ COMMITTED和REPEATABLE READ隔离级别下普通SELECT语句默认的模式。一致性读不会给它所访问的表加任何形式的锁，因此其它事务可以同时并发的修改它们。</p>
<h2 id="3、悲观锁和乐观锁"><a href="#3、悲观锁和乐观锁" class="headerlink" title="3、悲观锁和乐观锁"></a>3、悲观锁和乐观锁</h2><ul>
<li><p>悲观锁，正如它的名字那样，数据库总是认为别人会去修改它所要操作的数据，因此在数据库处理过程中将数据加锁。其实现依靠数据库底层。</p>
</li>
<li><p>乐观锁，如它的名字那样，总是认为别人不会去修改，只有在提交更新的时候去检查数据的状态。通常是给数据增加一个字段来标识数据的版本。</p>
</li>
</ul>
<h2 id="4、锁"><a href="#4、锁" class="headerlink" title="4、锁"></a>4、锁</h2><p>有这样三种锁我们需要了解</p>
<ul>
<li>Record Locks（记录锁）：在<u><strong>索引记录上加锁</strong></u>。</li>
<li>Gap Locks（间隙锁）：在<u><strong>索引记录之间加锁</strong></u>，或者在第一个索引记录之前加锁，或者在最后一个索引记录之后加锁。</li>
<li>Next-Key Locks：在索引记录上加锁，并且在索引记录之前的间隙加锁。它相当于是Record Locks与Gap Locks的一个结合。</li>
</ul>
<p>假设一个索引包含以下几个值：10,11,13,20。那么这个索引的next-key锁将会覆盖以下区间：</p>
<p>(negative infinity, 10]<br>(10, 11]<br>(11, 13]<br>(13, 20]<br>(20, positive infinity)</p>
<p>了解了以上概念之后，接下来具体就简单分析下REPEATABLE READ隔离级别是如何实现的</p>
<h2 id="5、理论分析"><a href="#5、理论分析" class="headerlink" title="5、理论分析"></a>5、理论分析</h2><p>​        之所以说是理论分析，是因为要是实际操作证明的话我也不知道怎么去证明，毕竟作者水平实在有限。但是，这并不意味着我在此胡说八道，有官方文档为证。</p>
<p>​        这段话的大致意思是，在默认的隔离级别中，普通的SELECT用的是一致性读不加锁。而对于<u><strong>锁定读、UPDATE和DELETE，则需要加锁</strong></u>，至于加什么锁视情况而定。如果你对一个<code>唯一索引</code>使用了唯一的检索条件，那么只需锁定索引记录即可；如果你<code>没有使用唯一索</code>引作为检索条件，或者用到了索引范围扫描，那么将会使用间隙锁或者next-key锁以此来阻塞其它会话向这个范围内的间隙插入数据。</p>
<p>​        作者曾经有一个误区，认为按照前面说MVCC下的增删查改的行为就不会出现任何问题，也不会出现不可重复读和幻读。但其实是大错特错。</p>
<p>​        举个很简单的例子，假设事务A更新表中id=1的记录，而事务B也更新这条记录，并且B先提交，如果按照前面MVVC说的，事务A读取id=1的快照版本，那么它看不到B所提交的修改，此时如果直接更新的话就会覆盖B之前的修改，这就不对了，可能B和A修改的不是一个字段，但是这样一来，B的修改就丢失了，这是不允许的。</p>
<p>​        所以，在修改的时候一定不是快照读，而是当前读。</p>
<p>​        而且，前面也讲过只有普通的SELECT才是快照读，其它诸如UPDATE、删除都是当前读。<u><strong>修改的时候加锁这是必然的</strong></u>，同时为了防止幻读的出现还需要加间隙锁。</p>
<ul>
<li>一致性读保证了可用重复读</li>
<li><u><strong>间隙锁防止了幻读</strong></u></li>
</ul>
<p>回想一下</p>
<p>1、利用MVCC实现一致性非锁定读，这就有保证在同一个事务中多次读取相同的数据返回的结果是一样的，解决了不可重复读的问题</p>
<p>2、利用Gap Locks和Next-Key可以阻止其它事务在锁定区间内插入数据，因此解决了幻读问题</p>
<p>综上所述，默认隔离级别的实现依赖于MVCC和锁，再具体一点是一致性读和锁。</p>
<br>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/java/netty/netty-nio/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="-CarloZ">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CarloZ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/java/netty/netty-nio/" itemprop="url">Netty-4.1.3X NIO与平台相关性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-05T00:00:00+08:00">
                2018-12-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/netty/" itemprop="url" rel="index">
                    <span itemprop="name">netty</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Netty-NIO-底层实现"><a href="#Netty-NIO-底层实现" class="headerlink" title="Netty NIO 底层实现"></a>Netty NIO 底层实现</h1><p>Netty 实现了 Reactor 模型，核心是 Selector；</p>
<p>Netty 的 Selector 底层是基于 JDK 的 Selector 实现的，依赖于 操作系统的 NIO实现；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">provider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (provider != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> provider;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> PrivilegedAction&lt;SelectorProvider&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> SelectorProvider <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (loadProviderFromProperty())</span><br><span class="line">                            <span class="keyword">return</span> provider;</span><br><span class="line">                        <span class="keyword">if</span> (loadProviderAsService())</span><br><span class="line">                            <span class="keyword">return</span> provider;</span><br><span class="line">                        provider = sun.nio.ch.DefaultSelectorProvider.create();</span><br><span class="line">                        <span class="keyword">return</span> provider;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<br>

<h1 id="JDK-DefaultSelectorProvider-create"><a href="#JDK-DefaultSelectorProvider-create" class="headerlink" title="JDK DefaultSelectorProvider.create()"></a>JDK DefaultSelectorProvider.create()</h1><p>下载 openjdk-8 的源码</p>
<p>搜索 SelectorProvider 即可发现，不同的操作系统 有不同的 DefaultSelectorProvider 实现：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20190923092806.png" alt></p>
<h3 id="在mac下"><a href="#在mac下" class="headerlink" title="在mac下"></a>在mac下</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20190923093124.png" alt></p>
<p>DefaultSelectorProvider 定义 封装：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSelectorProvider</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Prevent instantiation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DefaultSelectorProvider</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the default SelectorProvider.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> sun.nio.ch.KQueueSelectorProvider();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>KQueueSelectorProvider 定义 kqueue 实现；</p>
<p>KQueueSelectorImpl 定义 kqueue 的实现逻辑；</p>
<p>KQueueArrayWrapper 真正通过 jni 调用 操作系统实现 kqueue；</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20190923093610.png" alt></p>
<h3 id="在window下"><a href="#在window下" class="headerlink" title="在window下"></a>在window下</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20190923094154.png" alt></p>
<p>可以看到NIO只有 poll</p>
<h3 id="在-solaris-下"><a href="#在-solaris-下" class="headerlink" title="在 solaris 下"></a>在 solaris 下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSelectorProvider</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the default SelectorProvider.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String osname = AccessController</span><br><span class="line">            .doPrivileged(<span class="keyword">new</span> GetPropertyAction(<span class="string">"os.name"</span>));</span><br><span class="line">        <span class="keyword">if</span> (osname.equals(<span class="string">"SunOS"</span>))</span><br><span class="line">            <span class="keyword">return</span> createProvider(<span class="string">"sun.nio.ch.DevPollSelectorProvider"</span>);</span><br><span class="line">        <span class="keyword">if</span> (osname.equals(<span class="string">"Linux"</span>))</span><br><span class="line">            <span class="keyword">return</span> createProvider(<span class="string">"sun.nio.ch.EPollSelectorProvider"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> sun.nio.ch.PollSelectorProvider();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到如果 操作系统是 SunOS 下，则调用 DevPollSelectorProvider，否则调用 EPollSelectorProvider， 如果不能确定，默认调用 PollSelectorProvider；</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20190923094418.png" alt></p>
<p>可以看到 EPoll 的实现也是 jni 调用系统实现</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20190923095240.png" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/mysql/mysql-innodb-disk-doublewrite-buffer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="-CarloZ">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CarloZ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/mysql/mysql-innodb-disk-doublewrite-buffer/" itemprop="url">mysql5.6 innodb doublewrite buffer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-03T00:00:00+08:00">
                2018-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<br>

<h1 id="一、脏页刷盘风险"><a href="#一、脏页刷盘风险" class="headerlink" title="一、脏页刷盘风险"></a>一、脏页刷盘风险</h1><p>关于IO的最小单位：</p>
<p>　　1、数据库IO的最小单位是16K（MySQL默认，oracle是8K）</p>
<p>　　2、文件系统IO的最小单位是4K（也有1K的）</p>
<p>　　3、磁盘IO的最小单位是512字节</p>
<p>因此，存在IO写入导致page损坏的风险（写入了一部分）：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191217201657.png" alt></p>
<br>

<h1 id="二、doublewrite：两次写"><a href="#二、doublewrite：两次写" class="headerlink" title="二、doublewrite：两次写"></a>二、doublewrite：两次写</h1><p>提高innodb的可靠性，用来解决部分写失败(partial page write页断裂)。</p>
<br>

<h3 id="1、doublewrite解决了什么问题"><a href="#1、doublewrite解决了什么问题" class="headerlink" title="1、doublewrite解决了什么问题"></a>1、doublewrite解决了什么问题</h3><p>　　一个数据页的大小是16K，假设在把内存中的脏页写到数据库的时候，写了2K突然掉电，也就是说前2K数据是新的，后14K是旧的，那么磁盘数据库这个数据页就是不完整的，是一个坏掉的数据页。redo只能加上旧、校检完整的数据页恢复一个脏块，不能修复坏掉的数据页，所以这个数据就丢失了，可能会造成数据不一致，所以需要double write。</p>
<br>

<h3 id="2、使用情景"><a href="#2、使用情景" class="headerlink" title="2、使用情景"></a>2、使用情景</h3><p>　　当数据库正在从内存向磁盘写一个数据页是，数据库宕机，从而导致这个页只写了部分数据，这就是部分写失效，它会导致数据丢失。这时是无法通过重做日志恢复的，因为重做日志记录的是对页的物理修改，如果页本身已经损坏，重做日志也无能为力。</p>
<br>

<h3 id="3、doublewrite工作流程"><a href="#3、doublewrite工作流程" class="headerlink" title="3、doublewrite工作流程"></a>3、doublewrite工作流程</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191217201952.png" alt></p>
<p>　　doublewrite由两部分组成，一部分为内存中的 <code>doublewrite buffer</code>，其大小为2MB，另一部分是<code>磁盘上共享表空间(ibdata x)</code>中连续的128个页，即2个区(extent)，大小也是2M。</p>
<p>　　1、当一系列机制触发数据缓冲池中的脏页刷新时，并不直接写入磁盘数据文件中，而是先拷贝至内存中的doublewrite buffer中；</p>
<p>　　2、接着从两次写缓冲区分两次写入磁盘共享表空间中(连续存储，顺序写，性能很高)，每次写1MB；</p>
<p>　　3、待第二步完成后，再将doublewrite buffer中的脏页数据写入实际的各个表空间文件(离散写)；(脏页数据固化后，即进行标记对应doublewrite数据可覆盖)</p>
<br>

<h3 id="4、doublewrite-的崩溃恢复"><a href="#4、doublewrite-的崩溃恢复" class="headerlink" title="4、doublewrite 的崩溃恢复"></a>4、doublewrite 的崩溃恢复</h3><p>　　如果操作系统在将页写入磁盘的过程中发生崩溃，在恢复过程中，innodb存储引擎可以从共享表空间的doublewrite中找到该页的一个最近的副本，将其复制到表空间文件，再应用redo log，就完成了恢复过程。</p>
<p>　　因为有副本所以也不担心表空间中数据页是否损坏。</p>
<blockquote>
<p>Q：为什么log write不需要doublewrite的支持？</p>
<p>A：因为 redo log 写入的单位就是512字节，也就是磁盘IO的最小单位，所以无所谓数据损坏。</p>
</blockquote>
<br>

<h1 id="三、doublewrite的副作用"><a href="#三、doublewrite的副作用" class="headerlink" title="三、doublewrite的副作用"></a>三、doublewrite的副作用</h1><h3 id="1、doublewrite-带来的写负载"><a href="#1、doublewrite-带来的写负载" class="headerlink" title="1、doublewrite 带来的写负载"></a>1、doublewrite 带来的写负载</h3><p>　　1、double write是一个buffer, 但其实它是开在物理文件上的一个buffer, 其实也就是file, 所以它会导致系统有更多的fsync操作, 而硬盘的fsync性能是很慢的, 所以它会降低mysql的整体性能。</p>
<p>　　2、但是，doublewrite buffer写入磁盘共享表空间这个过程是连续存储，是顺序写，性能非常高，(约占写的%10)，牺牲一点写性能来保证数据页的完整还是很有必要的。</p>
<br>

<h3 id="2、监控-doublewrite-工作负载"><a href="#2、监控-doublewrite-工作负载" class="headerlink" title="2、监控 doublewrite 工作负载"></a>2、监控 doublewrite 工作负载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> show global status like '%dblwr%';</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| Variable_name              | Value |</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| Innodb_dblwr_pages_written | 92384 |</span><br><span class="line">| Innodb_dblwr_writes        | 18862 |</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>　　关注点：Innodb_dblwr_pages_written / Innodb_dblwr_writes</p>
<p>　　开启doublewrite后，每次脏页刷新必须要先写doublewrite，而doublewrite存在于磁盘上的是两个连续的区，每个区由连续的页组成，一般情况下一个区最多有64个页，所以一次IO写入应该可以最多写64个页。</p>
<p>　　而根据以上系统Innodb_dblwr_pages_written与Innodb_dblwr_writes的比例来看，大概在3左右，远远还没到64(如果约等于64，那么说明系统的写压力非常大，有大量的脏页要往磁盘上写)，所以从这个角度也可以看出，系统写入压力并不高。</p>
<br>

<h3 id="3、关闭double-write适合的场景"><a href="#3、关闭double-write适合的场景" class="headerlink" title="3、关闭double write适合的场景"></a>3、关闭double write适合的场景</h3><p>1、海量DML</p>
<p>2、不惧怕数据损坏和丢失</p>
<p>3、系统写负载成为主要负载</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> show variables like '%double%';</span><br><span class="line">+--------------------+-------+</span><br><span class="line">| Variable_name      | Value |</span><br><span class="line">+--------------------+-------+</span><br><span class="line">| innodb_doublewrite | ON    |</span><br><span class="line">+--------------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>　　作为InnoDB的一个关键特性，doublewrite功能默认是开启的，但是在上述特殊的一些场景也可以视情况关闭，来提高数据库写性能。静态参数，配置文件修改，重启数据库。</p>
<p>4、为什么没有把double write里面的数据写到data page里面呢？</p>
<p>　　1、double write里面的数据是连续的，如果直接写到data page里面，而data page的页又是离散的，写入会很慢。</p>
<p>　　2、double write里面的数据没有办法被及时的覆盖掉，导致double write的压力很大；短时间内可能会出现double write溢出的情况。</p>
<br>

<br>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/mysql/mysql-innodb-disk-iot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="-CarloZ">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CarloZ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/mysql/mysql-innodb-disk-iot/" itemprop="url">mysql5.6 innodb 索引组织表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-03T00:00:00+08:00">
                2018-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<br>

<h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>​    B+树是应文件系统所需而产生的一种B树的变形树（文件的目录一级一级索引，只有最底层的叶子节点（文件）保存数据）非叶子节点只保存索引，不保存实际的数据，数据都保存在叶子节点中，这不就是文件系统文件的查找吗?</p>
<p>​    我们就举个文件查找的例子：有3个文件夹a、b、c， a包含b，b包含c，一个文件yang.c，a、b、c就是索引（存储在非叶子节点）， a、b、c只是要找到的yang.c的key，而实际的数据yang.c存储在叶子节点上。</p>
<p>​    所有的非叶子节点都可以看成索引部分！</p>
<br>

<h3 id="2、B-树的性质"><a href="#2、B-树的性质" class="headerlink" title="2、B+树的性质"></a>2、B+树的性质</h3><blockquote>
<p>(下面提到的都是和B树不相同的性质)</p>
</blockquote>
<p>1、非叶子节点的子树指针与关键字个数相同；<br>2、非叶子节点的子树指针p[i],指向关键字值属于[k[i],k[i+1]]的子树.(B树是开区间,也就是说B树不允许关键字重复, B+树允许重复)；<br>3、为所有叶子节点增加一个链指针；<br>4、所有关键字都在叶子节点出现(稠密索引). (且链表中的关键字恰好是有序的)；<br>5、非叶子节点相当于是叶子节点的索引(稀疏索引),叶子节点相当于是存储(关键字)数据的数据层；<br>6、更适合于文件系统；</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191220165728.png" alt></p>
<br>

<h1 id="索引组织表（IOT）"><a href="#索引组织表（IOT）" class="headerlink" title="索引组织表（IOT）"></a>索引组织表（IOT）</h1><p>​    索引组织表 (<code>index organized table, IOT</code>) 就是 <u><strong><em>数据存储在一个索引结构中的表</em></strong></u>。存储在堆中的表是无组织的 (也就是说，只要有可用的空间，数据可以放在任何地方)，IOT中的数据则按主键存储和排序。对你的应用来说，IOT表和一个“常规”表并无二致。</p>
<p>​    索引组织表的数据按主键排序手段被存储在B-树索引中，除了存储主键列值外还存储非键列的值。普通索引只存储索引列，而索引组织表则存储表的所有列的值。</p>
<pre><code>` IOT`有什么意义呢？使用堆组织表时，我们必须为表和表主键上的索引分别留出空间。而IOT不存在主键的空间开销，因为索引就是数据，数据就是索引，二者已经合二为一。但是，IOT带来的好处并不止于节约了磁盘空间的占用，更重要的是大幅度降低了I/O，减少了访问缓冲区缓存(尽管从缓冲区缓存获取数据比从硬盘读要快得多，但缓冲区缓存并不免费，而且也绝对不是廉价的。每个缓冲区缓存获取都需要缓冲区缓存的多个闩，而闩是串行化设备，会限制应用的扩展能力)</code></pre><h3 id="IOT适用的场合"><a href="#IOT适用的场合" class="headerlink" title="IOT适用的场合"></a>IOT适用的场合</h3><p> 1、完全由主键组成的表。这样的表如果采用堆组织表，则表本身完全是多余的开销，因为所有的数据全部同样也保存在索引里，此时，堆表是没用的。<br> 2、代码查找表。如果你<strong><em>只会通过一个主键来访问一个表</em></strong>，这个表就非常适合实现为IOT.<br> 3、如果你想保证数据存储在某个位置上，或者希望数据以<strong><em>某种特定的顺序物理存储</em></strong>，IOT就是一种合适的结构。</p>
<h3 id="IOT提供如下的好处"><a href="#IOT提供如下的好处" class="headerlink" title="IOT提供如下的好处"></a>IOT提供如下的好处</h3><ul>
<li>提高缓冲区缓存效率，因为给定查询在缓存中需要的块更少。</li>
<li>减少缓冲区缓存访问，这会改善可扩缩性。</li>
<li>获取数据的工作总量更少，因为获取数据更快。</li>
<li>每个查询完成的物理I/O更少，因为对于任何给定的查询，需要的块更少，而且对地址记录的一个物理 I/O 很可能可以获取所有地址（而不只是其中一个地址，但堆表实现就只是获取一个地址）。如果经常在一个主键或惟一键上使用BETWEEN 查询也是如此，因为相近的记录存在一起，查询时引入的逻辑IO和物理IO都会更少。</li>
</ul>
<h1 id="从一个简单的表开始"><a href="#从一个简单的表开始" class="headerlink" title="从一个简单的表开始"></a>从一个简单的表开始</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">    age <span class="built_in">int</span>,</span><br><span class="line">    height <span class="built_in">int</span>,</span><br><span class="line">    weight <span class="built_in">int</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">32</span>)</span><br><span class="line">)<span class="keyword">engine</span> = <span class="keyword">innoDb</span>;</span><br></pre></td></tr></table></figure>

<p>相信只要入门数据库的同学都可以理解这个语句，我们也将从这个最简单的表开始，一步步地理解MySQL的索引结构。</p>
<p>首先，我们往这个表中插入一些数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span>(<span class="keyword">id</span>,age,height,weight,<span class="keyword">name</span>)<span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="string">'小吉'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span>(<span class="keyword">id</span>,age,height,weight,<span class="keyword">name</span>)<span class="keyword">VALUES</span>(<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="string">'小尼'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span>(<span class="keyword">id</span>,age,height,weight,<span class="keyword">name</span>)<span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="string">'小泰'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span>(<span class="keyword">id</span>,age,height,weight,<span class="keyword">name</span>)<span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="string">'小美'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span>(<span class="keyword">id</span>,age,height,weight,<span class="keyword">name</span>)<span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="string">'小蔡'</span>);</span><br></pre></td></tr></table></figure>

<p>我们来查一下，看看这些数据是否已经放入表中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from user;</span><br><span class="line">+<span class="comment">----+------+--------+--------+--------+</span></span><br><span class="line">| id | age  | height | weight | name   |</span><br><span class="line">+<span class="comment">----+------+--------+--------+--------+</span></span><br><span class="line">|  1 |    4 |      3 |      1 | 小泰   |</span><br><span class="line">|  2 |    1 |      2 |      7 | 小吉   |</span><br><span class="line">|  3 |    5 |      6 |      7 | 小蔡   |</span><br><span class="line">|  4 |    1 |      5 |      2 | 小美   |</span><br><span class="line">|  5 |    2 |      1 |      8 | 小尼   |</span><br><span class="line">+<span class="comment">----+------+--------+--------+--------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>可以看到，数据已经完整地放到了我们创建的user表中。</p>
<p>但是不知道大家发现了什么没有，好像发生了一件非常诡异的事情，我们插入的数据好像乱序了…</p>
<p>MySQL好像悄悄的给我们按照id排了个序。</p>
<p><strong>为什么会出现MySQL在我们没有显式排序的情况下，默默帮我们排了序呢？它是在什么时候进行排序的？</strong></p>
<br>

<h1 id="页的引入"><a href="#页的引入" class="headerlink" title="页的引入"></a>页的引入</h1><p>​    不知道大家毕业多长时间了，作为一个刚学完操作系统不久的学渣，页的概念依旧在脑中还没有变凉。其实MySQL中也有类似页的逻辑存储单位，听我慢慢道来。</p>
<p>​    在操作系统的概念中，当我们往磁盘中取数据，假设要取出的数据的大小是1KB，但是操作系统并不会只取出这1kb的数据，而是会取出4KB的数据，因为<strong><em>操作系统的一个页表项的大小是4KB</em></strong>。那为什么我们只需要1KB的数据，但是操作系统要取出4KB的数据呢？</p>
<p>​    这就涉及到一个程序局部性的概念，大概就是“<strong>一个程序在访问了一条数据之后，在之后会有极大的可能再次访问这条数据和访问这条数据的相邻数据</strong>”，所以索性直接加载4KB的数据到内存中，下次要访问这一页的数据时，直接从内存中找，可以减少磁盘IO次数，我们知道，磁盘IO是影响程序性能主要的因素，因为磁盘IO和内存IO的速度是不可同日而语的。</p>
<p>​    或许看完上面那一大段描述，还是有些抽象，所以我们索性回到数据库层面中，重新理解页的概念。</p>
<p>​    抛开所有东西不谈，假设还是我们刚才插入的那些数据，我们现在要找id = 5的数据，依照最原始的方式，我们一定会想到的就是——<strong>遍历</strong>，没错，这也是我们刚开始学计算机的时候最常用的寻找数据的方式。那么我们就来看看，以遍历的方式，我们找到id=5的数据，需要经历几次磁盘IO。</p>
<blockquote>
<p>​        首先，我们得先从id=1的数据开始读起，然后判断是否是我们需要的数据，如果不是，就再取id=2的数据，再进行判断，循环往复。毋庸置疑，在MySQL帮我们排好序之后，我们<strong>需要经历五次磁盘IO</strong>，才能将5号数据找到并读出来。</p>
</blockquote>
<p>那么我们再来看看引入页的概念之后，我们是如何读数据的。</p>
<blockquote>
<p>​        在引入页的概念之后，MySQL会将多条数据存在一个叫“页”的数据结构中，当MySQL读取id=1的数据时，会将id=1数据所在的页整页读到内存中，然后在内存中进行遍历判断，由于内存的IO速度比磁盘高很多，所以相对于磁盘IO，几乎可以忽略不计，那么我们来看看这样读取数据我们需要经历几次磁盘IO（假设每一页可以存4条数据）。</p>
<p>​        那么我们第一次会读取id=1的数据，并且将id=1到id=4的数据全部读到内存中，这是第一次磁盘IO，第二次将读取id=5的数据到内存中，<strong>这是第二次磁盘IO。所以我们只需要经历2次磁盘IO就可以找到id=5的这条数据。</strong></p>
</blockquote>
<p>​    但其实，在MySQL的InnoDb引擎中，页的大小是16KB，是操作系统的4倍，而int类型的数据是4个字节，其它类型的数据的字节数通常也在4000字节以内，所以一页是可以存放很多很多条数据的，而<strong>MySQL的数据正是以页为基本单位组合而成的</strong>。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191220172453.png" alt></p>
<p>​    上图就是我们目前为止所理解的页的结构，他包含我们的多条数据，另外，MySQL的数据以页组成，那么它有指向下一页的指针和指向上一页的指针。</p>
<p>​    那么说到这里，其实可以回答第一个问题了，MySQL实际上就是在我们插入数据的时候，就帮我们在页中排好了序，至于为什么要排序，这里先卖个关子，接着往下看。</p>
<br>

<h3 id="排序对性能的影响"><a href="#排序对性能的影响" class="headerlink" title="排序对性能的影响"></a>排序对性能的影响</h3><p>​    上文中我们提了一个问题，<strong>为什么数据库在插入数据时要对其进行排序呢？</strong>我们按正常顺序插入数据不是也挺好的吗？</p>
<p>​    这就要涉及到一个数据库查询流程的问题了，无论如何，我们是绝对不会去平白无故地在插入数据时增加一个操作来让流程复杂化的，所以插入数据时排序一定有其目的，就是<strong>优化查询的效率</strong>。</p>
<p>​    而我们不难看出，页内部存放数据的模块，实质上就是一个链表的结构，链表的特点也就是增删快，查询慢，所以优化查询的效率是必须的。</p>
<br>

<h3 id="基于单页模式存储的查询流程"><a href="#基于单页模式存储的查询流程" class="headerlink" title="基于单页模式存储的查询流程"></a>基于单页模式存储的查询流程</h3><p>还是基于我们第一节中的那张页图来谈，我们插入了五条数据，id分别是从1-5，那么假设我要找一个表中不存在的id，假设id=-1，那么现在的查询流程就是：</p>
<blockquote>
<p>​        将id=1的这一整页数据取出，进行逐个比对，那么当我们找到id=1的这条数据时，发现这个id大于我们所需要找的哪个id，由于数据库在插入数据时，已经进行过排序了，那么在id=1的数据后面，都是id&gt;1的数据，所以我们就不需要再继续往下寻找了。</p>
</blockquote>
<p>如果在插入时没有进行排序，那毋庸置疑，我们需要再继续往下进行寻找，逐条查找直到到结尾也没有找到这条数据，才能返回不存在这条数据。</p>
<p>当然，这只是排序优化的冰山一角，接着往下看。</p>
<br>

<h3 id="上述页模式可能带来的问题"><a href="#上述页模式可能带来的问题" class="headerlink" title="上述页模式可能带来的问题"></a>上述页模式可能带来的问题</h3><p>说完了排序，下面就来分析一下我们在第一节中的那幅图，对于大数据量下有什么弊端，或者换一个说法，我们可以怎么对这个模式进行优化。</p>
<p>我们不难看出，在现阶段我们了解的页模式中，只有一个功能，就是<strong>在查询某条数据的时候直接将一整页的数据加载到内存中，以减少硬盘IO次数，从而提高性能。</strong>但是，我们也可以看到，现在的页模式内部，实际上是采用了链表的结构，前一条数据指向后一条数据，本质上还是通过数据的逐条比较来取出特定的数据。</p>
<p>那么假设，我们这一页中有一百万条数据，我们要查的数据正好在最后一个，那么我们是不是一定要从前往后找到这一条数据呢？如果是这样，我们需要查找的次数就达到了一百万次，即使是在内存中查找，这个效率也是不高的。那么<strong>有什么办法来优化这种情况下的查找效率呢？</strong></p>
<br>

<h1 id="页目录的引入"><a href="#页目录的引入" class="headerlink" title="页目录的引入"></a>页目录的引入</h1><p>​    我们可以打个比方，我们在看书的时候，如果要找到某一节，而这一节我们并不知道在哪一页，我们是不是就要从前往后，一节一节地去寻找我们需要的内容的页码呢？答案是否定的，因为在书的前面，存在目录，它会告诉你这一节在哪一页，例如，第一节在第1页、第二节在第13页。<strong>在数据库的页中，实际上也使用了这种目录的结构，这就是页目录。</strong></p>
<p>​    那么引入页目录之后，我们所理解的页结构，就变成了这样：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191220172516.png" alt></p>
<p>分析一下这张图，实际上页目录就像是我们在看书的时候书本的目录一样，目录项1就相当于第一节，目录项2就相当于第二节，而每一条数据就相当于书本的每一页，这张图就可以解释成，<strong>第一节从第一页开始，第二节从第三页开始，而实际上，每个目录项会存放自己这个目录项当中最小的id，也就是说，目录项1中会存放1，而目录项2会存放3。</strong></p>
<p>那么对比一下数据库在没有页目录时候的查找流程，假设要查找id=3的数据，在没有页目录的情况下，需要查找id=1、id=2、id=3，三次才能找到该数据，而如果有页目录之后，只需要先查看一下id=3存在于哪个目录项下，然后直接通过目录项进行数据的查找即可，如果在该目录项下没有找到这条数据，那么就可以直接确定这条数据不存在，这样就大大提升了数据库的查找效率，但是这种页目录的实现，首先就需要基于数据是在已经进行过排序的的场景下，才可以发挥其作用，所以看到这里，大家应该明白第二个问题了，为什么数据库在插入时会进行排序，<strong>这才是真正发挥排序的作用的地方。</strong></p>
<br>

<h1 id="页的扩展"><a href="#页的扩展" class="headerlink" title="页的扩展"></a>页的扩展</h1><p>在上文中，我们基本上说明白了MySQL数据库中页的概念，以及它是如何基于页来减少磁盘IO次数的，以及排序是如何优化查询的效率的。</p>
<p>那么我们现在再来思考第三个问题：在开头说页的概念的时候，我们有说过，MySQL中每一页的大小只有16KB，不会随着数据的插入而自动扩容，所以这16KB不可能存下我们所有的数据，那么必定会有多个页来存储数据，那么<strong>在多页的情况下，MySQL中又是怎么组织这些页的呢？</strong></p>
<p>针对这个问题，我们继续来画出我们现在所了解的多页的结构图：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191220172531.png" alt></p>
<p>可以看到，在数据不断变多的情况下，MySQL会再去开辟新的页来存放新的数据，而每个页都有指向下一页的指针和指向上一页的指针，将所有页组织起来（这里修改了一下数据，将每一列的数据都放到了数据区中，其中<strong>第一个空格之前的代表id</strong>），第一页中存放id为1-5的数据，第二页存放id为6-10的数据，第三页存放id为11-15的数据，需要注意的是<strong>在开辟新页的时候，我们插入的数据不一定是放在新开辟的页上，而是要进行所有页的数据比较，来决定这条插入的数据放在哪一页上，而完成数据插入之后，最终的多页结构就会像上图中画的那样。</strong></p>
<br>

<h1 id="多页模式"><a href="#多页模式" class="headerlink" title="多页模式"></a>多页模式</h1><p>​    在多页模式下，MySQL终于可以完成多数据的存储了，就是采用开辟新页的方式，将多条数据放在不同的页中，然后同样采用链表的数据结构，将每一页连接起来。那么可以思考第四个问题：<strong>多页情况下是否对查询效率有影响呢？</strong></p>
<br>

<h3 id="多页模式对于查询效率的影响"><a href="#多页模式对于查询效率的影响" class="headerlink" title="多页模式对于查询效率的影响"></a>多页模式对于查询效率的影响</h3><p>针对这个问题，既然问出来了，那么答案是肯定的，多页会对查询效率产生一定的影响，影响主要就体现在，多页其本质也是一个链表结构，只要是链表结构，查询效率一定不会高。</p>
<p>假设数据又非常多条，数据库就会开辟非常多的新页，而这些新页就会像链表一样连接在一起，当我们要在这么多页中查询某条数据时，它还是会从头节点遍历到存在我们要查找的那条数据所存在的页上，我们好不容易通过页目录优化了页中数据的查询效率，现在又出现了以页为单位的链表，这不是前功尽弃了吗？</p>
<br>

<h3 id="如何优化多页模式"><a href="#如何优化多页模式" class="headerlink" title="如何优化多页模式"></a>如何优化多页模式</h3><p>由于多页模式会影响查询的效率，那么肯定需要有一种方式来优化多页模式下的查询。相信有同学已经猜出来了，既然我们可以用页目录来优化页内的数据区，那么我们也可以采取类似的方式来优化这种多页的情况。</p>
<p>是的，页内数据区和多页模式本质上都是链表，那么的确可以采用相同的方式来对其进行优化，它就是目录页。</p>
<p>所以我们对比页内数据区，来分析如何优化多页结构。在单页时，我们<strong>采用了页目录的目录项来指向一行数据，这条数据就是存在于这个目录项中的最小数据，那么就可以通过页目录来查找所需数据。</strong></p>
<p>所以对于多页结构也可以采用这种方式，使用一个目录项来指向某一页，而这个目录项存放的就是这一页中存放的最小数据的索引值。和页目录不同的地方在于，<strong>这种目录管理的级别是页，而页目录管理的级别是行。</strong></p>
<p>那么分析到这里，我们多页模式的结构就会是下图所示的这样：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191220172648.png" alt></p>
<p>存在一个目录页来管理页目录，目录页中的数据存放的就是指向的那一页中最小的数据。</p>
<p>这里要注意的一点是：其实<strong>目录页的本质也是页，普通页中存的数据是项目数据，而目录页中存的数据是普通页的地址。</strong></p>
<p>假设我们要查找id=19的数据，那么按照以前的查找方式，我们需要从第一页开始查找，发现不存在那么再到第二页查找，一直找到第四页才能找到id=19的数据，但是如果有了目录页，就可以使用id=19与目录页中存放的数据进行比较，发现19大于任何一条数据，于是进入id=16指向的页进行查找，直接然后再通过页内的页目录行级别的数据的查找，很快就可以找到id为19的数据了。随着数据越来越多，这种结构的效率相对于普通的多页模式，优势也就越来越明显。</p>
<p><strong>回归正题，相信有对MySQL比较了解的同学已经发现了，我们画的最终的这幅图，就是MySQL中的一种索引结构——B+树。</strong></p>
<br>

<h1 id="B-树的引入"><a href="#B-树的引入" class="headerlink" title="B+树的引入"></a>B+树的引入</h1><p>B+树的特点我在《<a href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247489831&idx=1&sn=748df3b637084f4a7dcbcc1b2835ca1e&chksm=ebd6260bdca1af1df320909a069aed1a1739d5922c3ffd8f42dc30570e33084b6f0af9e4dc35&scene=21#wechat_redirect" target="_blank" rel="noopener">[从入门到入土]令人脱发的数据库底层设计</a>》已经有详细叙述过了，在这里就不重复叙述了，如果有不了解的同学可以去看这篇博客。</p>
<p>我们接着往下聊，我们将我们画的存在目录页的多页模式图宏观化，可以形成下面的这张图：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191220172748.png" alt></p>
<p>这就是我们兜兜转转由简到繁形成的一颗B+树。和常规B+树有些许不同，这是一棵MySQL意义上的B+树，MySQL的一种索引结构，其中的每个节点就可以理解为是一个页，而叶子节点也就是数据页，除了叶子节点以外的节点就是目录页。</p>
<p>这一点在图中也可以看出来，非叶子节点只存放了索引，而只有叶子节点中存放了真实的数据，这也是符合B+树的特点的。</p>
<h3 id="B-树的优势"><a href="#B-树的优势" class="headerlink" title="B+树的优势"></a>B+树的优势</h3><blockquote>
<ul>
<li>由于叶子节点上存放了所有的数据，并且有指针相连，每个叶子节点在逻辑上是相连的，所以对于范围查找比较友好。</li>
<li>B+树的所有数据都在叶子节点上，所以B+树的查询效率稳定，一般都是查询3次。</li>
<li>B+树有利于数据库的扫描。</li>
<li>B+树有利于磁盘的IO，因为他的层高基本不会因为数据扩大而增高（三层树结构大概可以存放两千万数据量。</li>
</ul>
</blockquote>
<br>

<br>

<h3 id="页的完整结构"><a href="#页的完整结构" class="headerlink" title="页的完整结构"></a>页的完整结构</h3><p>说完了页的概念和页是如何一步一步地组合称为B+树的结构之后，相信大家对于页都有了一个比较清楚的认知，所以这里就要开始说说官方概念了，基于我们上文所说的，给出一个完整的页结构，也算是对上文中自己理解页结构的一种补充。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191220172803.png" alt></p>
<p>上图为 Page 数据结构，File Header 字段用于记录 Page 的头信息，其中比较重要的是 FIL_PAGE_PREV 和 FIL_PAGE_NEXT 字段，通过这两个字段，我们可以找到该页的上一页和下一页，实际上所有页通过两个字段可以形成一条双向链表。</p>
<blockquote>
<p>Page Header 字段用于记录 Page 的状态信息。接下来的 Infimum 和 Supremum 是两个伪行记录，Infimum（下确界）记录比该页中任何主键值都要小的值，Supremum （上确界）记录比该页中任何主键值都要大的值，这个伪记录分别构成了页中记录的边界。</p>
<p>User Records 中存放的是实际的数据行记录，具体的行记录结构将在本文的第二节中详细介绍。Free Space 中存放的是空闲空间，被删除的行记录会被记录成空闲空间。Page Directory 记录着与二叉查找相关的信息。File Trailer 存储用于检测数据完整性的校验和等数据。</p>
<p>引用来源：<a href="https://www.cnblogs.com/bdsir/p/8745553.html" target="_blank" rel="noopener">https://www.cnblogs.com/bdsir/p/8745553.html</a></p>
</blockquote>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191220172831.png" alt></p>
<br>

<br>

<h1 id="基于B-树聊聊MySQL的其它知识点"><a href="#基于B-树聊聊MySQL的其它知识点" class="headerlink" title="基于B+树聊聊MySQL的其它知识点"></a>基于B+树聊聊MySQL的其它知识点</h1><p>看到这里，我们已经了解了MySQL从单条数据开始，到通过页来减少磁盘IO次数，并且在页中实现了页目录来优化页中的查询效率，然后使用多页模式来存储大量的数据，最终使用目录页来实现多页模式的查询效率并形成我们口中的索引结构——B+树。既然说到这里了，那我们就来聊聊MySQL的其他知识点。</p>
<br>

<h3 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h3><p>关于聚簇索引和非聚簇索引在<a href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247489831&idx=1&sn=748df3b637084f4a7dcbcc1b2835ca1e&chksm=ebd6260bdca1af1df320909a069aed1a1739d5922c3ffd8f42dc30570e33084b6f0af9e4dc35&scene=21#wechat_redirect" target="_blank" rel="noopener">[从入门到入土]令人脱发的数据库底层设计</a>这篇文章中已经有了详细的介绍，这里简单地说说，所谓聚簇索引，就是将索引和数据放到一起，找到索引也就找到了数据，我们刚才看到的B+树索引就是一种聚簇索引，而非聚簇索引就是将数据和索引分开，查找时需要先查找到索引，然后通过索引回表找到相应的数据。InnoDB有且只有一个聚簇索引，而MyISAM中都是非聚簇索引。</p>
<br>

<h3 id="联合索引的最左前缀匹配原则"><a href="#联合索引的最左前缀匹配原则" class="headerlink" title="联合索引的最左前缀匹配原则"></a>联合索引的最左前缀匹配原则</h3><p>在MySQL数据库中不仅可以对某一列建立索引，还可以对多列建立一个联合索引，而联合索引存在一个最左前缀匹配原则的概念，如果基于B+树来理解这个最左前缀匹配原则，相对来说就会容易很很多了。</p>
<p>首先我们基于文首的这张表建立一个联合索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_obj <span class="keyword">on</span> <span class="keyword">user</span>(age <span class="keyword">asc</span>,height <span class="keyword">asc</span>,weight <span class="keyword">asc</span>)</span><br></pre></td></tr></table></figure>

<p>我们已经了解了索引的数据结构是一颗B+树，也了解了B+树优化查询效率的其中一个因素就是对数据进行了排序，那么我们在创建idx_obj这个索引的时候，也就相当于创建了一颗B+树索引，而这个索引就是<strong>依据联合索引的成员来进行排序</strong>，这里是age,height,weight。</p>
<p>看过我之前那篇博客的同学知道，InnoDB中只要有主键被定义，那么主键列被作为一个聚簇索引，而其它索引都将被作为非聚簇索引，所以自然而然的，这个索引就会是一个非聚簇索引。</p>
<p>所以根据这些我们可以得出结论：</p>
<ul>
<li>idx_obj这个索引会根据age,height,weight进行排序</li>
<li>idx_obj这个索引是一个非聚簇索引，查询时需要回表</li>
</ul>
<p>根据这两个结论，首先需要了解的就是，如何排序？</p>
<p>单列排序很简单，比大小嘛，谁都会，但是<strong>多列排序是基于什么原则的呢（重点）？</strong></p>
<p>实际上在MySQL中，联合索引的排序有这么一个原则，从左往右依次比较大小，就拿刚才建立的索引举例子，他会先去比较age的大小，如果age的大小相同，那么比较height的大小，如果height也无法比较大小， 那么就比较weight的大小，最终对这个索引进行排序。</p>
<p>那么根据这个排序我们也可以画出一个B+树，这里就不像上文画的那么详细了，简化一下：</p>
<p>数据：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191220172938.png" alt></p>
<p>B+树：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191220172952.png" alt></p>
<p>注意：此时由于是非聚簇索引，所以叶子节点不在有数据，而是存了一个主键索引，最终会通过主键索引来回表查询数据。</p>
<p>B+树的结构有了，就可以通过这个来理解最左前缀匹配原则了。</p>
<p>我们先写一个查询语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> age=<span class="number">1</span> <span class="keyword">and</span> height = <span class="number">2</span> <span class="keyword">and</span> weight = <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>毋庸置疑，这条语句一定会走idx_obj这个索引。</p>
<p>那么我们再看一个语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> height=<span class="number">2</span> <span class="keyword">and</span> weight = <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p><strong>思考一下，这条SQL会走索引吗？</strong></p>
<p>答案是否定的，那么我们分析的方向就是，为什么这条语句不会走索引。</p>
<p>上文中我们提到了一个多列的排序原则，是从左到右进行比较然后排序的，而我们的idx_obj这个索引从左到右依次是age,height,weight，所以当我们使用height和weight来作为查询条件时，由于age的缺失，那么就无法从age来进行比较了。</p>
<p>看到这里可能有小伙伴会有疑问，那<strong>如果直接用height和weight来进行比较不可以吗？</strong>显然是不可以的，可以举个例子，<strong>我们把缺失的这一列写作一个问号，那么这条语句的查询条件就变成了?27</strong>，那么我们从这课B+树的根节点开始，根节点上有127和365，那么以height和weight来进行比较的话，走的一定是127这一边，但是如果缺失的列数字是大于3的呢？比如427，527，627，那么如果走索引来查询数据，将会丢失数据，错误查询。所以这种情况下是绝对不会走索引进行查询的。这就是最左前缀匹配原则的成因。</p>
<ol>
<li>最左前缀匹配原则，MySQL会一直向右匹配直到遇到范围查询（&gt;、&lt;、between、like）就停止匹配，比如 a=3 and b=4 and c&gt;5 and d=6,如果建立(a,b,c,d)顺序的索引，d是无法使用索引的，如果建立(a,b,d,c)的索引则都可以使用到，a、b、d的顺序可以任意调整。</li>
<li>=和in可以乱序，比如 a=1 and b=2 and c=3 建立(a,b,c)索引可以任意顺序，MySQL的查询优化器会帮你优化成索引可以识别的形式。</li>
</ol>
<p>根据我们了解的可以得出结论：</p>
<p><strong>只要无法进行排序比较大小的，就无法走联合索引。</strong></p>
<p>可以再看几个语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> age=<span class="number">1</span> <span class="keyword">and</span> height = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>这条语句是可以走idx_obj索引的，因为它可以通过比较 (12?&lt;365)。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> age=<span class="number">1</span> <span class="keyword">and</span> weight=<span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>这条语句也是可以走ind_obj索引的，因为它也可以通过比较(1?7&lt;365)，走左子树，但是实际上weight并没有用到索引，因为根据最左匹配原则，如果有两页的age都等于1，那么会去比较height，但是height在这里并不作为查询条件，所以MySQL会将这两页全都加载到内存中进行最后的weight字段的比较，进行扫描查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">where</span> age&gt;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这条语句不会走索引，但是可以走索引。这句话是什么意思呢？这条SQL很特殊，由于其存在可以比较的索引，所以它走索引也可以查询出结果，但是由于这种情况是范围查询并且是全字段查询，如果走索引，还需要进行回表，MySQL查询优化器就会认为走索引的效率比全表扫描还要低，所以MySQL会去优化它，让他直接进行全表扫描。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> WEHRE age=<span class="number">1</span> <span class="keyword">and</span> height&gt;<span class="number">2</span> <span class="keyword">and</span> weight=<span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>这条语句是可以走索引的，因为它可以通过age进行比较，但是weight不会用到索引，因为height是范围查找，与第二条语句类似，如果有两页的height都大于2，那么MySQL会将两页的数据都加载进内存，然后再来通过weight匹配正确的数据。</p>
<br>

<h3 id="为什么InnoDB只有一个聚簇索引，而不将所有索引都使用聚簇索引？"><a href="#为什么InnoDB只有一个聚簇索引，而不将所有索引都使用聚簇索引？" class="headerlink" title="为什么InnoDB只有一个聚簇索引，而不将所有索引都使用聚簇索引？"></a>为什么InnoDB只有一个聚簇索引，而不将所有索引都使用聚簇索引？</h3><p>因为聚簇索引是将索引和数据都存放在叶子节点中，如果所有的索引都用聚簇索引，则每一个索引都将保存一份数据，会造成数据的冗余，在数据量很大的情况下，这种数据冗余是很消耗资源的。</p>
<br>

<h1 id="补充两个关于索引的点"><a href="#补充两个关于索引的点" class="headerlink" title="补充两个关于索引的点"></a>补充两个关于索引的点</h1><p>这两个点也是上次写关于索引的博客时漏下的，这里补上。</p>
<p><strong>1.什么情况下会发生明明创建了索引，但是执行的时候并没有通过索引呢？</strong></p>
<p><strong>科普时间：</strong>查询优化器 一条SQL语句的查询，可以有不同的执行方案，至于最终选择哪种方案，需要通过优化器进行选择，选择执行成本最低的方案。</p>
<p>在一条单表查询语句真正执行之前，MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案。这个成本最低的方案就是所谓的执行计划。</p>
<p>优化过程大致如下：</p>
<blockquote>
<p>1、根据搜索条件，找出所有可能使用的索引<br>2、计算全表扫描的代价<br>3、计算使用不同索引执行查询的代价<br>4、对比各种执行方案的代价，找出成本最低的那一个 。</p>
</blockquote>
<blockquote>
<p>参考：<a href="https://juejin.im/post/5d23ef4ce51d45572c0600bc" target="_blank" rel="noopener">https://juejin.im/post/5d23ef4ce51d45572c0600bc</a></p>
</blockquote>
<p>根据我们刚才的那张表的非聚簇索引，这条语句就是由于查询优化器的作用，造成没有走索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">where</span> age&gt;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>2.在稀疏索引情况下通常需要通过叶子节点的指针回表查询数据，什么情况下不需要回表？</strong></p>
<p>科普时间：覆盖索引 覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。</p>
<p>当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。</p>
<p>如，表<code>covering_index_sample</code>中有一个普通索引 <code>idx_key1_key2(key1,key2)</code>。当我们通过SQL语句：<code>select key2 from covering_index_sample where key1 = &#39;keytest&#39;;</code>的时候，就可以通过覆盖索引查询，无需回表。</p>
<blockquote>
<p>参考：<a href="https://juejin.im/post/5d23ef4ce51d45572c0600bc" target="_blank" rel="noopener">https://juejin.im/post/5d23ef4ce51d45572c0600bc</a></p>
</blockquote>
<p>例如:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> age <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">where</span> age = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这句话就不需要进行回表查询。</p>
<br>

<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本篇文章着重聊了一下关于MySQL的索引结构，从零开始慢慢构建了一个B+树索引，并且根据这个过程谈了B+树是如何一步一步去优化查询效率的。</p>
<p>简单地归纳一下就是：</p>
<blockquote>
<p>排序：优化查询的根本，插入时进行排序实际上就是为了优化查询的效率。<br>页：用于减少IO次数，还可以利用程序局部性原理，来稍微提高查询效率。<br>页目录：用于规避链表的软肋，避免在查询时进行链表的扫描。<br>多页：数据量增加的情况下开辟新页来保存数据。<br>目录页：“特殊的页目录”，其中保存的数据是页的地址。查询时可以通过目录页快速定位到页，避免多页的扫描。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/message-queue/kafka/3-kafka-design-principle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="-CarloZ">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CarloZ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/message-queue/kafka/3-kafka-design-principle/" itemprop="url">3、kafka设计原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-03T00:00:00+08:00">
                2018-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mq/" itemprop="url" rel="index">
                    <span itemprop="name">mq</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mq/kafka/" itemprop="url" rel="index">
                    <span itemprop="name">kafka</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<br>

<h1 id="1、broker-端设计架构"><a href="#1、broker-端设计架构" class="headerlink" title="1、broker 端设计架构"></a>1、broker 端设计架构</h1><h3 id="1-1、消息设计"><a href="#1-1、消息设计" class="headerlink" title="1.1、消息设计"></a>1.1、消息设计</h3><br>

<h3 id="1-2、集群管理"><a href="#1-2、集群管理" class="headerlink" title="1.2、集群管理"></a>1.2、集群管理</h3><h4 id="1-2-1、成员管理"><a href="#1-2-1、成员管理" class="headerlink" title="1.2.1、成员管理"></a>1.2.1、成员管理</h4><p>kafka 的自动化服务发现 和 成员管理 靠 zookeeper 实现；</p>
<p>每当一个 broker 启动时，它会将 自己 注册到 zookeeper 的一个节点（/brokers/ids/&lt;broker.id&gt;）</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191015160328.png" alt></p>
<p>注册信息格式如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"listener_security_protocol_map"</span>:&#123;</span><br><span class="line">        <span class="attr">"PLAINTEXT"</span>:<span class="string">"PLAINTEXT"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"endpoints"</span>:[</span><br><span class="line">        <span class="string">"PLAINTEXT://172.18.1.51:9092"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"jmx_port"</span>:<span class="number">-1</span>,</span><br><span class="line">    <span class="attr">"host"</span>:<span class="string">"172.18.1.51"</span>,</span><br><span class="line">    <span class="attr">"timestamp"</span>:<span class="string">"1570677366545"</span>,</span><br><span class="line">    <span class="attr">"port"</span>:<span class="number">9092</span>,</span><br><span class="line">    <span class="attr">"version"</span>:<span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>listener_security_protocol_map： 该broker与外界通信使用的安全协议类型；</li>
<li>endpoints：指定 broker 的 endpoint 列表；endpoint可以配置多个，每种协议一个，只是端口号不能冲突；</li>
<li>rack：指定broker机架信息，若设置了机架信息，kafka 会把副本分配在多个机架上；</li>
<li>jmx_port： broker 的 JMX 监控端口；</li>
<li>host：broker 主机名或 IP 地址；</li>
<li>port：broker 服务端口号；</li>
<li>timestamp：broker 启动时间；</li>
<li>version：broker 当前版本号；不是kafka版本号，每个 broker版本，信息格式不一样；</li>
</ul>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191015163631.png" alt></p>
<p>注意 ephemeralOwner值，该值不是0，意味着 这是一个 zookeeper的临时节点；</p>
<p><u><strong>kafka 管理集群及其成员的主要流程</strong></u>：</p>
<p>1、broker启动时，在 zk 上创建对应的临时节点，同时还会创建一个 监听器（listener）监听该临时节点的状态；</p>
<p>2、一旦 broker 启动后，监听器会自动同步整个集群信息到该 broker 上；</p>
<p>3、一旦 broker 崩溃，broker 与 zk 的会话断开，该临时节点会被自动清楚掉，监听器被触发，然后处理 broker 崩溃的后续事宜。</p>
<br>

<h4 id="1-2-2、使用到的ZooKeeper-路径"><a href="#1-2-2、使用到的ZooKeeper-路径" class="headerlink" title="1.2.2、使用到的ZooKeeper 路径"></a>1.2.2、使用到的ZooKeeper 路径</h4><p>新版本的 producer 和 consumer 已经不再 需要连接 zookeeper</p>
<p>下图涵盖了 Kafka 用到的 ZooKeeper 节点：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191016112327.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191016112432.png" alt></p>
<br>

<h3 id="1-3、副本与ISR设计"><a href="#1-3、副本与ISR设计" class="headerlink" title="1.3、副本与ISR设计"></a>1.3、副本与ISR设计</h3><p>副本：partition 在其他 broker 上的备份；</p>
<p>ISR：与 leader partition 上 <u><strong>保持同步</strong></u>的副本集合；</p>
<p>问题： 如何判断 副本与leader partition是否同步？</p>
<h4 id="1-3-1、follower副本同步"><a href="#1-3-1、follower副本同步" class="headerlink" title="1.3.1、follower副本同步"></a>1.3.1、follower副本同步</h4><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191016144419.png" alt></p>
<p>一个partition的格式如上图，其中比较重要的位置信息如下：</p>
<ul>
<li>起始位移（base offset）：表示该副本当前所含第一条消息的offset；</li>
<li>高水印值（high watermark，HW）：副本高水印值。保存了 最新一条”已提交“消息的位移。超过 HW 值的所有消息都被视为 ”未提交成功的“，因此 consumer 是看不到的。注意：不只有 leader partition 有 HW 值，每个 follower 都有 HW 值，只不过只有 leader 的 HW 值 可以决定 consumer 能看到的消息数；</li>
<li>日志末端位移（log end offset，LEO）：副本日志 下一条待写入消息的 offset，所有的 副本都需要维护自己的 LEO 信息。follower 向 leader 请求到数据后 会增加自己的 LEO。事实上 <u><strong>只有所有ISR副本都更新了对应的 LEO 之后 leader 才会 向右移动对应的 HW 值，来表明 消息写入成功</strong></u>。如下图</li>
</ul>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191016145355.png" alt></p>
<h4 id="1-3-2、ISR-设计"><a href="#1-3-2、ISR-设计" class="headerlink" title="1.3.2、ISR 设计"></a>1.3.2、ISR 设计</h4><p>如何判定 ISR？</p>
<p><u><strong>1、0.9.0.0 版本之前</strong></u></p>
<ul>
<li><p>参数：replica.lag.max.messages=n，follower落后leader的消息数；</p>
</li>
<li><p>参数：replica.lag.time.max.ms=m， follower 在 m 毫秒内 无法 向 leader 请求数据；</p>
</li>
</ul>
<p><u><strong>follower 落后 leader 的可能原因</strong></u>：</p>
<ul>
<li>请求速度追不上：follower 所在的broker 的 网络 I/O开销过大，导致 获取消息速度过慢；</li>
<li>进程卡住：follower 在一段时间内 无法 向 leader 请求数据，比如频繁GC和进程bug等；</li>
<li>新创建的副本：如果用户新增了 副本数，新副本追赶 leader 进度期间 通常都是不同步的；</li>
</ul>
<p><u><strong>参数：replica.lag.max.messages 的缺陷</strong></u>：无法动态适配场景，容易导致follower 频繁的 踢出加入 ISR；</p>
<p><u><strong>2、0.9.0.0 版本之后</strong></u></p>
<p>参数：replica.lag.time.max.ms 默认值10s。用于检测由于慢和进程卡壳的滞后，即 follower 落后 leader 的 时间间隔。</p>
<p>删除了 replica.lag.max.messages 参数，这样，只要 follower 不是持续落后，就不会被反复踢出 ISR；</p>
<br>

<h3 id="1-4、水印（watermark）和-leader-epoch"><a href="#1-4、水印（watermark）和-leader-epoch" class="headerlink" title="1.4、水印（watermark）和 leader epoch"></a>1.4、水印（watermark）和 leader epoch</h3><p>摘要：</p>
<ul>
<li>watermark机制的缺陷；</li>
<li>leader epoch 解决 watermark 的缺陷；</li>
</ul>
<h4 id="1-4-1、LEO更新机制"><a href="#1-4-1、LEO更新机制" class="headerlink" title="1.4.1、LEO更新机制"></a>1.4.1、LEO更新机制</h4><p>分类：leader 的 LEO 更新机制、follower 的 LEO 更新机制；</p>
<p><u><strong>follower 的 LEO 保存位置</strong></u>：【follower 所在 broker 的缓存上】，【leader 所在broker 的缓存上】；换句话说 leader 所在broker 上保存了 该 partition 下所有 follower 的 LEO；</p>
<p><u><strong>follower 的 LEO 更新机制</strong></u>：</p>
<ul>
<li>更新【follower 所在 broker 的缓存】的 LEO，follower 发送 FETCH 请求从leader 拿到数据后，follower 开始向底层log 写数据，从而自动更新 LEO值；</li>
<li>更新【leader 所在 broker 的缓存】的 LEO，leader 收到 follower的 FETCH请求后，它首先 从自己的log 读取响应的数据，但在 给 follower 返回数据之前，它会 先去更新自己 broker上的对应follower 的 LEO值；</li>
</ul>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191016165845.png" alt></p>
<p><u><strong>leader 的 LEO 更新机制</strong></u>：和 follower 更新自己 的LEO相同，leader 在写入log 时 会自动更新自己的 LEO值；</p>
<br>

<h4 id="1-4-2、HW更新机制"><a href="#1-4-2、HW更新机制" class="headerlink" title="1.4.2、HW更新机制"></a>1.4.2、HW更新机制</h4><p><u><strong>follower 的 HW更新机制</strong></u>： follower.HW = min（follower.LEO，leader.HW）； follower 在写完log数据以后，就会尝试更新HW值；</p>
<p><u><strong>leader 的 HW更新机制</strong></u>：leader的 HW 会影响 consumer的 可见性，所以比较重要；在以下 4种情况下，会做更新HW的尝试：</p>
<ol>
<li>副本称为 leader 时：有必要检查副本的状态；</li>
<li>集群中有broker崩溃导致 它的 follower被踢出 ISR时：拖后腿的 ISR没有了，有必要检查一下；</li>
<li>producer 向 leader 写入消息时：</li>
<li>leader 处理 follower FETCH 请求时：</li>
</ol>
<p>leader.HW = min（foreach（ISR.partition.LEO），（落后时间&lt; replica.lag.time.max.ms）partition.LEO）；<u><strong>选择【 ISR】 和 【落后于leader的时长不大于 replica.lag.time.max.ms 的所有副本】的最小 LEO值 作为 HW</strong></u>;</p>
<br>

<h4 id="1-4-3、watermark备份机制的缺陷"><a href="#1-4-3、watermark备份机制的缺陷" class="headerlink" title="1.4.3、watermark备份机制的缺陷"></a>1.4.3、watermark备份机制的缺陷</h4><p>leader 的 HW更新 依赖于 下一轮的 follower FETCH才能完成，这可能引起如下问题：</p>
<ul>
<li>备份数据丢失；</li>
<li>备份数据不一致；</li>
</ul>
<p><u><strong>问题1：备份数据丢失</strong></u></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191016171706.png" alt></p>
<p>上图中有两个副本：A和B。开始状态是A是leader。我们假设producer端min.insync.replicas设置为1，那么当producer发送两条消息给A后，A写入到底层log，此时Kafka会通知producer说这两条消息写入成功。</p>
<p>但是在broker端，leader和follower底层的log虽都写入了2条消息且分区HW已经被更新到2，但follower HW尚未被更新（也就是上面紫色颜色标记的第二步尚未执行）。倘若此时副本B所在的broker宕机，那么重启回来后B会自动把LEO调整到之前的HW值，故副本B会做日志截断(log truncation)，将offset = 1的那条消息从log中删除，并调整LEO = 1，此时follower副本底层log中就只有一条消息，即offset = 0的消息。</p>
<p>B重启之后需要给A发FETCH请求，但若A所在broker机器在此时宕机，那么Kafka会令B成为新的leader，而当A重启回来后也会执行日志截断，将HW调整回1。这样，位移=1的消息就从两个副本的log中被删除，即永远地丢失了。</p>
<p>这个场景丢失数据的前提是在min.insync.replicas=1时，一旦消息被写入leader端log即被认为是“已提交”，而延迟一轮FETCH RPC更新HW值的设计使得follower HW值是异步延迟更新的，倘若在这个过程中leader发生变更，那么成为新leader的follower的HW值就有可能是过期的，使得clients端认为是成功提交的消息被删除</p>
<p><u><strong>问题2：备份数据不一致</strong></u></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191016172010.png" alt></p>
<p>这种情况的初始状态与情况1有一些不同的：A依然是leader，A的log写入了2条消息，但B的log只写入了1条消息。分区HW更新到2，但B的HW还是1，同时producer端的min.insync.replicas = 1。</p>
<p>这次我们让A和B所在机器同时挂掉，然后假设B先重启回来，因此成为leader，分区HW = 1。假设此时producer发送了第3条消息(绿色框表示)给B，于是B的log中offset = 1的消息变成了绿色框表示的消息，同时分区HW更新到2（A还没有回来，就B一个副本，故可以直接更新HW而不用理会A）之后A重启回来，需要执行日志截断，但发现此时分区HW=2而A之前的HW值也是2，故不做任何调整。此后A和B将以这种状态继续正常工作。</p>
<p>显然，这种场景下，A和B底层log中保存在offset = 1的消息是不同的记录，从而引发不一致的情形出现。</p>
<br>

<h4 id="1-4-4、leader-epoch-如何解决"><a href="#1-4-4、leader-epoch-如何解决" class="headerlink" title="1.4.4、leader epoch 如何解决"></a>1.4.4、leader epoch 如何解决</h4><p>造成上述两个问题的根本原因在于HW值被用于衡量副本备份的成功与否以及在出现failture时作为日志截断的依据，但HW值的更新是异步延迟的，特别是需要额外的FETCH请求处理流程才能更新，故这中间发生的任何崩溃都可能导致HW值的过期。鉴于这些原因，Kafka 0.11引入了leader epoch来取代HW值。Leader端多开辟一段内存区域专门保存leader的epoch信息，这样即使出现上面的两个场景也能很好地规避这些问题。</p>
<p>所谓leader epoch实际上是一对值：（epoch，offset）。epoch表示leader的版本号，从0开始，当leader变更过1次时epoch就会+1，而offset则对应于该epoch版本的leader写入第一条消息的位移。因此假设有两对值：</p>
<p>(0, 0)</p>
<p>(1, 120)</p>
<p>则表示第一个leader从位移0开始写入消息；共写了120条[0, 119]；而第二个leader版本号是1，从位移120处开始写入消息。</p>
<p><u><strong><em>leader broker中会保存这样的一个缓存，并定期地写入到一个checkpoint文件中</em></strong></u>。</p>
<p>当leader写底层log时它会尝试更新整个缓存——如果这个leader首次写消息，则会在缓存中增加一个条目；否则就不做更新。而每次副本重新成为leader时会查询这部分缓存，获取出对应leader版本的位移，这就不会发生数据不一致和丢失的情况。</p>
<p>下面我们依然使用图的方式来说明下利用leader epoch如何规避上述两种情况</p>
<p><u><strong>一、规避数据丢失</strong></u></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191016172423.png" alt></p>
<p>上图左半边已经给出了简要的流程描述，这里不详细展开具体的leader epoch实现细节（比如OffsetsForLeaderEpochRequest的实现），我们只需要知道每个副本都引入了新的状态来保存自己当leader时开始写入的第一条消息的offset以及leader版本。这样在恢复的时候完全使用这些信息而非水位来判断是否需要截断日志。</p>
<p><u><strong>二、规避数据不一致</strong></u></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191016172514.png" alt></p>
<p>同样的道理，依靠leader epoch的信息可以有效地规避数据不一致的问题。</p>
<p><u><strong>总结</strong></u></p>
<p>0.11.0.0版本的Kafka通过引入leader epoch解决了原先依赖水位表示副本进度可能造成的数据丢失/数据不一致问题。有兴趣的读者可以阅读源代码进一步地了解其中的工作原理。</p>
<p>源代码位置：kafka.server.epoch.LeaderEpochCache.scala （leader epoch数据结构）、kafka.server.checkpoints.LeaderEpochCheckpointFile（checkpoint检查点文件操作类）还有分布在Log中的CRUD操作。</p>
<br>

<br>

<h3 id="1-5、日志存储设计"><a href="#1-5、日志存储设计" class="headerlink" title="1.5、日志存储设计"></a>1.5、日志存储设计</h3><p><u><strong>1、kafka 日志</strong></u></p>
<p>kafka的日志：不同于 请求日志，kafka日志 是 一种 专门为程序访问的 日志；更像是mysql中的binlog；</p>
<p>kafka 把 消息体 和 元数据信息 打包成 一个record，以追加的方式 写入日志；</p>
<p><strong><u>kafka的日志设计</u></strong>：topic -&gt; 多个 partition（分区）-&gt; 每个partition 又可以细分为 段日志（segment log），包含 日志段文件 和 索引文件； 下图中 .log 结尾的 就是 segment log，.index 和 .timeindex 结尾的就是 对应的索引文件；</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191017110417.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191017092632.png" alt></p>
<p><u><strong>2、日志段文件</strong></u></p>
<p>parition 分区名字：topic名-分区号；</p>
<p>日志段文件：00000000000000000196.log，每个 日志段文件大小都有上限，默认大小 1GB，通过 broker参数 log.segment.bytes 控制；日志段文件被填满以后，会自动创建一组新的 日志段文件和索引文件；</p>
<p><u><strong>3、索引文件</strong></u></p>
<p>除了 .log 文件外，kafka分区日志还包括 两个特殊的文件 .index 和 .timeindex；</p>
<p>.index 是位移索引文件；kafka可以用二分查找 将整体时间复杂度 降到 O(logN);</p>
<p>.timeindex 是 时间戳索引文件；可以根据时间戳找到一定范围的记录；</p>
<p><u><strong>4、日志留存</strong></u></p>
<p>kafka 会定期清除日志，而且清除的单位是 日志段文件；即清除 .log 日志 和 对应的 两个索引文件；</p>
<p>留存策略：</p>
<ul>
<li>基于时间的留存策略：kafka会morn清除7天前的日志段数据；可以通过 broker参数 log.retention.{hours|minutes|ms}用于配置清除日志的时间间隔；</li>
<li>基于大小的留存策略：kafka 会 保存 log.retention.bytes 参数值大小 字节数 的 日志。默认值 是 -1，表示不限制大小；</li>
</ul>
<p>注意：日志清除对于当前日志段是不生效的；</p>
<p><u><strong>5、日志压实 compaction</strong></u></p>
<p>kafka可以对key相同的 日志进行和合并，只保留最新的 value；</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191018111309.png" alt></p>
<br>

<h3 id="1-6、通信协议（wire-protocol）"><a href="#1-6、通信协议（wire-protocol）" class="headerlink" title="1.6、通信协议（wire protocol）"></a>1.6、通信协议（wire protocol）</h3><br>

<h3 id="1-7、controller设计"><a href="#1-7、controller设计" class="headerlink" title="1.7、controller设计"></a>1.7、controller设计</h3><p>1、controller 架构</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191018142603.png" alt></p>
<p>2、controller 管理状态</p>
<p>controller维护的状态分类：每台 broker 上的分区副本 和 每个分区的 leader 信息；从维度上看，又分为 副本状态和分区状态；由此 引入 副本状态机 和 分区状态机</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191018142436.png" alt></p>
<p>3、controller 职责</p>
<ul>
<li>更新集群元数据信息：分区信息变更时，controller封装变更信息 发送给每个 broker；</li>
<li>创建topic：监控 zk的/brokers/topics 子节点变更，监听到新节点 触发topic创建逻辑；</li>
<li>删除topic：监听到/admin/delete_topics下的节点时，触发删除topic操作；</li>
<li>分区重分配：监听 /admin/reassign_partitions 节点下的变更；</li>
<li>prefered leader 副本选举：分区的第一顺位副本作为 leader；</li>
<li>topic 分区扩展：用户发起增加分区的操作，会在 /brokers/topics/topic_name 下写入新的分区目录；</li>
<li>broker 加入集群：新加入的broker会在 /broker/ids 下创建 新的znode并写入 broker信息，对应的监听器会感知到变更；</li>
<li>broker 崩溃：/broker/ids 下的znode小时，监听器拿到变更，执行broker退出逻辑；</li>
<li>broker 受控关闭：</li>
<li>controller leader 选举：/controller 节点 存储了当前 controller所在的brokerid，集群首次启动，都会抢着创建该节点，胜出的那个broker成为 controller，同时更新 /controller_epoch 节点的值；</li>
</ul>
<p>4、controller 与 broker 通信</p>
<p>5、controller 组件</p>
<p>6、老板本 controller 的缺陷</p>
<p>7、新版本 controller</p>
<br>

<h3 id="1-8、broker-请求处理"><a href="#1-8、broker-请求处理" class="headerlink" title="1.8、broker 请求处理"></a>1.8、broker 请求处理</h3><p><u><strong>1、Reactor模型</strong></u></p>
<p><u><strong>2、kafka的broker处理模型</strong></u></p>
<p>1),KafkaServer<br>该类代表了一个kafka Broker的生命周期，处理kafka启动或者停止所需要的所有功能。</p>
<p>2),SocketServer<br>一个NIO 服务中心。线程模型是<br>1个Acceptor线程，用来处理新的链接请求<br>N个加工Processor线程。每个线程拥有一个他们自己的selector，主要负责IO请求及应答。</p>
<p>3),KafkaRequestHandler<br>实际会在KafkaRequestHandlerPool中创建多个对象，负责加工处理request线程。<br>会1创建M个处理Handler线程。负责处理request请求，将responses重新写会加工线程Processor，以便于其写回给客户端。</p>
<p><u>一个典型的 broker 请求流程如下</u>：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191018141137.png" alt></p>
<p>（1）启动 broker</p>
<ul>
<li>启动 acceptor 线程A</li>
<li>启动 3个 process 线程 P1, P2, P3</li>
<li>创建 KafkaRequestHander 线程池 和 8个请求处理线程 H1 ~ H8</li>
</ul>
<p>（2）broker 启动后，acceptor 线程 不断轮询是否存在 客户端的 新连接；P1~P3实时轮询 是否有 acceptor新发送的 socket连接通道 以及 请求队列 和 响应队列中是否有请求需要处理；H1 ~ H8 则 实时监控 请求队列中的新请求；</p>
<p>（3）此时 client 向 broker 发送数据，首先 client 会 创建 与 该 broker 的Socket 连接；</p>
<p>（4）acceptor 线程 监听到socket连接，接收，将连接发送给 P1~P3中的一个，假设是 P2；</p>
<p>（5）P2 下一次轮询时 发现 acceptor 传送过来的新连接，将其注册到 Selector上 并开始监听其上的 入站请求；</p>
<p>（6）现在 client 开始给 broker 发送 producer请求；</p>
<p>（7）P2 监听到 有新的请求到来，故获取之，然后发送到请求队列中；</p>
<p>（8）由于 H1~H8 实时监听请求队列，故必有一个线程最早发现 producer请求并开始处理，假设是 H5，H5从请求队列中取出并开始处理；</p>
<p>（9）H5 线程请求处理完成，将响应结果放入 P2 对应的 响应队列；</p>
<p>（10）P2 监听到 它的响应队列 有 响应，将响应取出 发送给 对应的 client；</p>
<p>（11）client 接收响应，标记本次 producer 请求处理过程结束；</p>
<br>

<br>

<h1 id="2、producer-端设计架构"><a href="#2、producer-端设计架构" class="headerlink" title="2、producer 端设计架构"></a>2、producer 端设计架构</h1><h3 id="2-1、producer-端基本数据结构"><a href="#2-1、producer-端基本数据结构" class="headerlink" title="2.1、producer 端基本数据结构"></a>2.1、producer 端基本数据结构</h3><br>

<h3 id="2-2、工作流程"><a href="#2-2、工作流程" class="headerlink" title="2.2、工作流程"></a>2.2、工作流程</h3><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191018155715.png" alt></p>
<ol>
<li>用户首先构建发送的消息对象 ProducerRecord，然后调用 KafkaProducer.send 进行发送；</li>
<li>KafkaProducer 接收到消息后首先 对其进行序列化；</li>
<li>然后结合本地缓存的元数据信息一起发送给 pointer 去确定目标分区；最后追加 写入内存中的缓存池（accumulator）。此时 KafkaProducer.send 方法成功返回；</li>
<li>KafkaProducer 负责 将缓存池 中的消息 分批次 发送给对应的 broker，完成真正的 消息发送逻辑；</li>
</ol>
<br>

<br>

<h1 id="3、consumer-端设计架构"><a href="#3、consumer-端设计架构" class="headerlink" title="3、consumer 端设计架构"></a>3、consumer 端设计架构</h1><h3 id="3-1、consumer-group-状态机"><a href="#3-1、consumer-group-状态机" class="headerlink" title="3.1、consumer group 状态机"></a>3.1、consumer group 状态机</h3><br>

<h3 id="3-2、group-管理协议"><a href="#3-2、group-管理协议" class="headerlink" title="3.2、group 管理协议"></a>3.2、group 管理协议</h3><br>

<h3 id="3-3、rebalance-场景分析"><a href="#3-3、rebalance-场景分析" class="headerlink" title="3.3、rebalance 场景分析"></a>3.3、rebalance 场景分析</h3><br>

<br>

<h1 id="4、实现精确一次处理语义"><a href="#4、实现精确一次处理语义" class="headerlink" title="4、实现精确一次处理语义"></a>4、实现精确一次处理语义</h1><h3 id="4-1、消息交付语义"><a href="#4-1、消息交付语义" class="headerlink" title="4.1、消息交付语义"></a>4.1、消息交付语义</h3><ul>
<li>最多一次（at more once）：</li>
<li>最少一次（at least once）：</li>
<li>精确一次（exactly once）：</li>
</ul>
<p>KafkaProducer端默认是 at least once，可以通过幂等性 实现 exactly once；</p>
<p>KafkaConsumer 跟 位移提交时机有关系</p>
<ul>
<li>先处理后提交位移，则是 at least once；</li>
<li>先提交位移后处理消息，则是 at more once；</li>
</ul>
<br>

<h3 id="4-2、幂等性producer（idempotent-producer）"><a href="#4-2、幂等性producer（idempotent-producer）" class="headerlink" title="4.2、幂等性producer（idempotent producer）"></a>4.2、幂等性producer（idempotent producer）</h3><p>需要 打开 producer 参数 enable.idempotence = true</p>
<p>通过 producer_id，分区号，和消息序列号，实现 单个producer 的 exactly once，多个之间则不能；</p>
<br>

<h3 id="4-3、事务（transaction）"><a href="#4-3、事务（transaction）" class="headerlink" title="4.3、事务（transaction）"></a>4.3、事务（transaction）</h3><br>

<br>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/mysql/mysql-innodb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="-CarloZ">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CarloZ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/mysql/mysql-innodb/" itemprop="url">mysql5.6 innodb存储引擎</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-03T00:00:00+08:00">
                2018-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>官方文档：<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-storage-engine.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/innodb-storage-engine.html</a></p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><blockquote>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-introduction.html" target="_blank" rel="noopener">14.1 InnoDB简介</a>   </p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/mysql-acid.html" target="_blank" rel="noopener">14.2 InnoDB和ACID模型</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-multi-versioning.html" target="_blank" rel="noopener">14.3 InnoDB多版本</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-architecture.html" target="_blank" rel="noopener">14.4 InnoDB架构</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-in-memory-structures.html" target="_blank" rel="noopener">14.5 InnoDB内存结构</a>   </p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-on-disk-structures.html" target="_blank" rel="noopener">14.6 InnoDB磁盘结构</a>   </p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-locking-transaction-model.html" target="_blank" rel="noopener">14.7 InnoDB锁定和事务模型</a>   </p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-configuration.html" target="_blank" rel="noopener">14.8 InnoDB配置</a>   </p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-compression.html" target="_blank" rel="noopener">14.9 InnoDB表压缩</a>   </p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-file-format.html" target="_blank" rel="noopener">14.10 InnoDB文件格式管理</a>   </p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-row-format.html" target="_blank" rel="noopener">14.11 InnoDB行格式</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-disk-management.html" target="_blank" rel="noopener">14.12 InnoDB磁盘I / O和文件空间管理</a>   </p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-online-ddl.html" target="_blank" rel="noopener">14.13 InnoDB和在线DDL</a>   </p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html" target="_blank" rel="noopener">14.14 InnoDB启动选项和系统变量</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-information-schema.html" target="_blank" rel="noopener">14.15 InnoDB INFORMATION_SCHEMA表</a>   </p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-performance-schema.html" target="_blank" rel="noopener">14.16 InnoDB与MySQL性能架构的集成</a>   </p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-monitors.html" target="_blank" rel="noopener">14.17 InnoDB监视器</a>   </p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-backup-recovery.html" target="_blank" rel="noopener">14.18 InnoDB备份和恢复</a>   </p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-and-mysql-replication.html" target="_blank" rel="noopener">14.19 InnoDB和MySQL复制</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-memcached.html" target="_blank" rel="noopener">14.20 InnoDB memcached插件</a>   </p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-troubleshooting.html" target="_blank" rel="noopener">14.21 InnoDB故障排除</a>   </p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-limits.html" target="_blank" rel="noopener">14.22 InnoDB限制</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-restrictions-limitations.html" target="_blank" rel="noopener">14.23 InnoDB的限制和限制</a></p>
</blockquote>
<h2 id="14-1-InnoDB简介"><a href="#14-1-InnoDB简介" class="headerlink" title="14.1 InnoDB简介"></a>14.1 InnoDB简介</h2><p><code>InnoDB</code>是一种兼顾了高可靠性和高性能的通用存储引擎。在MySQL 5.6中，<code>InnoDB</code>是默认的MySQL存储引擎。除非您配置了其他默认存储引擎，否则发出<a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>不带<code>ENGINE=</code> 子句的语句将创建一个<code>InnoDB</code>表。</p>
<p><code>InnoDB</code> 包括适用于MySQL 5.1的InnoDB插件的所有功能，以及特定于MySQL 5.5及更高版本的新功能。</p>
<h3 id="InnoDB的主要优势"><a href="#InnoDB的主要优势" class="headerlink" title="InnoDB的主要优势"></a>InnoDB的主要优势</h3><ul>
<li>它的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_dml" target="_blank" rel="noopener">DML</a>操作遵循 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_acid" target="_blank" rel="noopener">ACID</a>模型，并 具有具有 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_commit" target="_blank" rel="noopener">提交</a>，<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_rollback" target="_blank" rel="noopener">回滚</a>和 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_crash_recovery" target="_blank" rel="noopener">崩溃恢复</a> 功能的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_transaction" target="_blank" rel="noopener">事务</a>， 以保护用户数据。有关更多信息<a href="https://dev.mysql.com/doc/refman/5.6/en/mysql-acid.html" target="_blank" rel="noopener">，</a>请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/mysql-acid.html" target="_blank" rel="noopener">第14.2节“ InnoDB和ACID模型”</a>。</li>
<li>行级<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_locking" target="_blank" rel="noopener">锁定</a>和Oracle风格的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_consistent_read" target="_blank" rel="noopener">一致读取可</a>提高多用户并发性和性能。有关更多信息<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-locking-transaction-model.html" target="_blank" rel="noopener">，</a>请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-locking-transaction-model.html" target="_blank" rel="noopener">第14.7节“ InnoDB锁定和事务模型”</a>。</li>
<li><code>InnoDB</code>表格将您的数据排列在磁盘上以基于<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_primary_key" target="_blank" rel="noopener">主键</a>优化查询 。每个 <code>InnoDB</code>表都有一个称为<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_clustered_index" target="_blank" rel="noopener">聚集索引</a>的主键索引，该<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_clustered_index" target="_blank" rel="noopener">索引</a> 组织数据以最小化主键查找的I / O。有关更多信息<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-index-types.html" target="_blank" rel="noopener">，</a>请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-index-types.html" target="_blank" rel="noopener">第14.6.2.1节“聚集索引和二级索引”</a>。</li>
<li>维护数据 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_referential_integrity" target="_blank" rel="noopener">完整性</a>， <code>InnoDB</code>支持 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_foreign_key" target="_blank" rel="noopener"><code>FOREIGN KEY</code></a>约束。使用外键检查插入，更新和删除操作，以确保它们不会导致不同表之间的不一致。有关更多信息<a href="https://dev.mysql.com/doc/refman/5.6/en/create-table-foreign-keys.html" target="_blank" rel="noopener">，</a>请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/create-table-foreign-keys.html" target="_blank" rel="noopener">第13.1.17.6节“外键约束”</a>。</li>
</ul>
<p><strong>表14.1 InnoDB存储引擎功能</strong></p>
<table>
<thead>
<tr>
<th>特征</th>
<th>支持</th>
</tr>
</thead>
<tbody><tr>
<td><strong>B树索引</strong></td>
<td>是</td>
</tr>
<tr>
<td><strong>备份/时间点恢复</strong>（在服务器中而不是在存储引擎中实现。）</td>
<td>是</td>
</tr>
<tr>
<td><strong>集群数据库支持</strong></td>
<td>没有</td>
</tr>
<tr>
<td><strong>聚集索引</strong></td>
<td>是</td>
</tr>
<tr>
<td><strong>压缩数据</strong></td>
<td>是</td>
</tr>
<tr>
<td><strong>资料快取</strong></td>
<td>是</td>
</tr>
<tr>
<td><strong>加密数据</strong></td>
<td>是（通过加密功能在服务器中实现；在MySQL 5.7和更高版本中，支持静态数据表空间加密。）</td>
</tr>
<tr>
<td><strong>外键支持</strong></td>
<td>是</td>
</tr>
<tr>
<td><strong>全文搜索索引</strong></td>
<td>是（MySQL 5.6和更高版本提供InnoDB对FULLTEXT索引的支持。）</td>
</tr>
<tr>
<td><strong>地理空间数据类型支持</strong></td>
<td>是</td>
</tr>
<tr>
<td><strong>地理空间索引支持</strong></td>
<td>是（MySQL 5.7和更高版本提供InnoDB对地理空间索引的支持。）</td>
</tr>
<tr>
<td><strong>哈希索引</strong></td>
<td>否（InnoDB在内部将哈希索引用于其自适应哈希索引功能。）</td>
</tr>
<tr>
<td><strong>索引缓存</strong></td>
<td>是</td>
</tr>
<tr>
<td><strong>锁定粒度</strong></td>
<td>行</td>
</tr>
<tr>
<td><strong>MVCC</strong></td>
<td>是</td>
</tr>
<tr>
<td><strong>复制支持</strong>（在服务器中而不是在存储引擎中实现。）</td>
<td>是</td>
</tr>
<tr>
<td><strong>储存限制</strong></td>
<td>64TB</td>
</tr>
<tr>
<td><strong>T树索引</strong></td>
<td>没有</td>
</tr>
<tr>
<td><strong>交易次数</strong></td>
<td>是</td>
</tr>
<tr>
<td><strong>更新数据字典的统计信息</strong></td>
<td>是</td>
</tr>
</tbody></table>
<p>要将其功能<code>InnoDB</code>与MySQL随附的其他存储引擎进行比较，请参阅<a href="https://dev.mysql.com/doc/refman/5.6/en/storage-engines.html" target="_blank" rel="noopener">第15章，</a><a href="https://dev.mysql.com/doc/refman/5.6/en/storage-engines.html" target="_blank" rel="noopener"><em>备用存储引擎中</em></a>的“ <em>存储引擎功能”</em>表 。</p>
<p><strong>Table 15.1 Storage Engines Feature Summary</strong></p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>MyISAM</th>
<th>Memory</th>
<th>InnoDB</th>
<th>Archive</th>
<th>NDB</th>
</tr>
</thead>
<tbody><tr>
<td><strong>B-tree indexes</strong></td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td><strong>Backup/point-in-time recovery</strong> (note 1)</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td><strong>Cluster database support</strong></td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td><strong>Clustered indexes</strong></td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td><strong>Compressed data</strong></td>
<td>Yes (note 2)</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><strong>Data caches</strong></td>
<td>No</td>
<td>N/A</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td><strong>Encrypted data</strong></td>
<td>Yes (note 3)</td>
<td>Yes (note 3)</td>
<td>Yes (note 4)</td>
<td>Yes (note 3)</td>
<td>Yes (note 3)</td>
</tr>
<tr>
<td><strong>Foreign key support</strong></td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>Yes (note 5)</td>
</tr>
<tr>
<td><strong>Full-text search indexes</strong></td>
<td>Yes</td>
<td>No</td>
<td>Yes (note 6)</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td><strong>Geospatial data type support</strong></td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td><strong>Geospatial indexing support</strong></td>
<td>Yes</td>
<td>No</td>
<td>Yes (note 7)</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td><strong>Hash indexes</strong></td>
<td>No</td>
<td>Yes</td>
<td>No (note 8)</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td><strong>Index caches</strong></td>
<td>Yes</td>
<td>N/A</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td><strong>Locking granularity</strong></td>
<td>Table</td>
<td>Table</td>
<td>Row</td>
<td>Row</td>
<td>Row</td>
</tr>
<tr>
<td><strong>MVCC</strong></td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td><strong>Replication support</strong> (note 1)</td>
<td>Yes</td>
<td>Limited (note 9)</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td><strong>Storage limits</strong></td>
<td>256TB</td>
<td>RAM</td>
<td>64TB</td>
<td>None</td>
<td>384EB</td>
</tr>
<tr>
<td><strong>T-tree indexes</strong></td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td><strong>Transactions</strong></td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td><strong>Update statistics for data dictionary</strong></td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody></table>
<br>

<h2 id="14-2-InnoDB和ACID模型"><a href="#14-2-InnoDB和ACID模型" class="headerlink" title="14.2 InnoDB和ACID模型"></a>14.2 InnoDB和ACID模型</h2><p>该<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_acid" target="_blank" rel="noopener">ACID</a>模式是一组数据库设计原则强调的是，对于业务数据和关键任务应用重要的可靠性方面。MySQL包含诸如<code>InnoDB</code>存储引擎严格遵循ACID模型，因此数据不会损坏，结果也不会因软件崩溃和硬件故障等异常情况而失真。当您依赖于ACID的功能时，您无需重新发明一致性检查和崩溃恢复机制。如果您有其他软件保护措施，超可靠的硬件或可以容忍少量数据丢失或不一致的应用程序，则可以调整MySQL设置以牺牲一些ACID可靠性，以获得更高的性能或吞吐量。</p>
<p>以下各节讨论MySQL功能（尤其是<code>InnoDB</code>存储引擎）如何 与ACID模型的类别进行交互：</p>
<ul>
<li><strong>答</strong>：原子性。</li>
<li><strong>C</strong>：一致性。</li>
<li><strong>我</strong>：：隔离。</li>
<li><strong>D</strong>：耐久性。</li>
</ul>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>ACID模型 的<strong>原子性</strong>方面主要涉及<code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_transaction" target="_blank" rel="noopener">事务</a>。相关的MySQL功能包括：</p>
<ul>
<li>自动提交设置。</li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a> 声明。</li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>ROLLBACK</code></a> 声明。</li>
<li><code>INFORMATION_SCHEMA</code> 表中的 操作数据。</li>
</ul>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>ACID模型 的<strong>一致性</strong>方面主要涉及内部<code>InnoDB</code>处理，以防止数据崩溃。相关的MySQL功能包括：</p>
<ul>
<li><code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_doublewrite_buffer" target="_blank" rel="noopener">doublewrite缓冲区</a>。</li>
<li><code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_crash_recovery" target="_blank" rel="noopener">崩溃恢复</a>。</li>
</ul>
<h3 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h3><p>ACID模型 的<strong>隔离</strong>方面主要涉及<code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_transaction" target="_blank" rel="noopener">事务</a>，尤其是适用于每个事务的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_isolation_level" target="_blank" rel="noopener">隔离级别</a>。相关的MySQL功能包括：</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_autocommit" target="_blank" rel="noopener">自动提交</a>设置。</li>
<li><code>SET ISOLATION LEVEL</code> 声明。</li>
<li><code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_locking" target="_blank" rel="noopener">锁定</a> 的底层细节。在性能调整期间，您可以通过<code>INFORMATION_SCHEMA</code>表格查看这些详细信息 。</li>
</ul>
<h3 id="耐用性"><a href="#耐用性" class="headerlink" title="耐用性"></a>耐用性</h3><p>ACID模型 的<strong>持久性</strong>方面涉及与特定硬件配置交互的MySQL软件功能。由于取决于您的CPU，网络和存储设备的功能的可能性很多，因此为具体的准则提供最复杂的方面。（这些准则可能采取购买“ 新硬件 ”的形式 。）相关的MySQL功能包括：</p>
<ul>
<li><code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_doublewrite_buffer" target="_blank" rel="noopener">doublewrite buffer</a>，由<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_doublewrite" target="_blank" rel="noopener"><code>innodb_doublewrite</code></a> 配置选项打开和关闭 。</li>
<li>配置选项 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_flush_log_at_trx_commit" target="_blank" rel="noopener"><code>innodb_flush_log_at_trx_commit</code></a>。</li>
<li>配置选项 <a href="https://dev.mysql.com/doc/refman/5.6/en/replication-options-binary-log.html#sysvar_sync_binlog" target="_blank" rel="noopener"><code>sync_binlog</code></a>。</li>
<li>配置选项 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a>。</li>
<li>存储设备（例如磁盘驱动器，SSD或RAID阵列）中的写缓冲区。</li>
<li>存储设备中由电池支持的缓存。</li>
<li>用来运行MySQL的操作系统，特别是它对<code>fsync()</code>系统调用的支持。</li>
<li>不间断电源（UPS）保护运行MySQL服务器并存储MySQL数据的所有计算机服务器和存储设备的电源。</li>
<li>您的备份策略，例如备份的频率和类型以及备份保留期。</li>
<li>对于分布式或托管数据应用程序，MySQL服务器的硬件所在的数据中心的特定特性，以及数据中心之间的网络连接。</li>
</ul>
<br>

<h2 id="14-3-InnoDB-MVCC"><a href="#14-3-InnoDB-MVCC" class="headerlink" title="14.3 InnoDB MVCC"></a>14.3 InnoDB MVCC</h2><p><code>InnoDB</code>是一个 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_mvcc" target="_blank" rel="noopener">多版本的存储引擎</a>：它保留有关已更改行的旧版本的信息，以支持诸如并发和<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_rollback" target="_blank" rel="noopener">回滚之</a>类的事务功能 。此信息存储在表空间中的数据结构中，该数据结构称为 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_rollback_segment" target="_blank" rel="noopener">回滚段</a>（在Oracle中类似的数据结构之后）。<code>InnoDB</code> 使用回滚段中的信息来执行事务回滚中所需的撤消操作。它还使用该信息来构建行的早期版本，以实现 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_consistent_read" target="_blank" rel="noopener">一致的读取</a>。</p>
<p>在内部，<code>InnoDB</code>向数据库中存储的每一行添加三个字段。6个字节的<code>DB_TRX_ID</code>字段表示插入或更新该行的最后一个事务的事务标识符。同样，删除在内部被视为更新，在该更新中，行中的特殊位被设置为将其标记为已删除。每行还包含一个7字节的 <code>DB_ROLL_PTR</code>字段，称为滚动指针。回滚指针指向写入回滚段的Undo Log记录。如果行已更新，则Undo Log记录将包含在更新行之前重建行内容所必需的信息。一个6字节的<code>DB_ROW_ID</code>字段包含一个行ID，该行ID随着插入新行而单调增加。如果 <code>InnoDB</code>自动生成聚集索引，该索引包含行ID值。否则，该 <code>DB_ROW_ID</code>列不会出现在任何索引中。</p>
<p>回滚段中的Undo Log分为插入和更新Undo Log。插入Undo Log仅在事务回滚时才需要，并且在事务提交后可以立即将其丢弃。更新Undo Log也用于一致的读取中，但是只有在不存在为其<code>InnoDB</code>分配了快照的事务（ 一致的读取可能需要更新Undo Log中的信息来构建数据库的早期版本）后，才可以将其删除行。</p>
<p>定期提交您的事务，包括仅发出一致读取的事务。否则， <code>InnoDB</code>将无法丢弃更新Undo Log中的数据，并且回滚段可能会变得太大而填满表空间。</p>
<p>回滚段中的Undo Log记录的物理大小通常小于相应的插入或更新的行。您可以使用此信息来计算回滚段所需的空间。</p>
<p>在<code>InnoDB</code>多版本方案中，当您使用SQL语句删除行时，并不会立即将其从数据库中物理删除。<code>InnoDB</code>仅在丢弃为删除而编写的更新Undo Log记录时，才物理删除相应的行及其索引记录。此删除操作称为<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_purge" target="_blank" rel="noopener">purge</a>，它非常快，通常花费与执行删除操作的SQL语句相同的时间顺序。</p>
<p>如果您以大约相同的速率在表中以较小的批次插入和删除行，则由于所有“ 死 ”行，清除线程可能开始滞后并且表可能会变得越来越大 ，从而使所有内容都受磁盘约束慢。在这种情况下，请限制新行的操作，并通过调整<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_max_purge_lag" target="_blank" rel="noopener"><code>innodb_max_purge_lag</code></a>系统变量来向清除线程分配更多资源 。有关更多信息<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html" target="_blank" rel="noopener">，</a>请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html" target="_blank" rel="noopener">第14.14节“ InnoDB启动选项和系统变量”</a>。</p>
<h3 id="多版本索引和二级索引"><a href="#多版本索引和二级索引" class="headerlink" title="多版本索引和二级索引"></a>多版本索引和二级索引</h3><p><code>InnoDB</code>多版本并发控制（MVCC）对二级索引的处理方式不同于聚簇索引。聚簇索引中的记录将就地更新，其隐藏的系统列指向<code>Undo Log</code>条目，可以从中重建记录的早期版本。与聚簇索引记录不同，辅助索引记录不包含隐藏的系统列，也不会就地更新。</p>
<p>更新二级索引列时，将对旧的二级索引记录进行删除标记，插入新记录，并最终清除带有删除标记的记录。当二级索引记录被删除标记或二级索引页被较新的事务更新时，<code>InnoDB</code>在聚集索引中查找数据库记录。在聚集索引中，<code>DB_TRX_ID</code>检查记录的记录，如果在启动读取事务后修改了记录，则从<code>Undo Log</code>中检索记录的正确版本。</p>
<p>如果二级索引记录被标记为删除或二级索引页被更新的事务更新， 则不使用<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_covering_index" target="_blank" rel="noopener">覆盖索引</a>技术。而不是从索引结构中返回值，而是<code>InnoDB</code>在聚集索引中查找记录。</p>
<p>但是，如果启用了 <a href="https://dev.mysql.com/doc/refman/5.6/en/index-condition-pushdown-optimization.html" target="_blank" rel="noopener">索引条件下推（ICP）</a>优化，并且<code>WHERE</code>只能使用索引中的字段来评估部分条件，则MySQL服务器仍会将<code>WHERE</code>条件的这一部分下推到存储引擎，并使用指数。如果找不到匹配的记录，则避免聚集索引查找。如果找到了匹配的记录，即使在删除标记的记录中，也要在 <code>InnoDB</code>聚簇索引中查找记录。</p>
<br>

<h2 id="14-4-InnoDB架构"><a href="#14-4-InnoDB架构" class="headerlink" title="14.4 InnoDB架构"></a>14.4 InnoDB架构</h2><p>下图显示了构成<code>InnoDB</code>存储引擎体系结构的内存中和磁盘上的结构。有关每种结构的信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-in-memory-structures.html" target="_blank" rel="noopener">第14.5节“ InnoDB内存结构”</a>和 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-on-disk-structures.html" target="_blank" rel="noopener">第14.6节“ InnoDB磁盘结构”</a>。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191122160128.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191122161052.png" alt></p>
<p><strong>图14.1 InnoDB架构</strong></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191203113218.png" alt></p>
<br>

<h2 id="14-5-InnoDB内存结构"><a href="#14-5-InnoDB内存结构" class="headerlink" title="14.5 InnoDB内存结构"></a>14.5 InnoDB内存结构</h2><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-buffer-pool.html" target="_blank" rel="noopener">14.5.1缓冲池</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-change-buffer.html" target="_blank" rel="noopener">14.5.2Change Buffer</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-adaptive-hash.html" target="_blank" rel="noopener">14.5.3自适应哈希索引</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-redo-log-buffer.html" target="_blank" rel="noopener">14.5.4日志缓冲区</a></li>
</ul>
<h3 id="14-5-1-Buffer-Pool"><a href="#14-5-1-Buffer-Pool" class="headerlink" title="14.5.1 Buffer Pool"></a>14.5.1 Buffer Pool</h3><p>Buffer Pool是主内存中的一个区域，在<code>InnoDB</code>访问表和索引数据时会在其中进行 缓存。Buffer Pool允许直接从内存中直接处理经常使用的数据，从而加快了处理速度。在专用服务器上，通常将多达80％的物理内存分配给缓冲池。</p>
<p>为了提高大容量读取操作的效率，Buffer Pool被分为多个<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_page" target="_blank" rel="noopener">页面</a>，这些<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_page" target="_blank" rel="noopener">页面</a>可能包含多个行。为了提高缓存管理的效率，Buffer Pool被实现为页面的链接列表。使用<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_lru" target="_blank" rel="noopener">LRU</a>算法的变体将很少使用的数据从缓存中老化掉 。</p>
<p>知道如何利用缓冲池将经常访问的数据保留在内存中是MySQL优化的重要方面。</p>
<h4 id="缓冲池LRU算法"><a href="#缓冲池LRU算法" class="headerlink" title="缓冲池LRU算法"></a>缓冲池LRU算法</h4><p>使用最近最少使用（LRU）算法的变体，将缓冲池作为列表进行管理。当需要空间以将新页面添加到缓冲池时，将驱逐最近使用最少的页面，并将新页面添加到列表的中间。此中点插入策略将列表视为两个子列表：</p>
<ul>
<li>最前面是最近访问过的新页面（“ 年轻 ”） 的子列表</li>
<li>在末尾，是最近访问的旧页面的子列表</li>
</ul>
<p><strong>图14.2缓冲池列表</strong></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191203141337.png" alt></p>
<p>该算法将大量页面保留在新的子列表中。旧的子列表包含较少使用的页面。这些页面是<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_eviction" target="_blank" rel="noopener">驱逐的</a>候选对象 。</p>
<p>默认情况下，该算法的运行方式如下：</p>
<ul>
<li>3/8的缓冲池专用于旧的子列表。</li>
<li>列表的中点是新子列表的尾部与旧子列表的头相交的边界。</li>
<li>当<code>InnoDB</code>将页面读入缓冲池时，它首先将其插入中点（旧子列表的头部）。可以读取页面，因为它是用户启动的操作（例如SQL查询）所必需的，或作为的自动执行的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_read_ahead" target="_blank" rel="noopener">预读</a>操作的一部分 <code>InnoDB</code>。</li>
<li>访问旧子列表中的页面 使其变为“ 年轻 ”，将其移至新子列表的头部。如果由于用户启动的操作而需要读取页面，则将立即进行首次访问，并使页面年轻。如果由于预读操作而读取了该页面，则第一次访问不会立即发生，并且在退出该页面之前可能根本不会发生。</li>
<li>随着数据库的运行，通过移至列表的尾部，缓冲池中未被访问的页面将“ 老化 ”。新的和旧的子列表中的页面都会随着其他页面的更新而老化。随着将页面插入中点，旧子列表中的页面也会老化。最终，未使用的页面到达旧子列表的尾部并被逐出。</li>
</ul>
<p>默认情况下，查询读取的页面会立即移入新的子列表，这意味着它们在缓冲池中的停留时间更长。例如，针对<a href="https://dev.mysql.com/doc/refman/5.6/en/mysqldump.html" target="_blank" rel="noopener"><strong>mysqldump</strong></a>操作或<code>SELECT</code>不带<code>WHERE</code>子句的 语句 执行的表扫描可以将大量数据带入缓冲池，并驱逐同等数量的旧数据，即使不再使用新数据也是如此。同样，由预读后台线程加载且仅访问一次的页面将移到新列表的开头。这些情况可能会将常用页面推送到旧的子列表，在此它们会被逐出。有关优化此行为的信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-performance-midpoint_insertion.html" target="_blank" rel="noopener">第14.8.3.2节“使缓冲池扫描具有抵抗力”</a>和 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-performance-read_ahead.html" target="_blank" rel="noopener">第14.8.3.3节“配置InnoDB缓冲池预取（预读）”</a>。</p>
<p><code>InnoDB</code>标准监视器输出在<code>BUFFER POOL AND MEMORY</code>有关缓冲池LRU算法操作的部分中包含几个字段。有关详细信息，请参阅<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-buffer-pool.html#innodb-buffer-pool-monitoring" target="_blank" rel="noopener">使用InnoDB Standard Monitor监视缓冲池</a>。</p>
<h4 id="缓冲池配置"><a href="#缓冲池配置" class="headerlink" title="缓冲池配置"></a>缓冲池配置</h4><blockquote>
<p>那么innodb-buffer-pool-size的大小应该设置为什么呢？下面我们就开始谈到这个。</p>
<p><strong>独立服务器</strong></p>
<p>在一个独立的只使用InnoDB引擎的MySQL服务器中，根据经验，推荐设置innodb-buffer-pool-size为服务器总可用内存的80%。<br>为什么不是90%或者100%呢？因为其它的东西也需要内存：</p>
<ul>
<li>每个查询至少需要几K的内存(有时候是几M)</li>
<li>有各种其它内部的MySQL结构和缓存</li>
<li>InnoDB有一些结构是不用缓冲池的内存的(字典缓存，文件系统，锁系统和页哈希表等)</li>
<li>也有一些MySQL文件是在OS缓存里的(binary日志，relay日志,innodb事务日志等)</li>
<li>此处，你也必须为操作系统留出些内存</li>
</ul>
<p><strong>共享服务器</strong></p>
<p>如果你的MySQL服务器与其它应用共享资源，那么上面80%的经验就不那么适用了。<br>在这样的环境下，设置一个对的数字有点难度。<br>首先让我们来统计一下InnoDB表的实际占用大小。执行如下查询：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT engine,</span><br><span class="line">&gt;   count(*) as TABLES,</span><br><span class="line">&gt;   concat(round(sum(table_rows)/1000000,2),'M') rows,</span><br><span class="line">&gt;   concat(round(sum(data_length)/(1024*1024*1024),2),'G') DATA,</span><br><span class="line">&gt;   concat(round(sum(index_length)/(1024*1024*1024),2),'G') idx,</span><br><span class="line">&gt;   concat(round(sum(data_length+index_length)/(1024*1024*1024),2),'G') total_size,</span><br><span class="line">&gt;   round(sum(index_length)/sum(data_length),2) idxfrac</span><br><span class="line">&gt; FROM information_schema.TABLES</span><br><span class="line">&gt; WHERE table_schema not in ('mysql', 'performance_schema', 'information_schema')</span><br><span class="line">&gt; GROUP BY engine</span><br><span class="line">&gt; ORDER BY sum(data_length+index_length) DESC LIMIT 10;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>这会给出一个参考，让你知道如果你想缓存整个数据集应该为InnoDB缓冲池设置多少内存合适。<br>不过大多数情况你不需要那样做，你只需要缓存你经常使用的数据集。<br>设置好之后，我们来看看如何检查InnoDB缓冲池大小是否设置足够。<br>在终端中，执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> $ mysqladmin ext -ri1 | grep Innodb_buffer_pool_reads</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> | Innodb_buffer_pool_reads                 | 1832098003     |</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> | Innodb_buffer_pool_reads                 | 595            |</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> | Innodb_buffer_pool_reads                 | 915            |</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> | Innodb_buffer_pool_reads                 | 734            |</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> | Innodb_buffer_pool_reads                 | 622            |</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> | Innodb_buffer_pool_reads                 | 710            |</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> | Innodb_buffer_pool_reads                 | 664            |</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> | Innodb_buffer_pool_reads                 | 987            |</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> | Innodb_buffer_pool_reads                 | 1287           |</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> | Innodb_buffer_pool_reads                 | 967            |</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> | Innodb_buffer_pool_reads                 | 1181           |</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> | Innodb_buffer_pool_reads                 | 949            |</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>你所看到的是从硬盘读取数据到缓冲池的次数(每秒)。上面的数据已经相当高了(幸运的是，这个服务器的IO设备能处理每秒4000的IO操作)，如果这个是OLTP系统，我建议提高innodb缓冲池的大小和如果必要增加服务器内存。</p>
<p><strong>更改InnoDB缓冲池</strong></p>
<p>最后，介绍如何更改innodb-buffer-pool-size。<br>如果你运行的是MySQL 5.7，那么非常幸运，你可以在线更改这个变量，只需要以root身份执行如下查询：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; mysql&gt; SET GLOBAL innodb_buffer_pool_size=size_in_bytes;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>这还没完，你仍然需要更改my.cnf文件，不过至少你不需要重启服务器让它生效。从mysql的错误日志中我们可以看到它生效的过程：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> [Note] InnoDB: Resizing buffer pool from 134217728 to 21474836480. (unit=134217728)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> [Note] InnoDB: disabled adaptive <span class="built_in">hash</span> index.</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> [Note] InnoDB: buffer pool 0 : 159 chunks (1302369 blocks) were added.</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> [Note] InnoDB: buffer pool 0 : <span class="built_in">hash</span> tables were resized.</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> [Note] InnoDB: Resized <span class="built_in">hash</span> tables at lock_sys, adaptive <span class="built_in">hash</span> index, dictionary.</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> [Note] InnoDB: Completed to resize buffer pool from 134217728 to 21474836480.</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> [Note] InnoDB: Re-enabled adaptive <span class="built_in">hash</span> index.</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>在更早的mysql版本就需要重启了，所以：</p>
<ol>
<li>在my.cnf中设置一个innodb_buffer_pool_size合适的值</li>
<li>重启mysql服务器</li>
</ol>
</blockquote>
<p>您可以配置缓冲池的各个方面以提高性能。</p>
<ul>
<li>理想情况下，您可以将Buffer Pool的大小设置为与实际一样大的值，从而为服务器上的其他进程留出足够的内存以运行而不会进行过多的分页。缓冲池越大，就越<code>InnoDB</code>像内存数据库一样，从磁盘读取一次数据，然后在后续读取期间从内存访问数据。使用<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_buffer_pool_size" target="_blank" rel="noopener"><code>innodb_buffer_pool_size</code></a> 配置选项配置缓冲池大小 。</li>
<li>在具有足够内存的64位系统上，可以将缓冲池分成多个部分，以最大程度地减少并发操作之间的内存结构争用。有关详细信息，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-multiple-buffer-pools.html" target="_blank" rel="noopener">第14.8.3.1节“配置多个缓冲池实例”</a>。</li>
<li>您可以将频繁访问的数据保留在内存中，而不必考虑操作突然导致的活动高峰，这些操作会将大量不经常访问的数据带入缓冲池。有关详细信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-performance-midpoint_insertion.html" target="_blank" rel="noopener">第14.8.3.2节“使缓冲池扫描具有抵抗力”</a>。</li>
<li>您可以控制何时以及如何执行预读请求，以异步方式将页面预取到缓冲池中，从而预期很快将需要这些页面。有关详细信息，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-performance-read_ahead.html" target="_blank" rel="noopener">第14.8.3.3节“配置InnoDB缓冲池预取（预读）”</a>。</li>
<li>您可以控制何时进行后台冲洗，以及是否根据工作负荷动态调整冲洗速率。有关详细信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-buffer-pool-flushing.html" target="_blank" rel="noopener">第14.8.3.4节“配置缓冲池刷新”</a>。</li>
<li>您可以配置如何<code>InnoDB</code>保留当前缓冲池状态，以免在服务器重新启动后进行冗长的预热。有关详细信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-preload-buffer-pool.html" target="_blank" rel="noopener">第14.8.3.5节“保存和恢复缓冲池状态”</a>。</li>
</ul>
<h4 id="使用InnoDB标准监视器监视缓冲池"><a href="#使用InnoDB标准监视器监视缓冲池" class="headerlink" title="使用InnoDB标准监视器监视缓冲池"></a>使用InnoDB标准监视器监视缓冲池</h4><p><code>InnoDB</code>可以使用访问的标准监视器输出， <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-standard-monitor.html" target="_blank" rel="noopener"><code>SHOW ENGINE INNODB STATUS</code></a>提供有关缓冲池操作的度量。缓冲池度量标准位于<code>BUFFER POOL AND MEMORY</code>“ <code>InnoDB</code>标准监视器”输出中的部分，其 外观类似于以下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total memory allocated 2197815296; in additional pool allocated 0</span><br><span class="line">Dictionary memory allocated 155455</span><br><span class="line">Buffer pool size   131071</span><br><span class="line">Free buffers       92158</span><br><span class="line">Database pages     38770</span><br><span class="line">Old database pages 14271</span><br><span class="line">Modified db pages  619</span><br><span class="line">Pending reads 0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 4, not young 0</span><br><span class="line">0.00 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 322, created 38448, written 42083</span><br><span class="line">0.00 reads/s, 222.30 creates/s, 159.47 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead</span><br><span class="line">0.00/s</span><br><span class="line">LRU len: 38770, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br></pre></td></tr></table></figure>

<p>下表描述了<code>InnoDB</code>标准监视器报告的缓冲池度量 标准。</p>
<blockquote>
<p>注意</p>
<p><code>InnoDB</code> 标准监视器输出中 提供的每秒平均值基于自<code>InnoDB</code>上次打印标准监视器输出以来经过的时间 。</p>
</blockquote>
<p><strong>表14.2 InnoDB缓冲池指标</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>分配的总内存</td>
<td>为缓冲池分配的总内存（以字节为单位）。</td>
</tr>
<tr>
<td>分配了额外的池</td>
<td>为附加池分配的总内存（以字节为单位）。</td>
</tr>
<tr>
<td>分配的字典内存</td>
<td>为<code>InnoDB</code>数据字典分配的总内存，以字节为单位。</td>
</tr>
<tr>
<td>缓冲池大小</td>
<td>分配给缓冲池的页面总大小（以页为单位）。</td>
</tr>
<tr>
<td>可用缓冲区</td>
<td>缓冲池空闲列表的页面总大小。</td>
</tr>
<tr>
<td>数据库页面</td>
<td>缓冲池LRU列表的页面总大小。</td>
</tr>
<tr>
<td>旧数据库页面</td>
<td>缓冲池旧LRU子列表的页面总大小。</td>
</tr>
<tr>
<td>修改的数据库页面</td>
<td>缓冲池中当前修改的页面数。</td>
</tr>
<tr>
<td>待读</td>
<td>等待读入缓冲池的缓冲池页面数。</td>
</tr>
<tr>
<td>待写LRU</td>
<td>从LRU列表的底部开始写入的缓冲池中的旧脏页数。</td>
</tr>
<tr>
<td>等待写入刷新列表</td>
<td>检查点期间要刷新的缓冲池页面数。</td>
</tr>
<tr>
<td>待写单页</td>
<td>缓冲池中暂挂的独立页面写入数。</td>
</tr>
<tr>
<td>使页面年轻化</td>
<td>缓冲池LRU列表中变年轻的页面总数（已移至“ new ”页面的子列表的开头）。</td>
</tr>
<tr>
<td>页面不年轻</td>
<td>缓冲池LRU列表中未设置为年轻的页面总数（保留在“ old ”子列表中但未设置为年轻的页面）。</td>
</tr>
<tr>
<td>青少年</td>
<td>每秒平均访问缓冲池LRU列表中的旧页面所导致的页面年轻。有关更多信息，请参见此表后面的注释。</td>
</tr>
<tr>
<td>非年轻</td>
<td>每秒平均访问缓冲池LRU列表中的旧页面导致的页面不年轻。有关更多信息，请参见此表后面的注释。</td>
</tr>
<tr>
<td>阅读页面</td>
<td>从缓冲池读取的页面总数。</td>
</tr>
<tr>
<td>创建页面</td>
<td>在缓冲池中创建的页面总数。</td>
</tr>
<tr>
<td>写的页面</td>
<td>从缓冲池写入的页面总数。</td>
</tr>
<tr>
<td>读/秒</td>
<td>每秒平均每秒读取的缓冲池页面数。</td>
</tr>
<tr>
<td>创建/秒</td>
<td>每秒平均创建的缓冲池页面的每秒数量。</td>
</tr>
<tr>
<td>写/秒</td>
<td>每秒平均缓冲池页面写入数。</td>
</tr>
<tr>
<td>缓冲池命中率</td>
<td>从缓冲池内存与磁盘存储读取的页面的缓冲池页面命中率。</td>
</tr>
<tr>
<td>年青率</td>
<td>页面访问的平均命中率使页面更年轻。有关更多信息，请参见此表后面的注释。</td>
</tr>
<tr>
<td>不（成年率）</td>
<td>页面访问未使页面变年轻的平均命中率。有关更多信息，请参见此表后面的注释。</td>
</tr>
<tr>
<td>预读页面</td>
<td>预读操作的每秒平均数。</td>
</tr>
<tr>
<td>被逐出的页面无权访问</td>
<td>每秒从缓冲池访问而未访问的页面的平均值。</td>
</tr>
<tr>
<td>随机预读</td>
<td>随机预读操作的每秒平均数。</td>
</tr>
<tr>
<td>伦</td>
<td>缓冲池LRU列表的页面总大小。</td>
</tr>
<tr>
<td>unzip_LRU len</td>
<td>缓冲池unzip_LRU列表的页面总大小。</td>
</tr>
<tr>
<td>I / O总和</td>
<td>最近50秒内访问的缓冲池LRU列表页面的总数。</td>
</tr>
<tr>
<td>I / O电流</td>
<td>已访问的缓冲池LRU列表页面的总数。</td>
</tr>
<tr>
<td>I / O解压缩总和</td>
<td>已访问的缓冲池unzip_LRU列表页面的总数。</td>
</tr>
<tr>
<td>I / O解压缩</td>
<td>已访问的缓冲池unzip_LRU列表页面的总数。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>注意事项</strong>：</p>
<ul>
<li>该<code>youngs/s</code>指标仅适用于旧页面。它基于对页面的访问次数，而不是页面数。可以对给定页面进行多次访问，所有访问都计入在内。如果<code>youngs/s</code>在不进行大扫描时看到非常低的 值，则可能需要减少延迟时间或增加用于旧子列表的缓冲池的百分比。增加百分比会使旧的子列表变大，因此该子列表中的页面需要更长的时间才能移到尾部，这增加了再次访问这些页面并使它们变年轻的可能性。</li>
<li>该<code>non-youngs/s</code>指标仅适用于旧页面。它基于对页面的访问次数，而不是页面数。可以对给定页面进行多次访问，所有访问都计入在内。如果<code>non-youngs/s</code>执行大型表扫描时看不到较高的值（较高的<code>youngs/s</code> 值），请增加延迟值。</li>
<li>该<code>young-making</code>比率说明了对所有缓冲池页面的访问，而不仅仅是访问了旧子列表中的页面。该<code>young-making</code>速率和 <code>not</code>速率通常不会加总到整个缓冲池的命中率。旧子列表中的页面命中会导致页面移动到新子列表，但是新子列表中的页面命中只会导致页面与列表的头部保持一定距离时才移动到列表的头部。</li>
<li><code>not (young-making rate)</code>是由于<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_old_blocks_time" target="_blank" rel="noopener"><code>innodb_old_blocks_time</code></a>未满足所定义的延迟，或者由于新子列表中的页面点击未导致页面移动到头部而导致页面访问未使页面变年轻的平均点击率 。此速率说明了对所有缓冲池页面的访问，而不仅仅是访问旧子列表中的页面。</li>
</ul>
<p>缓冲池<a href="https://dev.mysql.com/doc/refman/5.6/en/server-status-variables.html" target="_blank" rel="noopener">服务器状态变量</a>和 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-buffer-pool-stats-table.html" target="_blank" rel="noopener"><code>INNODB_BUFFER_POOL_STATS</code></a>表提供了许多与<code>InnoDB</code>标准监视器输出中相同的缓冲池度量 标准。有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-information-schema-buffer-pool-tables.html#innodb-information-schema-buffer-pool-stats-example" target="_blank" rel="noopener">示例14.10，“查询INNODB_BUFFER_POOL_STATS表”</a>。</p>
<br>



<h3 id="14-5-2-Change-Buffer"><a href="#14-5-2-Change-Buffer" class="headerlink" title="14.5.2 Change Buffer"></a>14.5.2 Change Buffer</h3><p>Change Buffer是一种特殊的数据结构，当<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_secondary_index" target="_blank" rel="noopener">二级索引</a>页不在<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_buffer_pool" target="_blank" rel="noopener">缓冲池(Buffer Pool)中</a>时，它们 会缓存这些更改 。当页面通过其他读取操作加载到缓冲池中时，可能由<a href="https://dev.mysql.com/doc/refman/5.6/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>， <a href="https://dev.mysql.com/doc/refman/5.6/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>或 <a href="https://dev.mysql.com/doc/refman/5.6/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>操作（DML）导致的缓冲更改 将在以后合并。</p>
<p><strong>图14.3Change Buffer</strong></p>
<p><img src="https://dev.mysql.com/doc/refman/5.6/en/images/innodb-change-buffer.png" alt></p>
<p>与<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_clustered_index" target="_blank" rel="noopener">聚簇索引</a>不同，二级索引通常是非唯一的，并且二级索引中的插入以相对随机的顺序发生。同样，删除和更新可能会影响索引树中不相邻的二级索引页。当稍后通过其他操作将受影响的页读入缓冲池时，合并缓存的更改将避免从磁盘将辅助索引页读入缓冲池所需的大量随机访问I / O。</p>
<p>在系统大部分处于空闲状态或缓慢关闭期间运行的清除操作会定期将更新的索引页写入磁盘。与将每个值立即写入磁盘相比，清除操作可以更有效地为一系列索引值写入磁盘块。</p>
<p>当有许多受影响的行和许多辅助索引要更新时，Change Buffer合并可能需要几个小时。在此期间，磁盘I / O会增加，这可能会导致磁盘绑定查询的速度大大降低。提交事务之后，甚至在服务器关闭并重新启动之后，Change Buffer合并也可能继续发生（ 有关更多信息<a href="https://dev.mysql.com/doc/refman/5.6/en/forcing-innodb-recovery.html" target="_blank" rel="noopener">，</a>请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/forcing-innodb-recovery.html" target="_blank" rel="noopener">第14.21.2节“强制InnoDB恢复”</a>）。</p>
<p>在内存中，Change Buffer占用了缓冲池的一部分。在磁盘上，Change Buffer是系统表空间的一部分，当数据库服务器关闭时，索引更改将存储在其中。</p>
<p>Change Buffer中缓存的数据类型由 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_change_buffering" target="_blank" rel="noopener"><code>innodb_change_buffering</code></a>变量控制。有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-change-buffer.html#innodb-change-buffer-configuration" target="_blank" rel="noopener">配置变更缓冲</a>。您还可以配置最大Change Buffer大小。有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-change-buffer.html#innodb-change-buffer-maximum-size" target="_blank" rel="noopener">配置Change Buffer最大大小</a>。</p>
<p>如果索引包含降序索引列或主键包含降序索引列，则辅助索引不支持更改缓冲。</p>
<p>有关Change Buffer的常见问题的答案，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/faqs-innodb-change-buffer.html" target="_blank" rel="noopener">第A.16节“ MySQL 5.6 FAQ：InnoDBChange Buffer”</a>。</p>
<h4 id="配置Change-Buffer"><a href="#配置Change-Buffer" class="headerlink" title="配置Change Buffer"></a>配置Change Buffer</h4><p>在表上执行，和 操作时<a href="https://dev.mysql.com/doc/refman/5.6/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>， 索引列的值（尤其是辅助键的值）通常处于未排序的顺序，需要大量的I / O才能使辅助索引保持最新状态。当相关<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_page" target="_blank" rel="noopener">页面</a>不在 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_buffer_pool" target="_blank" rel="noopener">缓冲池中时</a>，<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_change_buffer" target="_blank" rel="noopener">Change Buffer</a>将 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_change_buffer" target="_blank" rel="noopener">更改</a>缓存到辅助索引条目 ，从而避免了不立即从磁盘读取页面而避免了昂贵的I / O操作。当页面加载到缓冲池中时，缓冲的更改将合并，更新的页面随后将刷新到磁盘。的<a href="https://dev.mysql.com/doc/refman/5.6/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a><a href="https://dev.mysql.com/doc/refman/5.6/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a><code>InnoDB</code>当服务器接近空闲时以及在<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_slow_shutdown" target="_blank" rel="noopener">缓慢关闭</a>期间，主线程会合并缓冲的更改 。</p>
<p>由于Change Buffer功能可以减少磁盘读写操作，因此它对于受I / O约束的工作负载（例如，具有大量DML操作的应用程序，例如批量插入）最有价值。</p>
<p>但是，Change Buffer占用了缓冲池的一部分，从而减少了可用于缓存数据页的内存。如果工作集几乎适合缓冲池，或者您的表具有相对较少的二级索引，则禁用更改缓冲可能很有用。如果工作数据集完全适合缓冲池，则更改缓冲不会带来额外的开销，因为它仅适用于不在缓冲池中的页面。</p>
<p>您可以<code>InnoDB</code> 使用<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_change_buffering" target="_blank" rel="noopener"><code>innodb_change_buffering</code></a> 配置参数来控制执行更改缓冲 的程度。您可以为插入，删除操作（最初将索引记录标记为删除）和清除操作（物理删除索引记录）启用或禁用缓冲。更新操作是插入和删除的组合。默认 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_change_buffering" target="_blank" rel="noopener"><code>innodb_change_buffering</code></a>值为 <code>all</code>。</p>
<p>允许的<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_change_buffering" target="_blank" rel="noopener"><code>innodb_change_buffering</code></a> 值包括：</p>
<ul>
<li><p><strong><code>all</code></strong></p>
<p>默认值：缓冲区插入，删除标记操作和清除。</p>
</li>
<li><p><strong><code>none</code></strong></p>
<p>不要缓冲任何操作。</p>
</li>
<li><p><strong><code>inserts</code></strong></p>
<p>缓冲区插入操作。</p>
</li>
<li><p><strong><code>deletes</code></strong></p>
<p>缓冲区删除标记操作。</p>
</li>
<li><p><strong><code>changes</code></strong></p>
<p>缓冲插入和删除标记操作。</p>
</li>
<li><p><strong><code>purges</code></strong></p>
<p>缓冲在后台发生的物理删除操作。</p>
</li>
</ul>
<p>您可以<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_change_buffering" target="_blank" rel="noopener"><code>innodb_change_buffering</code></a>在MySQL选项文件（<code>my.cnf</code>或 <code>my.ini</code>）中设置 参数，或使用<a href="https://dev.mysql.com/doc/refman/5.6/en/set-variable.html" target="_blank" rel="noopener"><code>SET GLOBAL</code></a> 语句动态更改参数，该 语句需要足够的权限来设置全局系统变量。请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/system-variable-privileges.html" target="_blank" rel="noopener">第5.1.8.1节“系统变量特权”</a>。更改设置会影响新操作的缓冲。现有缓冲条目的合并不受影响。</p>
<h4 id="配置Change-Buffer最大大小"><a href="#配置Change-Buffer最大大小" class="headerlink" title="配置Change Buffer最大大小"></a>配置Change Buffer最大大小</h4><p>该<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_change_buffer_max_size" target="_blank" rel="noopener"><code>innodb_change_buffer_max_size</code></a> 变量允许将<strong><u>Change Buffer的最大大小配置为Buffer Pool总大小的百分比</u></strong>。默认情况下， <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_change_buffer_max_size" target="_blank" rel="noopener"><code>innodb_change_buffer_max_size</code></a>设置为25。最大设置为50。</p>
<p>考虑<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_change_buffer_max_size" target="_blank" rel="noopener"><code>innodb_change_buffer_max_size</code></a>在具有大量插入，更新和删除活动的MySQL服务器上进行增加 ，其中Change Buffer合并不能跟上新的Change Buffer条目，从而导致Change Buffer达到其最大大小限制。</p>
<p>考虑<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_change_buffer_max_size" target="_blank" rel="noopener"><code>innodb_change_buffer_max_size</code></a>在使用静态数据进行报告的MySQL服务器上减少 存储空间，或者Change Buffer消耗的缓冲池共享的内存空间过多，从而导致页面比预期的更快地退出缓冲池。</p>
<p>使用代表性的工作负载测试不同的设置，以确定最佳配置。该 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_change_buffer_max_size" target="_blank" rel="noopener"><code>innodb_change_buffer_max_size</code></a> 设置是动态的，允许在不重新启动服务器的情况下修改设置。</p>
<h4 id="监视Change-Buffer"><a href="#监视Change-Buffer" class="headerlink" title="监视Change Buffer"></a>监视Change Buffer</h4><p>以下选项可用于Change Buffer监视：</p>
<ul>
<li><p><code>InnoDB</code>标准监视器输出包括Change Buffer状态信息。要查看监视器数据，请发出该<code>SHOW ENGINE INNODB STATUS</code>语句。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW ENGINE INNODB STATUS\G</span><br></pre></td></tr></table></figure>

<p>Change Buffer状态信息位于<code>INSERT BUFFER AND ADAPTIVE HASH INDEX</code> 标题下， 并显示类似以下内容：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> BUFFER <span class="keyword">AND</span> ADAPTIVE <span class="keyword">HASH</span> <span class="keyword">INDEX</span></span><br><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line">Ibuf: <span class="keyword">size</span> <span class="number">1</span>, free <span class="keyword">list</span> <span class="keyword">len</span> <span class="number">0</span>, seg <span class="keyword">size</span> <span class="number">2</span>, <span class="number">0</span> merges</span><br><span class="line">merged <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br><span class="line">discarded <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">4425293</span>, used cells <span class="number">32</span>, node <span class="keyword">heap</span> has <span class="number">1</span> buffer(s)</span><br><span class="line"><span class="number">13577.57</span> <span class="keyword">hash</span> searches/s, <span class="number">202.47</span> non-<span class="keyword">hash</span> searches/s</span><br></pre></td></tr></table></figure>

<p>有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-standard-monitor.html" target="_blank" rel="noopener">第14.17.3节“ InnoDB标准监视器和锁定监视器输出”</a>。</p>
</li>
<li><p>该 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-metrics-table.html" target="_blank" rel="noopener"><code>INFORMATION_SCHEMA.INNODB_METRICS</code></a> 表提供了在<code>InnoDB</code>标准监视器输出中找到的大多数数据点 以及其他数据点。要查看Change Buffer度量标准以及每个度量标准的描述，请发出以下查询：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT NAME, COMMENT FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME LIKE '%ibuf%'\G</span><br></pre></td></tr></table></figure>

<p>有关<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-metrics-table.html" target="_blank" rel="noopener"><code>INNODB_METRICS</code></a>表用法的信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-information-schema-metrics-table.html" target="_blank" rel="noopener">第14.15.6节“ InnoDB INFORMATION_SCHEMA指标表”</a>。</p>
</li>
<li><p>该 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-buffer-page-table.html" target="_blank" rel="noopener"><code>INFORMATION_SCHEMA.INNODB_BUFFER_PAGE</code></a> 表提供有关缓冲池中每个页面的元数据，包括Change Buffer索引和Change Buffer位图页面。Change Buffer页面由标识 <code>PAGE_TYPE</code>。<code>IBUF_INDEX</code>是Change Buffer索引页面<code>IBUF_BITMAP</code>的页面类型，并且 是Change Buffer位图页面的页面类型。</p>
<p>警告</p>
<p>查询该<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-buffer-page-table.html" target="_blank" rel="noopener"><code>INNODB_BUFFER_PAGE</code></a> 表可能会带来很大的性能开销。为避免影响性能，请重现要在测试实例上调查的问题，然后在测试实例上运行查询。</p>
<p>例如，您可以查询该 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-buffer-page-table.html" target="_blank" rel="noopener"><code>INNODB_BUFFER_PAGE</code></a>表以确定缓冲池页面总数中所包含的<code>IBUF_INDEX</code>和 的大概数量 <code>IBUF_BITMAP</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT (SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE</span><br><span class="line">       WHERE PAGE_TYPE LIKE 'IBUF%') AS change_buffer_pages, </span><br><span class="line">       (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_BUFFER_PAGE) <span class="keyword">AS</span> total_pages,</span><br><span class="line">       (<span class="keyword">SELECT</span> ((change_buffer_pages/total_pages)*<span class="number">100</span>)) </span><br><span class="line">       <span class="keyword">AS</span> change_buffer_page_percentage;</span><br><span class="line">+<span class="comment">---------------------+-------------+-------------------------------+</span></span><br><span class="line">| change_buffer_pages | total_pages | change_buffer_page_percentage |</span><br><span class="line">+<span class="comment">---------------------+-------------+-------------------------------+</span></span><br><span class="line">|                  25 |        8192 |                        0.3052 |</span><br><span class="line">+<span class="comment">---------------------+-------------+-------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>有关该<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-buffer-page-table.html" target="_blank" rel="noopener"><code>INNODB_BUFFER_PAGE</code></a>表提供的其他数据的信息 ，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-buffer-page-table.html" target="_blank" rel="noopener">第21.30.1节“ INFORMATION_SCHEMA INNODB_BUFFER_PAGE表”</a>。有关相关用法信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-information-schema-buffer-pool-tables.html" target="_blank" rel="noopener">第14.15.5节“ InnoDB INFORMATION_SCHEMA缓冲池表”</a>。</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.6/en/performance-schema.html" target="_blank" rel="noopener">Performance Schema</a> 提供了Change Buffer互斥锁等待工具，以进行高级性能监视。要查看Change Buffer检测，请发出以下查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM performance_schema.setup_instruments</span><br><span class="line">       WHERE NAME LIKE '%wait/synch/mutex/innodb/ibuf%';</span><br><span class="line">+<span class="comment">-------------------------------------------------------+---------+-------+</span></span><br><span class="line">| NAME                                                  | ENABLED | TIMED |</span><br><span class="line">+<span class="comment">-------------------------------------------------------+---------+-------+</span></span><br><span class="line">| wait/synch/mutex/innodb/ibuf_bitmap_mutex             | YES     | YES   |</span><br><span class="line">| wait/synch/mutex/innodb/ibuf_mutex                    | YES     | YES   |</span><br><span class="line">| wait/synch/mutex/innodb/ibuf_pessimistic_insert_mutex | YES     | YES   |</span><br><span class="line">+<span class="comment">-------------------------------------------------------+---------+-------+</span></span><br></pre></td></tr></table></figure>

<p>有关监视<code>InnoDB</code> 互斥锁等待的信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/monitor-innodb-mutex-waits-performance-schema.html" target="_blank" rel="noopener">第14.16.1节“使用性能模式监视InnoDB Mutex等待”</a>。</p>
</li>
</ul>
<br>

<h3 id="14-5-3自适应哈希索引"><a href="#14-5-3自适应哈希索引" class="headerlink" title="14.5.3自适应哈希索引"></a>14.5.3自适应哈希索引</h3><p>自适应哈希索引（innodb-adaptive-hash）功能可以<code>InnoDB</code> 在不牺牲事务功能或可靠性的情况下，在工作负载和缓冲池有足够内存的适当组合的系统上，更像是内存数据库。自适应哈希索引功能由<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_adaptive_hash_index" target="_blank" rel="noopener"><code>innodb_adaptive_hash_index</code></a> 变量启用 ，或在服务器启动时由禁用 <code>--skip-innodb-adaptive-hash-index</code>。</p>
<p>根据观察到的搜索模式，使用索引关键字的前缀构建哈希索引。该前缀可以是任何长度，并且可能是哈希树索引中仅B树中的某些值出现。哈希索引是根据对经常访问的索引页面的需求而建立的。</p>
<p>如果表几乎完全适合主内存，则散列索引可以通过启用直接查找任何元素的方式来加速查询，从而将索引值转换为某种指针。<code>InnoDB</code> 具有监视索引搜索的机制。如果 <code>InnoDB</code>发现查询可以从构建哈希索引中受益，它会自动这样做。</p>
<p>在某些工作负载下，哈希索引查找的速度大大超过了监视索引查找和维护哈希索引结构的额外工作。在繁重的工作负载（例如多个并发连接）下，访问自适应哈希索引有时可能会成为争用的源。与 <code>LIKE</code>运算符和<code>%</code> 通配符也往往不会受益。对于无法从自适应哈希索引功能中受益的工作负载，将其关闭可减少不必要的性能开销。由于很难预先预测自适应哈希索引功能是否适合特定的系统和工作负载，因此请考虑启用和禁用该功能的基准测试。与早期版本相比，MySQL 5.6中的体系结构更改使其更适合禁用自适应哈希索引功能。</p>
<p>您可以在输出<code>SEMAPHORES</code>部分中 监视自适应哈希索引的使用和争用 <a href="https://dev.mysql.com/doc/refman/5.6/en/show-engine.html" target="_blank" rel="noopener"><code>SHOW ENGINE INNODB STATUS</code></a>。如果在中创建的RW锁上有许多线程正在等待<code>btr0sea.c</code>，则禁用自适应哈希索引功能可能很有用。</p>
<p>有关哈希索引的性能特征的信息，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/index-btree-hash.html" target="_blank" rel="noopener">第8.3.8节“ B树和哈希索引的比较”</a>。</p>
<br>

<h3 id="14-5-4-Log-Buffer"><a href="#14-5-4-Log-Buffer" class="headerlink" title="14.5.4 Log Buffer"></a>14.5.4 Log Buffer</h3><p>日志缓冲区是存储区域，用于保存要写入磁盘上的日志文件的数据。日志缓冲区大小由<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_log_buffer_size" target="_blank" rel="noopener"><code>innodb_log_buffer_size</code></a>变量定义 。默认大小为16MB。日志缓冲区的内容会定期刷新到磁盘。较大的日志缓冲区使大型事务可以运行，而无需在事务提交之前将Redo Log数据写入磁盘。因此，如果您有更新，插入或删除许多行的事务，则增加日志缓冲区的大小可以节省磁盘I / O。</p>
<p>该 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_flush_log_at_trx_commit" target="_blank" rel="noopener"><code>innodb_flush_log_at_trx_commit</code></a> 变量控制如何将日志缓冲区的内容写入并刷新到磁盘。该 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_flush_log_at_timeout" target="_blank" rel="noopener"><code>innodb_flush_log_at_timeout</code></a> 变量控制日志刷新频率。</p>
<br>

<h2 id="14-6-InnoDB磁盘结构"><a href="#14-6-InnoDB磁盘结构" class="headerlink" title="14.6 InnoDB磁盘结构"></a>14.6 InnoDB磁盘结构</h2><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-tables.html" target="_blank" rel="noopener">14.6.1表格</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-indexes.html" target="_blank" rel="noopener">14.6.2索引</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-tablespace.html" target="_blank" rel="noopener">14.6.3表空间</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-data-dictionary.html" target="_blank" rel="noopener">14.6.4 InnoDB数据字典</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-doublewrite-buffer.html" target="_blank" rel="noopener">14.6.5Doublewrite Buffer</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-redo-log.html" target="_blank" rel="noopener">14.6.6Redo Log</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-undo-logs.html" target="_blank" rel="noopener">14.6.7Undo Log</a></li>
</ul>
<p>本节介绍<code>InnoDB</code>磁盘上的结构和相关主题。</p>
<br>

<h3 id="14-6-1-Tables"><a href="#14-6-1-Tables" class="headerlink" title="14.6.1 Tables"></a>14.6.1 Tables</h3><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/using-innodb-tables.html" target="_blank" rel="noopener">14.6.1.1创建InnoDB表</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-create-table-external.html" target="_blank" rel="noopener">14.6.1.2在外部创建表</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-table-import.html" target="_blank" rel="noopener">14.6.1.3导入InnoDB表</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-migration.html" target="_blank" rel="noopener">14.6.1.4移动或复制InnoDB表</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/converting-tables-to-innodb.html" target="_blank" rel="noopener">14.6.1.5将表从MyISAM转换为InnoDB</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-auto-increment-handling.html" target="_blank" rel="noopener">14.6.1.6 InnoDB中的AUTO_INCREMENT处理</a></li>
</ul>
<h4 id="14-6-1-1创建InnoDB表"><a href="#14-6-1-1创建InnoDB表" class="headerlink" title="14.6.1.1创建InnoDB表"></a>14.6.1.1创建InnoDB表</h4><p>要创建<code>InnoDB</code>表，请使用以下 <a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (a <span class="built_in">INT</span>, b <span class="built_in">CHAR</span> (<span class="number">20</span>), PRIMARY <span class="keyword">KEY</span> (a)) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>

<p>如果将<code>ENGINE=InnoDB</code> 子句<code>InnoDB</code>定义为默认存储引擎（默认情况下为默认引擎），则无需指定该子句。要检查默认存储引擎，请发出以下语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT @@default_storage_engine;</span><br><span class="line">+<span class="comment">--------------------------+</span></span><br><span class="line">| @@default_storage_engine |</span><br><span class="line">+<span class="comment">--------------------------+</span></span><br><span class="line">| InnoDB                   |</span><br><span class="line">+<span class="comment">--------------------------+</span></span><br></pre></td></tr></table></figure>

<p><code>ENGINE=InnoDB</code>如果计划使用<a href="https://dev.mysql.com/doc/refman/5.6/en/mysqldump.html" target="_blank" rel="noopener"><strong>mysqldump</strong></a>或复制<a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>在没有默认存储引擎的服务器上重播该语句， 则 可能仍使用子句<code>InnoDB</code>。</p>
<p>一个<code>InnoDB</code>表及其索引可以在创建<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_system_tablespace" target="_blank" rel="noopener">系统表空间</a>或在一个 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_file_per_table" target="_blank" rel="noopener">文件每个表的</a> 表空间。当 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a>启用，这是默认像MySQL 5.6.6的，一 <code>InnoDB</code>台是隐含在一个单独的文件，每个表的表空间中创建。相反，如果 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a>禁用此选项，则会<code>InnoDB</code>在<code>InnoDB</code>系统表空间中隐式创建表。</p>
<p>创建<code>InnoDB</code>表时，MySQL 在MySQL数据目录下的数据库目录中创建一个<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_frm_file" target="_blank" rel="noopener">.frm文件</a>。有关<code>.frm</code>文件的更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/using-innodb-tables.html#innodb-frm-file" target="_blank" rel="noopener">InnoDB表和.frm文件</a>。对于在每个表文件表空间中创建的表，默认情况下，MySQL还在数据库目录中创建一个 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_ibd_file" target="_blank" rel="noopener">.ibd</a>表空间文件。在 <code>InnoDB</code>系统表空间中创建的表在现有<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_ibd_file" target="_blank" rel="noopener">ibdata文件中</a>创建，该<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_ibd_file" target="_blank" rel="noopener">文件</a>位于MySQL数据目录中。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191203143854.png" alt></p>
<p>在内部，<code>InnoDB</code>将每个表的条目添加到<code>InnoDB</code>数据字典中。该条目包括数据库名称。例如，如果<code>t1</code>在<code>test</code> 数据库中创建了table ，则数据库名称的数据字典条目为 <code>&#39;test/t1&#39;</code>。这意味着您可以<code>t1</code>在不同的数据库中创建一个具有相同名称（）的表，并且该表名不会在内部冲突<code>InnoDB</code>。</p>
<h5 id="InnoDB表和-frm文件"><a href="#InnoDB表和-frm文件" class="headerlink" title="InnoDB表和.frm文件"></a>InnoDB表和.frm文件</h5><p>MySQL将表的数据字典信息<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_frm_file" target="_blank" rel="noopener">存储</a>在数据库目录中的 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_frm_file" target="_blank" rel="noopener">.frm文件</a>中。与其他MySQL存储引擎不同， <code>InnoDB</code>它还在系统表空间内的自身内部数据字典中编码有关表的信息。MySQL删除表或数据库时，将删除一个或多个<code>.frm</code>文件以及<code>InnoDB</code>数据字典中的相应条目。您不能<code>InnoDB</code>仅通过移动<code>.frm</code> 文件来在数据库之间移动表。有关移动<code>InnoDB</code> 表的信息，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-migration.html" target="_blank" rel="noopener">第14.6.1.4节“移动或复制InnoDB表”</a>。</p>
<h5 id="InnoDB表和行格式"><a href="#InnoDB表和行格式" class="headerlink" title="InnoDB表和行格式"></a>InnoDB表和行格式</h5><p>默认的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_row_format" target="_blank" rel="noopener">行格式</a>的的<code>InnoDB</code>表 <code>Compact</code>。尽管此行格式适合基本实验，但请考虑使用 <code>Dynamic</code> or <code>Compressed</code> 格式来利用<code>InnoDB</code> 诸如表压缩和长列值的有效页外存储等功能。使用这些行格式要求将<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a>其启用（MySQL 5.6.6中的默认值），并将其 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_format" target="_blank" rel="noopener"><code>innodb_file_format</code></a>设置为 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_barracuda" target="_blank" rel="noopener">Barracuda</a>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> innodb_file_per_table=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> innodb_file_format=barracuda;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t3 (a <span class="built_in">INT</span>, b <span class="built_in">CHAR</span> (<span class="number">20</span>), PRIMARY <span class="keyword">KEY</span> (a)) ROW_FORMAT=DYNAMIC;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t4 (a <span class="built_in">INT</span>, b <span class="built_in">CHAR</span> (<span class="number">20</span>), PRIMARY <span class="keyword">KEY</span> (a)) ROW_FORMAT=COMPRESSED;</span><br></pre></td></tr></table></figure>

<p>有关<code>InnoDB</code>行格式的更多信息，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-row-format.html" target="_blank" rel="noopener">第14.11节“ InnoDB行格式”</a>。有关如何确定<code>InnoDB</code>表的行格式以及行格式的物理特性的信息<code>InnoDB</code> ，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-row-format.html" target="_blank" rel="noopener">第14.11节“ InnoDB行格式”</a>。</p>
<h5 id="InnoDB表和主键"><a href="#InnoDB表和主键" class="headerlink" title="InnoDB表和主键"></a>InnoDB表和主键</h5><p>始终为表定义一个<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_primary_key" target="_blank" rel="noopener">主键</a><code>InnoDB</code>，并指定一个或多个满足以下条件的列：</p>
<ul>
<li>被最重要的查询引用。</li>
<li>永远不会空白。</li>
<li>永远不要有重复的值。</li>
<li>一旦插入，就很少更改值。</li>
</ul>
<p>例如，在包含有关人员的信息的表中，您不会在其上创建主键，<code>(firstname, lastname)</code>因为一个以上的人员可以具有相同的名称，某些人员的姓氏为空白，有时人们会更改其名称。有这么多的约束，通常没有明显的列集可以用作主键，因此您需要创建一个新的具有数字ID的列，以用作全部或部分主键。您可以声明一个 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_auto_increment" target="_blank" rel="noopener">自动增量</a>列，以便在插入行时自动填写升序值：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The value of ID can act like a pointer between related items in different tables.</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t5 (<span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT, b <span class="built_in">CHAR</span> (<span class="number">20</span>), PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment"># The primary key can consist of more than one column. Any autoinc column must come first.</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t6 (<span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT, a <span class="built_in">INT</span>, b <span class="built_in">CHAR</span> (<span class="number">20</span>), PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>,a));</span><br></pre></td></tr></table></figure>

<p>尽管在没有定义主键的情况下表可以正常工作，但是主键涉及性能的许多方面，并且对于任何大型或经常使用的表都是至关重要的设计方面。建议您始终在<a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a> 语句中指定主键。如果创建表，加载数据，然后稍后运行 <a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>以添加主键，则该操作比创建表时定义主键要慢得多。</p>
<h5 id="查看InnoDB表属性"><a href="#查看InnoDB表属性" class="headerlink" title="查看InnoDB表属性"></a>查看InnoDB表属性</h5><p>要查看<code>InnoDB</code>表的属性，请发出一条<a href="https://dev.mysql.com/doc/refman/5.6/en/show-table-status.html" target="_blank" rel="noopener"><code>SHOW TABLE STATUS</code></a> 语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW TABLE STATUS FROM test LIKE 't%' \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           Name: t1</span><br><span class="line">         Engine: InnoDB</span><br><span class="line">        Version: 10</span><br><span class="line">     Row_format: Compact</span><br><span class="line">           Rows: 0</span><br><span class="line"> Avg_row_length: 0</span><br><span class="line">    Data_length: 16384</span><br><span class="line">Max_data_length: 0</span><br><span class="line">   Index_length: 0</span><br><span class="line">      Data_free: 0</span><br><span class="line"> Auto_increment: NULL</span><br><span class="line">    Create_time: 2015-03-16 16:26:52</span><br><span class="line">    Update_time: NULL</span><br><span class="line">     Check_time: NULL</span><br><span class="line">      Collation: latin1_swedish_ci</span><br><span class="line">       <span class="keyword">Checksum</span>: <span class="literal">NULL</span></span><br><span class="line"> Create_options:</span><br><span class="line">        <span class="keyword">Comment</span>:</span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>有关<a href="https://dev.mysql.com/doc/refman/5.6/en/show-table-status.html" target="_blank" rel="noopener"><code>SHOW TABLE STATUS</code></a>输出的信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/show-table-status.html" target="_blank" rel="noopener">第13.7.5.37节“ SHOW TABLE STATUS语句”</a>。</p>
<p><code>InnoDB</code>还可以使用<code>InnoDB</code>Information Schema系统表查询表属性：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_TABLES WHERE NAME='test/t1' \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">     TABLE_ID: 42</span><br><span class="line">         NAME: test/t1</span><br><span class="line">         FLAG: 1</span><br><span class="line">       N_COLS: 5</span><br><span class="line">        SPACE: 24</span><br><span class="line">  FILE_FORMAT: Antelope</span><br><span class="line">   ROW_FORMAT: Compact</span><br><span class="line">ZIP_PAGE_SIZE: 0</span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure>

<p>有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-information-schema-system-tables.html" target="_blank" rel="noopener">第14.15.3节“ InnoDB INFORMATION_SCHEMA系统表”</a>。</p>
<br>

<h4 id="14-6-1-5将表从MyISAM转换为InnoDB"><a href="#14-6-1-5将表从MyISAM转换为InnoDB" class="headerlink" title="14.6.1.5将表从MyISAM转换为InnoDB"></a>14.6.1.5将表从MyISAM转换为InnoDB</h4><p>如果您具有<a href="https://dev.mysql.com/doc/refman/5.6/en/myisam-storage-engine.html" target="_blank" rel="noopener"><code>MyISAM</code></a>要转换<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-storage-engine.html" target="_blank" rel="noopener"><code>InnoDB</code></a>为更好的可靠性和可伸缩性的表，请在转换之前查看以下准则和提示。</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/converting-tables-to-innodb.html#innodb-convert-memory-usage" target="_blank" rel="noopener">调整MyISAM和InnoDB的内存使用量</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/converting-tables-to-innodb.html#innodb-convert-transactions" target="_blank" rel="noopener">处理太长或太短的交易</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/converting-tables-to-innodb.html#innodb-convert-deadlock" target="_blank" rel="noopener">处理死锁</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/converting-tables-to-innodb.html#innodb-convert-plan-storage" target="_blank" rel="noopener">规划存储布局</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/converting-tables-to-innodb.html#innodb-convert-convert" target="_blank" rel="noopener">转换现有表</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/converting-tables-to-innodb.html#innodb-convert-clone" target="_blank" rel="noopener">克隆表的结构</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/converting-tables-to-innodb.html#innodb-convert-transfer" target="_blank" rel="noopener">传输现有数据</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/converting-tables-to-innodb.html#innodb-convert-storage-requirements" target="_blank" rel="noopener">储存要求</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/converting-tables-to-innodb.html#innodb-convert-primary-key" target="_blank" rel="noopener">为每个表定义一个主键</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/converting-tables-to-innodb.html#innodb-convert-application-performance" target="_blank" rel="noopener">应用程序性能注意事项</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/converting-tables-to-innodb.html#innodb-convert-understand-files" target="_blank" rel="noopener">了解与InnoDB表关联的文件</a></li>
</ul>
<h5 id="调整MyISAM和InnoDB的内存使用量"><a href="#调整MyISAM和InnoDB的内存使用量" class="headerlink" title="调整MyISAM和InnoDB的内存使用量"></a>调整MyISAM和InnoDB的内存使用量</h5><p>从<code>MyISAM</code>表过渡时，降低<a href="https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_key_buffer_size" target="_blank" rel="noopener"><code>key_buffer_size</code></a>配置选项的值 以释放缓存结果不再需要的内存。增加<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_buffer_pool_size" target="_blank" rel="noopener"><code>innodb_buffer_pool_size</code></a> 配置选项的值，该 选项执行与为<code>InnoDB</code>表分配缓存内存类似的作用。该 <code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_buffer_pool" target="_blank" rel="noopener">缓冲池</a>可以缓存表数据和索引数据，加快了查询，查找并保持查询结果在内存中进行再利用。有关缓冲池大小配置的指导，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/memory-use.html" target="_blank" rel="noopener">第8.12.4.1节“ MySQL如何使用内存”</a>。</p>
<p>在繁忙的服务器上，在关闭查询缓存的情况下运行基准测试。该<code>InnoDB</code>缓冲池提供类似的好处，所以查询缓存可能会不必要地占用内存。有关查询缓存的信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/query-cache.html" target="_blank" rel="noopener">第8.10.3节“ MySQL查询缓存”</a>。</p>
<h5 id="处理太长或太短的交易"><a href="#处理太长或太短的交易" class="headerlink" title="处理太长或太短的交易"></a>处理太长或太短的交易</h5><p>因为<code>MyISAM</code>表不支持 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_transaction" target="_blank" rel="noopener">事务</a>，所以您可能没有过多注意 <a href="https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_autocommit" target="_blank" rel="noopener"><code>autocommit</code></a>配置选项和<a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a>and <a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>ROLLBACK</code></a> 语句。这些关键字对于允许多个会话同时读取和写入<code>InnoDB</code>表很重要，从而在写繁重的工作负载中提供了可伸缩性的实质好处。</p>
<p>当事务打开时，系统会保留数据快照，如在事务开始时看到的那样，如果系统在杂散事务保持运行的同时插入，更新和删除数百万行，则可能导致大量开销。因此，请注意避免事务运行时间过长：</p>
<ul>
<li>如果您正在使用<a href="https://dev.mysql.com/doc/refman/5.6/en/mysql.html" target="_blank" rel="noopener"><strong>mysql</strong></a>会话进行交互式实验，请务必 <a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a>在完成时（完成更改）或 <a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>ROLLBACK</code></a>（撤消更改）。关闭交互式会话，而不要长时间打开它们，以免意外使事务长时间打开。</li>
<li>确保您的应用程序中的任何错误处理程序也未 <a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>ROLLBACK</code></a> 完成更改或<a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a> 已完成更改。</li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>ROLLBACK</code></a>这是一个相对昂贵的操作，因为 <a href="https://dev.mysql.com/doc/refman/5.6/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>， <a href="https://dev.mysql.com/doc/refman/5.6/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.6/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>操作会写入到<code>InnoDB</code>之前的表中 <a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a>，并期望大多数更改都能成功提交，并且很少进行回滚。试验大量数据时，请避免对大量行进行更改，然后回滚这些更改。</li>
<li>当使用一系列<a href="https://dev.mysql.com/doc/refman/5.6/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>语句加载大量数据时 ，请定期 <a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a>执行结果以避免事务持续数小时。在数据仓库的典型加载操作中，如果出现问题，请截断表（使用<a href="https://dev.mysql.com/doc/refman/5.6/en/truncate-table.html" target="_blank" rel="noopener"><code>TRUNCATE TABLE</code></a>），然后从头开始，而不是执行操作 <a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>ROLLBACK</code></a>。</li>
</ul>
<p>前面的技巧可以节省在过长的事务中可能浪费的内存和磁盘空间。当事务短于应有的时间时，问题就在于过多的I / O。对于每个 <a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a>，MySQL确保将每个更改安全地记录到磁盘上，其中涉及一些I / O。</p>
<ul>
<li>对于<code>InnoDB</code>表格的大多数操作，应使用设置 <a href="https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_autocommit" target="_blank" rel="noopener"><code>autocommit=0</code></a>。从效率的角度看，这样就避免了在发出大量连续的不必要的I / O <a href="https://dev.mysql.com/doc/refman/5.6/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>， <a href="https://dev.mysql.com/doc/refman/5.6/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>或 <a href="https://dev.mysql.com/doc/refman/5.6/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>语句。从安全角度来看，<a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>ROLLBACK</code></a> 如果您在<a href="https://dev.mysql.com/doc/refman/5.6/en/mysql.html" target="_blank" rel="noopener"><strong>mysql</strong></a>命令行或应用程序中的异常处理程序中出错，则允许您发布 语句以恢复丢失或乱码的数据。</li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_autocommit" target="_blank" rel="noopener"><code>autocommit=1</code></a>适用于<code>InnoDB</code>表 的时间是运行一系列查询以生成报告或分析统计信息时。在这种情况下，不会存在与<a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a>或 相关的I / O损失<a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>ROLLBACK</code></a>，并且<code>InnoDB</code>可以 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-performance-ro-txn.html" target="_blank" rel="noopener">自动优化只读工作负载</a>。</li>
<li>如果进行了一系列相关更改，请一次完成所有更改，最后一次 <a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a>完成。例如，如果您将相关的信息插入到多个表中，请<a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a> 在进行所有更改后执行一次。或者，如果您运行许多连续的 <a href="https://dev.mysql.com/doc/refman/5.6/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>语句，则<a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a>在加载所有数据之后执行一次 ；如果您要执行数百万条 <a href="https://dev.mysql.com/doc/refman/5.6/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>语句，则可能通过发出<a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a>每万或十万条记录来拆分庞大的事务 ，因此事务不会增长得太大。</li>
<li>请记住，即使是一条<a href="https://dev.mysql.com/doc/refman/5.6/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a> 语句也会打开一个事务，因此在交互式<a href="https://dev.mysql.com/doc/refman/5.6/en/mysql.html" target="_blank" rel="noopener"><strong>mysql</strong></a> 会话中运行某些报表或调试查询后，请发出a <a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a> 或关闭<a href="https://dev.mysql.com/doc/refman/5.6/en/mysql.html" target="_blank" rel="noopener"><strong>mysql</strong></a>会话。</li>
</ul>
<h5 id="处理死锁"><a href="#处理死锁" class="headerlink" title="处理死锁"></a>处理死锁</h5><p>您可能会在MySQL错误日志中看到警告消息，该警告消息涉及 “ 死锁 ”或的输出 <a href="https://dev.mysql.com/doc/refman/5.6/en/show-engine.html" target="_blank" rel="noopener"><code>SHOW ENGINE INNODB STATUS</code></a>。尽管名称听起来很吓人，但是 对于表来说，<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_deadlock" target="_blank" rel="noopener">死锁</a>并不是一个严重的问题<code>InnoDB</code>，并且通常不需要采取任何纠正措施。当两个事务开始修改多个表时，以不同的顺序访问表时，它们可以达到每个事务都在等待另一个的状态，而任何一个都不能继续进行。MySQL立即检测到这种情况并取消（<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_rollback" target="_blank" rel="noopener">回滚</a>）“ 较小 ”的事务，从而允许其他事务继续进行。</p>
<p>您的应用程序确实需要错误处理逻辑来重新启动像这样被强制取消的事务。当您重新发出与以前相同的SQL语句时，原始的计时问题不再适用。另一笔交易已经完成，您可以继续进行，或者另一笔交易仍在进行中，您的交易会等到完成为止。</p>
<p>如果不断发生死锁警告，则可以检查应用程序代码以一致的方式对SQL操作进行重新排序，或缩短事务。您可以在<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_print_all_deadlocks" target="_blank" rel="noopener"><code>innodb_print_all_deadlocks</code></a>启用该选项的情况下进行测试， 以查看MySQL错误日志中的所有死锁警告，而不仅仅是<a href="https://dev.mysql.com/doc/refman/5.6/en/show-engine.html" target="_blank" rel="noopener"><code>SHOW ENGINE INNODB STATUS</code></a>输出中的最后一个警告 。</p>
<p>有关更多信息，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-deadlocks.html" target="_blank" rel="noopener">第14.7.5节“ InnoDB中的死锁”</a>。</p>
<h5 id="规划存储布局"><a href="#规划存储布局" class="headerlink" title="规划存储布局"></a>规划存储布局</h5><p>为了从<code>InnoDB</code>表中获得最佳性能，您可以调整许多与存储布局相关的参数。</p>
<p>当您将<code>MyISAM</code>是大的，经常访问的，并保持至关重要的数据表，调查和考虑<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a>， <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_format" target="_blank" rel="noopener"><code>innodb_file_format</code></a>以及 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_page_size" target="_blank" rel="noopener"><code>innodb_page_size</code></a>配置选项，以及 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-row-format.html" target="_blank" rel="noopener"><code>ROW_FORMAT</code> 和<code>KEY_BLOCK_SIZE</code>条款</a>中的 <a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>说法。</p>
<p>在初始实验期间，最重要的设置是 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a>。启用此设置后，这是MySQL 5.6.6中的默认设置，新 <code>InnoDB</code>表将在<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_file_per_table" target="_blank" rel="noopener">每表文件表</a> 空间中隐式创建 。与<code>InnoDB</code>系统表空间相比，每表文件表空间允许在表被截断或删除时由操作系统回收磁盘空间。每表文件表空间还支持 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_barracuda" target="_blank" rel="noopener">梭子鱼</a>文件格式和相关功能，例如表压缩，长变长列的有效页外存储和大索引前缀。有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-file-per-table-tablespaces.html" target="_blank" rel="noopener">第14.6.3.2节“每表文件表空间”</a>。</p>
<h5 id="转换现有表"><a href="#转换现有表" class="headerlink" title="转换现有表"></a>转换现有表</h5><p>要将非<code>InnoDB</code>表转换为使用，请 <code>InnoDB</code>使用<a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>

<p>警告</p>
<p>不要<em>不</em>转换在MySQL系统表 <code>mysql</code>从数据库<code>MyISAM</code> 到<code>InnoDB</code>表。这是不受支持的操作。如果这样做，MySQL将不会重新启动，直到您从备份中还原旧的系统表或通过重新初始化数据目录来重新生成它们（请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/data-directory-initialization.html" target="_blank" rel="noopener">第2.10.1节“初始化数据目录”</a>）。</p>
<h5 id="克隆表的结构"><a href="#克隆表的结构" class="headerlink" title="克隆表的结构"></a>克隆表的结构</h5><p>您可以制作一个<code>InnoDB</code>表，该表是MyISAM表的克隆，而不是<a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>用来执行转换，以便在切换之前并排测试新旧表。</p>
<p>创建<code>InnoDB</code>具有相同的列和索引定义的空表。使用看到完整的 语句来使用。将子句更改为 。 <code>SHOW CREATE TABLE *</code>table_name<code>*\G</code><a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a><code>ENGINE``ENGINE=INNODB</code></p>
<h5 id="传输现有数据"><a href="#传输现有数据" class="headerlink" title="传输现有数据"></a>传输现有数据</h5><p>要将大量数据传输到<code>InnoDB</code>上一节中创建的空 表中，请使用插入行。 <code>INSERT INTO *</code>innodb_table<code>* SELECT * FROM *</code>myisam_table<code>* ORDER BY *</code>primary_key_columns<code>*</code></p>
<p>您还可以<code>InnoDB</code> 在插入数据后为表创建索引。从历史上看，创建新的二级索引对于InnoDB而言是一项缓慢的操作，但是现在您可以在索引创建步骤中以相对较少的开销加载数据之后创建索引。</p>
<p>如果您<code>UNIQUE</code>对辅助键有限制，则可以通过在导入操作期间暂时关闭唯一性检查来加快表的导入：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> unique_checks=<span class="number">0</span>;... import operation ...</span><br><span class="line"><span class="keyword">SET</span> unique_checks=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>对于大表，这可以节省磁盘I / O，因为 <code>InnoDB</code>可以使用其 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_change_buffer" target="_blank" rel="noopener">Change Buffer</a>将辅助索引记录批量写入。确保数据不包含重复的密钥。 <a href="https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_unique_checks" target="_blank" rel="noopener"><code>unique_checks</code></a>允许但不要求存储引擎忽略重复的密钥。</p>
<p>为了更好地控制插入过程，您可以分段插入大表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> newtable <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> oldtable</span><br><span class="line">   <span class="keyword">WHERE</span> yourkey &gt; something <span class="keyword">AND</span> yourkey &lt;= somethingelse;</span><br></pre></td></tr></table></figure>

<p>插入所有记录后，您可以重命名表。</p>
<p>在大表转换期间，增加<code>InnoDB</code>缓冲池的大小 以减少磁盘I / O，最多可占物理内存的80％。您还可以增加<code>InnoDB</code>日志文件的大小。</p>
<h5 id="储存要求"><a href="#储存要求" class="headerlink" title="储存要求"></a>储存要求</h5><p>如果打算<code>InnoDB</code>在转换过程中为表中的数据制作几个临时副本， 建议您在每个表文件表空间中创建表，以便在删除表时可以回收磁盘空间。当 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a> 配置选项启用（默认），新创建的 <code>InnoDB</code>表在文件的每个表的表空间隐式创建。</p>
<p>无论您是<code>MyISAM</code>直接转换表还是创建克隆<code>InnoDB</code>表，请确保在此过程中有足够的磁盘空间来容纳旧表和新表。 <strong><code>InnoDB</code>表比<code>MyISAM</code>表需要更多的磁盘空间。</strong> 如果<a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>操作空间不足，则会启动回滚，如果它是磁盘绑定的，则可能要花费数小时。对于插入，<code>InnoDB</code>使用插入缓冲区将二级索引记录合并到批索引中。这样可以节省大量的磁盘I / O。对于回滚，不使用这种机制，回滚所花费的时间可能比插入时间长30倍。</p>
<p>对于失控的回滚，如果数据库中没有有价值的数据，建议您终止数据库进程，而不要等待数百万的磁盘I / O操作完成。有关完整过程，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/forcing-innodb-recovery.html" target="_blank" rel="noopener">第14.21.2节“强制InnoDB恢复”</a>。</p>
<h5 id="为每个表定义一个主键"><a href="#为每个表定义一个主键" class="headerlink" title="为每个表定义一个主键"></a>为每个表定义一个主键</h5><p>该<code>PRIMARY KEY</code>子句是影响MySQL查询性能以及表和索引空间使用的关键因素。主键唯一地标识表中的一行。表中的每一行都必须具有主键值，并且任何两行都不能具有相同的主键值。</p>
<p>这些是主键的指南，后面有更详细的说明。</p>
<ul>
<li><code>PRIMARY KEY</code>为每个表 声明一个。通常，它是<code>WHERE</code>查找单行时在子句中引用的最重要的列。</li>
<li><code>PRIMARY KEY</code>在原始<a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a> 语句中 声明该子句，而不是稍后通过一条<a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>语句添加它 。</li>
<li>仔细选择列及其数据类型。数字列优先于字符列或字符串列。</li>
<li>如果没有其他稳定，唯一，非空的数字列要使用，请考虑使用自动递增列。</li>
<li>如果不确定主键列的值是否可以更改，则自动增量列也是一个不错的选择。更改主键列的值是一项昂贵的操作，可能涉及重新排列表内和每个二级索引内的数据。</li>
</ul>
<p>考虑将<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_primary_key" target="_blank" rel="noopener">主键</a>添加到尚无<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_primary_key" target="_blank" rel="noopener">主键</a>的任何表中。根据表的最大投影尺寸使用最小的实用数字类型。这可以使每行稍微紧凑一些，从而可以为大型表节省大量空间。如果表具有任何<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_secondary_index" target="_blank" rel="noopener">二级索引</a>，则节省的空间将成倍增加 ，因为在每个二级索引条目中都会重复主键值。除了减小磁盘上的数据大小之外，小的主键还使更多数据适合 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_buffer_pool" target="_blank" rel="noopener">缓冲池</a>，从而加快了各种操作并提高了并发性。</p>
<p>如果表在某个较长的列（例如）上已经具有主键<code>VARCHAR</code>，请考虑添加一个新的无符号 <code>AUTO_INCREMENT</code>列，并将主键切换到该列，即使查询中未引用该列。这种设计更改可以在二级索引中节省大量空间。您可以将以前的主键列指定为<code>UNIQUE NOT NULL</code>强制执行与<code>PRIMARY KEY</code>子句相同的约束，即防止所有这些列之间出现重复或空值。</p>
<p>如果将相关信息分布在多个表中，则通常每个表的主键使用同一列。例如，人员数据库可能有几个表，每个表都有员工编号的主键。一个销售数据库可能有一些带有客户编号主键的表，而另一些带有订单编号主键的表。因为使用主键的查找非常快，所以您可以为此类表构造有效的联接查询。</p>
<p>如果您<code>PRIMARY KEY</code>完全忽略该子句，MySQL会为您创建一个不可见的子句。它是一个6字节的值，可能比您需要的时间更长，因此浪费了空间。因为它是隐藏的，所以您不能在查询中引用它。</p>
<h5 id="应用程序性能注意事项"><a href="#应用程序性能注意事项" class="headerlink" title="应用程序性能注意事项"></a>应用程序性能注意事项</h5><p>与<code>InnoDB</code>等效<code>MyISAM</code>表相比，的可靠性和可伸缩性功能 需要更多的磁盘存储。您可能会略微更改列和索引的定义，以提高空间利用率，减少处理结果集时的I / O和内存消耗，以及更好地利用索引查找来实现更好的查询优化计划。</p>
<p>如果确实为主键设置了数字ID列，请使用该值与任何其他表中的相关值进行交叉引用，尤其是对于<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_join" target="_blank" rel="noopener">联接</a>查询。例如，与其接受一个国家名称作为输入并进行查询来搜索相同的名称，不如进行一次查找以确定国家ID，然后进行其他查询（或单个联接查询）以在多个表中查找相关信息。与其将客户或商品目录号存储为一串数字（可能会用完几个字节），不如将其转换为数字ID以进行存储和查询。4字节无符号 <a href="https://dev.mysql.com/doc/refman/5.6/en/integer-types.html" target="_blank" rel="noopener"><code>INT</code></a>列可以索引超过40亿个项目（美国的含义是十亿：十亿）。有关不同整数类型的范围，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/integer-types.html" target="_blank" rel="noopener">第11.2.1节“整数类型（精确值）-INTEGER，INT，SMALLINT，TINYINT，MEDIUMINT，BIGINT”</a>。</p>
<h5 id="了解与InnoDB表关联的文件"><a href="#了解与InnoDB表关联的文件" class="headerlink" title="了解与InnoDB表关联的文件"></a>了解与InnoDB表关联的文件</h5><p><code>InnoDB</code>文件比文件需要更多的照顾和计划<code>MyISAM</code>。</p>
<ul>
<li>您不得删除代表<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_system_tablespace" target="_blank" rel="noopener">系统表空间</a>的 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_ibdata_file" target="_blank" rel="noopener">ibdata文件</a>。 <code>InnoDB</code></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-migration.html" target="_blank" rel="noopener">第14.6.1.4节“移动或复制InnoDB表”</a><code>InnoDB</code>中介绍了 将表移动或复制到其他服务器的方法 。</li>
</ul>
<br>

<h3 id="14-6-2-Index"><a href="#14-6-2-Index" class="headerlink" title="14.6.2 Index"></a>14.6.2 Index</h3><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-index-types.html" target="_blank" rel="noopener">14.6.2.1聚集索引和二级索引</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-physical-structure.html" target="_blank" rel="noopener">14.6.2.2 InnoDB索引的物理结构</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-fulltext-index.html" target="_blank" rel="noopener">14.6.2.3 InnoDB全文索引</a></li>
</ul>
<p>本节涵盖与<code>InnoDB</code> 索引有关的主题。</p>
<h4 id="14-6-2-1聚集索引和二级索引"><a href="#14-6-2-1聚集索引和二级索引" class="headerlink" title="14.6.2.1聚集索引和二级索引"></a>14.6.2.1聚集索引和二级索引</h4><p>每个<code>InnoDB</code>表都有一个特殊的索引，称为<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_clustered_index" target="_blank" rel="noopener">聚簇索引</a> ，用于存储行数据。通常，聚簇索引与<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_primary_key" target="_blank" rel="noopener">主键</a>同义 。为了从查询，插入和其他数据库操作中获得最佳性能，您必须了解如何<code>InnoDB</code>使用聚簇索引为每个表优化最常见的查找和DML操作。</p>
<ul>
<li>在<code>PRIMARY KEY</code>表上定义a 时，<code>InnoDB</code>将其用作聚簇索引。为您创建的每个表定义一个主键。如果没有逻辑唯一且非空的列或列集，请添加一个新的 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_auto_increment" target="_blank" rel="noopener">自动递增</a> 列，其值将自动填充。</li>
<li>如果您没有<code>PRIMARY KEY</code>为表定义，MySQL会<code>UNIQUE</code>在所有键列所在的位置找到第一个索引，<code>NOT NULL</code>并将 <code>InnoDB</code>其用作聚集索引。</li>
<li>如果表没有索引<code>PRIMARY KEY</code>或没有合适的 <code>UNIQUE</code>索引，则在<code>InnoDB</code> 内部生成一个隐藏的聚集索引<code>GEN_CLUST_INDEX</code>，该索引在包含行ID值的合成列上命名 。这些行由<code>InnoDB</code>分配给该表中各行的ID排序 。行ID是一个6字节的字段，随着插入新行而单调增加。因此，按行ID排序的行实际上在插入顺序上。</li>
</ul>
<h5 id="聚集索引如何加快查询"><a href="#聚集索引如何加快查询" class="headerlink" title="聚集索引如何加快查询"></a>聚集索引如何加快查询</h5><p>通过聚集索引访问行是快速的，因为索引搜索直接导致包含所有行数据的页面。如果表很大，则与使用不同于索引记录的页面存储行数据的存储组织相比，聚集索引体系结构通常可以节省磁盘I / O操作。</p>
<h5 id="二级索引如何与聚簇索引相关"><a href="#二级索引如何与聚簇索引相关" class="headerlink" title="二级索引如何与聚簇索引相关"></a>二级索引如何与聚簇索引相关</h5><p>除聚集索引之外的所有索引都称为 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_secondary_index" target="_blank" rel="noopener">辅助索引</a>。在中<code>InnoDB</code>，辅助索引中的每个记录都包含该行的主键列以及为辅助索引指定的列。 <code>InnoDB</code>使用此主键值在聚集索引中搜索行。</p>
<p><code>如果主键较长，则辅助索引将使用更多空间，因此具有短的主键是有利的。</code></p>
<p>有关利用<code>InnoDB</code> 聚簇索引和二级索引的准则，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/optimization-indexes.html" target="_blank" rel="noopener">第8.3节“优化和索引”</a>。</p>
<h4 id="14-6-2-2-InnoDB索引的物理结构"><a href="#14-6-2-2-InnoDB索引的物理结构" class="headerlink" title="14.6.2.2 InnoDB索引的物理结构"></a>14.6.2.2 InnoDB索引的物理结构</h4><p>所有<code>InnoDB</code>索引都是 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_b_tree" target="_blank" rel="noopener">B树</a>，索引记录存储在树的叶子页中。索引页的默认大小为16KB。</p>
<p>将新记录插入<code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_clustered_index" target="_blank" rel="noopener">聚集索引时</a>，请 <code>InnoDB</code>尝试使页面的1/16空闲，以备将来插入和更新索引记录。如果按顺序插入索引记录（升序或降序），则所得到的索引页大约为15/16。如果以随机顺序插入记录，则页面将充满1/2到15/16。如果索引页面的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_fill_factor" target="_blank" rel="noopener">填充因子</a>下降到1/2以下，请 <code>InnoDB</code>尝试收缩索引树以释放页面。</p>
<p>您可以通过 在初始化MySQL实例之前设置配置选项来定义MySQL实例中 所有表空间的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_page_size" target="_blank" rel="noopener">页面大小</a>。定义实例的页面大小后，如果不重新初始化实例就无法更改它。支持的大小为16KB，8KB和4KB。 <code>InnoDB</code><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_page_size" target="_blank" rel="noopener"><code>innodb_page_size</code></a></p>
<p>使用特定<code>InnoDB</code>页面大小的MySQL实例不能使用来自使用不同页面大小的实例的数据文件或日志文件。</p>
<h4 id="14-6-2-3-InnoDB全文索引"><a href="#14-6-2-3-InnoDB全文索引" class="headerlink" title="14.6.2.3 InnoDB全文索引"></a>14.6.2.3 InnoDB全文索引</h4><p><code>FULLTEXT</code>索引是在基于文本的列（<a href="https://dev.mysql.com/doc/refman/5.6/en/char.html" target="_blank" rel="noopener"><code>CHAR</code></a>， <a href="https://dev.mysql.com/doc/refman/5.6/en/char.html" target="_blank" rel="noopener"><code>VARCHAR</code></a>或<a href="https://dev.mysql.com/doc/refman/5.6/en/blob.html" target="_blank" rel="noopener"><code>TEXT</code></a>列）上创建的， 以帮助加快对这些列中包含的数据的查询和DML操作，而忽略定义为停用词的任何单词。</p>
<p>甲<code>FULLTEXT</code>指数被定义为一个的一部分 <a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>说明或使用添加到现有的表<a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a> 或<a href="https://dev.mysql.com/doc/refman/5.6/en/create-index.html" target="_blank" rel="noopener"><code>CREATE INDEX</code></a>。</p>
<p>使用<a href="https://dev.mysql.com/doc/refman/5.6/en/fulltext-search.html#function_match" target="_blank" rel="noopener"><code>MATCH() ... AGAINST</code></a>语法执行全文搜索。有关用法信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/fulltext-search.html" target="_blank" rel="noopener">第12.9节“全文搜索功能”</a>。</p>
<p><code>InnoDB</code> <code>FULLTEXT</code> 本节中的以下主题描述了索引：</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-fulltext-index.html#innodb-fulltext-index-design" target="_blank" rel="noopener">InnoDB全文索引设计</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-fulltext-index.html#innodb-fulltext-index-tables" target="_blank" rel="noopener">InnoDB全文索引表</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-fulltext-index.html#innodb-fulltext-index-cache" target="_blank" rel="noopener">InnoDB全文索引缓存</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-fulltext-index.html#innodb-fulltext-index-docid" target="_blank" rel="noopener">InnoDB全文索引文档ID和FTS_DOC_ID列</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-fulltext-index.html#innodb-fulltext-index-deletion" target="_blank" rel="noopener">InnoDB全文索引删除处理</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-fulltext-index.html#innodb-fulltext-index-transaction" target="_blank" rel="noopener">InnoDB全文索引事务处理</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-fulltext-index.html#innodb-fulltext-index-monitoring" target="_blank" rel="noopener">监控InnoDB全文索引</a></li>
</ul>
<h5 id="InnoDB全文索引设计"><a href="#InnoDB全文索引设计" class="headerlink" title="InnoDB全文索引设计"></a>InnoDB全文索引设计</h5><p><code>InnoDB</code> <code>FULLTEXT</code>索引具有倒排索引设计。倒排索引存储一个单词列表，对于每个单词，存储该单词出现的文档列表。为了支持邻近搜索，每个单词的位置信息也作为字节偏移量存储。</p>
<h5 id="InnoDB全文索引表"><a href="#InnoDB全文索引表" class="headerlink" title="InnoDB全文索引表"></a>InnoDB全文索引表</h5><p>创建<code>InnoDB</code> <code>FULLTEXT</code>索引时，将创建一组索引表，如以下示例所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE opening_lines (</span><br><span class="line">       id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,</span><br><span class="line">       opening_line TEXT(500),</span><br><span class="line">       author VARCHAR(200),</span><br><span class="line">       title VARCHAR(200),</span><br><span class="line">       FULLTEXT idx (opening_line)</span><br><span class="line">       ) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT table_id, name, space from INFORMATION_SCHEMA.INNODB_SYS_TABLES</span><br><span class="line">       WHERE name LIKE 'test/%';</span><br><span class="line">+<span class="comment">----------+----------------------------------------------------+-------+</span></span><br><span class="line">| table_id | name                                               | space |</span><br><span class="line">+<span class="comment">----------+----------------------------------------------------+-------+</span></span><br><span class="line">|      333 | test/FTS_0000000000000147_00000000000001c9_INDEX_1 |   289 |</span><br><span class="line">|      334 | test/FTS_0000000000000147_00000000000001c9_INDEX_2 |   290 |</span><br><span class="line">|      335 | test/FTS_0000000000000147_00000000000001c9_INDEX_3 |   291 |</span><br><span class="line">|      336 | test/FTS_0000000000000147_00000000000001c9_INDEX_4 |   292 |</span><br><span class="line">|      337 | test/FTS_0000000000000147_00000000000001c9_INDEX_5 |   293 |</span><br><span class="line">|      338 | test/FTS_0000000000000147_00000000000001c9_INDEX_6 |   294 |</span><br><span class="line">|      330 | test/FTS_0000000000000147_BEING_DELETED            |   286 |</span><br><span class="line">|      331 | test/FTS_0000000000000147_BEING_DELETED_CACHE      |   287 |</span><br><span class="line">|      332 | test/FTS_0000000000000147_CONFIG                   |   288 |</span><br><span class="line">|      328 | test/FTS_0000000000000147_DELETED                  |   284 |</span><br><span class="line">|      329 | test/FTS_0000000000000147_DELETED_CACHE            |   285 |</span><br><span class="line">|      327 | test/opening_lines                                 |   283 |</span><br><span class="line">+<span class="comment">----------+----------------------------------------------------+-------+</span></span><br></pre></td></tr></table></figure>

<p>前六个表代表倒排索引，并称为辅助索引表。对传入文档进行标记时，各个单词（也称为 “ 标记 ”）与位置信息和关联的文档ID（<code>DOC_ID</code>）一起插入索引表中。根据单词的第一个字符的字符集排序权重，单词在六个索引表中得到完全排序和分区。</p>
<p>倒排索引分为六个辅助索引表，以支持并行索引创建。默认情况下，两个线程对索引表中的单词和相关数据进行标记，排序和插入。线程数可以使用该<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_ft_sort_pll_degree" target="_blank" rel="noopener"><code>innodb_ft_sort_pll_degree</code></a> 选项配置 。<code>FULLTEXT</code>在大型表上创建索引时，请考虑增加线程数 。</p>
<p>辅助索引表名称以前缀 <code>FTS_</code>和后缀 <code>INDEX_*</code>。每个索引表通过索引表名称中与<code>table_id</code>索引表的匹配的十六进制值与索引表相关联。例如，<code>table_id</code>所述的 <code>test/opening_lines</code>表是 <code>327</code>，为此，十六进制值是0x147。如前面的示例所示，十六进制值“ 147 ”出现在与该<code>test/opening_lines</code>表关联的索引表的名称中。</p>
<p>表示的十六进制值<code>index_id</code>的的 <code>FULLTEXT</code>索引也出现在辅助索引表名。例如，在辅助表名称中 <code>test/FTS_0000000000000147_00000000000001c9_INDEX_1</code>，十六进制值<code>1c9</code>的十进制值为457。可以通过查询 表中的该值（457）来识别<code>opening_lines</code>表（<code>idx</code>） 上定义的索引<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-sys-indexes-table.html" target="_blank" rel="noopener"><code>INFORMATION_SCHEMA.INNODB_SYS_INDEXES</code></a>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT index_id, name, table_id, space from INFORMATION_SCHEMA.INNODB_SYS_INDEXES</span><br><span class="line">       WHERE index_id=457;</span><br><span class="line">+<span class="comment">----------+------+----------+-------+</span></span><br><span class="line">| index_id | name | table_id | space |</span><br><span class="line">+<span class="comment">----------+------+----------+-------+</span></span><br><span class="line">|      457 | idx  |      327 |   283 |</span><br><span class="line">+<span class="comment">----------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>

<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a>启用 索引表后，索引表将存储在其自己的表空间中 。如果 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a>禁用此选项，则索引表存储在 <code>InnoDB</code>系统表空间（空间0）中。</p>
<p>注意</p>
<p>由于MySQL 5.6.5中引入的错误，启用索引表后会在<code>InnoDB</code>系统表空间（空间0） 中创建索引表<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a>。该错误已在MySQL 5.6.20和MySQL 5.7.5（Bug＃18635485）中修复。</p>
<p>上一示例中显示的其他索引表称为通用索引表，用于删除处理和存储<code>FULLTEXT</code>索引的内部状态 。与为每个全文索引创建的倒排索引表不同，这组表是在特定表上创建的所有全文索引所共有的。</p>
<p>即使删除了全文索引，也会保留公用辅助表。删除全文索引时，将 <code>FTS_DOC_ID</code>保留为该索引创建的<code>FTS_DOC_ID</code> 列，因为删除该列将需要重建表。需要通用的腋窝表来管理该<code>FTS_DOC_ID</code> 柱。</p>
<ul>
<li><p><code>FTS_*_DELETED</code> 和 <code>FTS_*_DELETED_CACHE</code></p>
<p>包含已删除但其数据尚未从全文索引中删除的文档的文档ID（DOC_ID）。该<code>FTS_*_DELETED_CACHE</code>是内存版本的<code>FTS_*_DELETED</code> 表。</p>
</li>
<li><p><code>FTS_*_BEING_DELETED</code> 和 <code>FTS_*_BEING_DELETED_CACHE</code></p>
<p>包含已删除文档的文档ID（DOC_ID），这些文档的数据当前正在从全文索引中删除。该<code>FTS_*_BEING_DELETED_CACHE</code>表是该 表的内存版本 <code>FTS_*_BEING_DELETED</code>。</p>
</li>
<li><p><code>FTS_*_CONFIG</code></p>
<p>存储有关<code>FULLTEXT</code>索引内部状态的信息 。最重要的是，它存储<code>FTS_SYNCED_DOC_ID</code>，用于标识已解析并刷新到磁盘的文档。在崩溃恢复的情况下， <code>FTS_SYNCED_DOC_ID</code>将使用值来标识尚未刷新到磁盘的文档，以便可以重新解析文档并将其添加回 <code>FULLTEXT</code>索引缓存中。要查看此表中的数据，请查询该 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-ft-config-table.html" target="_blank" rel="noopener"><code>INFORMATION_SCHEMA.INNODB_FT_CONFIG</code></a> 表。</p>
</li>
</ul>
<h5 id="InnoDB全文索引缓存"><a href="#InnoDB全文索引缓存" class="headerlink" title="InnoDB全文索引缓存"></a>InnoDB全文索引缓存</h5><p>插入文档后，将对其进行标记化，并将各个单词和关联的数据插入 <code>FULLTEXT</code>索引。即使对于小型文档，此过程也可能导致在辅助索引表中进行大量小的插入，从而使对这些表的并发访问成为争用点。为避免此问题，请 <code>InnoDB</code>使用<code>FULLTEXT</code> 索引缓存来临时缓存最近插入的行的索引表插入。此内存中的高速缓存结构将保留插入，直到高速缓存已满，然后将其批量刷新到磁盘（至辅助索引表）。您可以查询该 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-ft-index-cache-table.html" target="_blank" rel="noopener"><code>INFORMATION_SCHEMA.INNODB_FT_INDEX_CACHE</code></a> 表以查看最近插入的行的标记化数据。</p>
<p>缓存和批处理刷新行为避免了对辅助索引表的频繁更新，这可能导致在繁忙的插入和更新期间并发访问问题。批处理技术还避免了同一单词的多次插入，并最大程度地减少了重复输入。代替单独刷新每个单词，对同一单词的插入进行合并并作为单个条目刷新到磁盘，从而提高了插入效率，同时保持了尽可能小的辅助索引表。</p>
<p>该<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_ft_cache_size" target="_blank" rel="noopener"><code>innodb_ft_cache_size</code></a> 变量用于配置全文索引缓存大小（基于每个表），这会影响刷新全文索引缓存的频率。您还可以使用该<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_ft_total_cache_size" target="_blank" rel="noopener"><code>innodb_ft_total_cache_size</code></a> 选项为给定实例中的所有表定义全局全文索引高速缓存大小限制 。</p>
<p>全文索引缓存存储与辅助索引表相同的信息。但是，全文索引缓存仅缓存最近插入的行的标记化数据。查询时，已刷新到磁盘（全文辅助表）的数据不会带回到全文索引缓存中。直接查询辅助索引表中的数据，并将辅助索引表中的结果与全文索引缓存中的结果合并，然后再返回。</p>
<h5 id="InnoDB全文索引文档ID和FTS-DOC-ID列"><a href="#InnoDB全文索引文档ID和FTS-DOC-ID列" class="headerlink" title="InnoDB全文索引文档ID和FTS_DOC_ID列"></a>InnoDB全文索引文档ID和FTS_DOC_ID列</h5><p><code>InnoDB</code>使用称为文档ID（<code>DOC_ID</code>）的唯一文档标识符将全文索引中的单词映射到单词出现的文档记录。映射需要<code>FTS_DOC_ID</code> 在索引表上有一列。如果<code>FTS_DOC_ID</code> 未定义列，则在创建全文索引时<code>InnoDB</code>自动添加一个隐藏的<code>FTS_DOC_ID</code>列。下面的示例演示了此行为。</p>
<p>下表定义不包括 <code>FTS_DOC_ID</code>列：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE opening_lines (</span><br><span class="line">       id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,</span><br><span class="line">       opening_line TEXT(500),</span><br><span class="line">       author VARCHAR(200),</span><br><span class="line">       title VARCHAR(200)</span><br><span class="line">       ) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure>

<p>当使用<code>CREATE FULLTEXT INDEX</code>语法在表上创建全文索引时，将 返回警告，报告<code>InnoDB</code>正在重建表以添加<code>FTS_DOC_ID</code> 列。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE FULLTEXT INDEX idx ON opening_lines(opening_line);</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.19 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 1</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW WARNINGS;</span><br><span class="line">+<span class="comment">---------+------+--------------------------------------------------+</span></span><br><span class="line">| Level   | Code | Message                                          |</span><br><span class="line">+<span class="comment">---------+------+--------------------------------------------------+</span></span><br><span class="line">| Warning |  124 | InnoDB rebuilding table to add column FTS_DOC_ID |</span><br><span class="line">+<span class="comment">---------+------+--------------------------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>当用于<a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>向没有<code>FTS_DOC_ID</code>列的表中添加全文索引时，将 返回相同的警告 。如果您一次创建全文索引<a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>并且未指定<code>FTS_DOC_ID</code>列，则 <code>InnoDB</code>添加隐藏 <code>FTS_DOC_ID</code>列，而不会发出警告。</p>
<p>与<code>FTS_DOC_ID</code>在<a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>已经加载了数据的表上创建全文索引相比，在时间上定义列 要便宜得多。如果<code>FTS_DOC_ID</code> 在加载数据之前在表上定义了列，则不必重建表及其索引即可添加新列。如果您不关心<code>CREATE FULLTEXT INDEX</code>性能，请忽略该<code>FTS_DOC_ID</code>列来 <code>InnoDB</code>为您创建性能 。 <code>InnoDB</code>创建隐藏的 <code>FTS_DOC_ID</code>列以及<code>FTS_DOC_ID_INDEX</code>该<code>FTS_DOC_ID</code>列上的唯一索引（） 。如果要创建自己的<code>FTS_DOC_ID</code>列，则必须将该列定义为<code>BIGINT UNSIGNED NOT NULL</code>并命名为 <code>FTS_DOC_ID</code> （全部大写），如以下示例所示：</p>
<p>注意</p>
<p>该<code>FTS_DOC_ID</code>列不必定义为<code>AUTO_INCREMENT</code>列，但 <code>AUTO_INCREMENT</code>可以使加载数据更加容易。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE opening_lines (</span><br><span class="line">       FTS_DOC_ID BIGINT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,</span><br><span class="line">       opening_line TEXT(500),</span><br><span class="line">       author VARCHAR(200),</span><br><span class="line">       title VARCHAR(200)</span><br><span class="line">       ) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure>

<p>如果选择自己定义<code>FTS_DOC_ID</code>列，则您有责任管理该列，以免出现空值或重复值。<code>FTS_DOC_ID</code>值不能重复使用，这意味着<code>FTS_DOC_ID</code> 值必须不断增加。</p>
<p>（可选）您可以<code>FTS_DOC_ID_INDEX</code>在<code>FTS_DOC_ID</code>列上创建所需的唯一 （全部大写） 。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE UNIQUE INDEX FTS_DOC_ID_INDEX on opening_lines(FTS_DOC_ID);</span><br></pre></td></tr></table></figure>

<p>如果您未创建<code>FTS_DOC_ID_INDEX</code>， <code>InnoDB</code>则会自动创建。</p>
<p>在MySQL 5.6.31之前，最大使用<code>FTS_DOC_ID</code>值与新 <code>FTS_DOC_ID</code>值之间的允许间隙 为10000。在MySQL 5.6.31及更高版本中，允许间隙为65535。</p>
<p>为避免重建表，<code>FTS_DOC_ID</code> 删除全文索引时将保留该列。</p>
<h5 id="InnoDB全文索引删除处理"><a href="#InnoDB全文索引删除处理" class="headerlink" title="InnoDB全文索引删除处理"></a>InnoDB全文索引删除处理</h5><p>删除具有全文索引列的记录可能会导致辅助索引表中的许多小删除，从而使对这些表的并发访问成为争用点。为避免此问题，每当从索引表中删除<code>DOC_ID</code>记录时，已删除文档的Document ID（）就会记录在特殊<code>FTS_*_DELETED</code>表中，并且索引记录仍保留在全文索引中。返回查询结果之前，<code>FTS_*_DELETED</code>表格用于过滤删除的文档ID。这种设计的好处是删除既快速又便宜。缺点是删除记录后不会立即减小索引的大小。要删除已删除记录的全文索引条目，请<code>OPTIMIZE TABLE</code>在带有索引的表上 运行<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_optimize_fulltext_only" target="_blank" rel="noopener"><code>innodb_optimize_fulltext_only=ON</code></a> 以重建全文索引。有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/fulltext-fine-tuning.html#fulltext-optimize" target="_blank" rel="noopener">优化InnoDB全文索引</a>。</p>
<h5 id="InnoDB全文索引事务处理"><a href="#InnoDB全文索引事务处理" class="headerlink" title="InnoDB全文索引事务处理"></a>InnoDB全文索引事务处理</h5><p><code>InnoDB</code> <code>FULLTEXT</code>索引由于具有缓存和批处理行为，因此具有特殊的事务处理特性。具体来说，<code>FULLTEXT</code>索引的更新和插入是在事务提交时处理的，这意味着 <code>FULLTEXT</code>搜索只能看到提交的数据。下面的示例演示了此行为。该 <code>FULLTEXT</code>搜索只返回插入的行被提交之后的结果。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE opening_lines (</span><br><span class="line">       id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,</span><br><span class="line">       opening_line TEXT(500),</span><br><span class="line">       author VARCHAR(200),</span><br><span class="line">       title VARCHAR(200),</span><br><span class="line">       FULLTEXT idx (opening_line)</span><br><span class="line">       ) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">mysql&gt; BEGIN;</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO opening_lines(opening_line,author,title) VALUES</span><br><span class="line">       ('<span class="keyword">Call</span> me Ishmael.<span class="string">','</span>Herman Melville<span class="string">','</span>Moby-Dick<span class="string">'),</span></span><br><span class="line"><span class="string">       ('</span>A screaming comes across the sky.<span class="string">','</span>Thomas Pynchon<span class="string">','</span>Gravity\<span class="string">'s Rainbow'</span>),</span><br><span class="line">       (<span class="string">'I am an invisible man.'</span>,<span class="string">'Ralph Ellison'</span>,<span class="string">'Invisible Man'</span>),</span><br><span class="line">       (<span class="string">'Where now? Who now? When now?'</span>,<span class="string">'Samuel Beckett'</span>,<span class="string">'The Unnamable'</span>),</span><br><span class="line">       (<span class="string">'It was love at first sight.'</span>,<span class="string">'Joseph Heller'</span>,<span class="string">'Catch-22'</span>),</span><br><span class="line">       (<span class="string">'All this happened, more or less.'</span>,<span class="string">'Kurt Vonnegut'</span>,<span class="string">'Slaughterhouse-Five'</span>),</span><br><span class="line">       (<span class="string">'Mrs. Dalloway said she would buy the flowers herself.'</span>,<span class="string">'Virginia Woolf'</span>,<span class="string">'Mrs. Dalloway'</span>),</span><br><span class="line">       (<span class="string">'It was a pleasure to burn.'</span>,<span class="string">'Ray Bradbury'</span>,<span class="string">'Fahrenheit 451'</span>);</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT COUNT(*) FROM opening_lines WHERE MATCH(opening_line) AGAINST('Ishmael');</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| COUNT(*) |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">|        0 |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; COMMIT;</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT COUNT(*) FROM opening_lines WHERE MATCH(opening_line) AGAINST('Ishmael');</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| COUNT(*) |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">|        1 |</span><br><span class="line">+<span class="comment">----------+</span></span><br></pre></td></tr></table></figure>

<h5 id="监控InnoDB全文索引"><a href="#监控InnoDB全文索引" class="headerlink" title="监控InnoDB全文索引"></a>监控InnoDB全文索引</h5><p>您可以<code>InnoDB</code> <code>FULLTEXT</code>通过查询下<code>INFORMATION_SCHEMA</code> 表来监视和检查索引的特殊文本处理方面：</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-ft-config-table.html" target="_blank" rel="noopener"><code>INNODB_FT_CONFIG</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-ft-index-table-table.html" target="_blank" rel="noopener"><code>INNODB_FT_INDEX_TABLE</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-ft-index-cache-table.html" target="_blank" rel="noopener"><code>INNODB_FT_INDEX_CACHE</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-ft-default-stopword-table.html" target="_blank" rel="noopener"><code>INNODB_FT_DEFAULT_STOPWORD</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-ft-deleted-table.html" target="_blank" rel="noopener"><code>INNODB_FT_DELETED</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-ft-being-deleted-table.html" target="_blank" rel="noopener"><code>INNODB_FT_BEING_DELETED</code></a></li>
</ul>
<p>您还可以<code>FULLTEXT</code>通过查询<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-sys-indexes-table.html" target="_blank" rel="noopener"><code>INNODB_SYS_INDEXES</code></a>和 查看索引和表的 基本信息 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-sys-tables-table.html" target="_blank" rel="noopener"><code>INNODB_SYS_TABLES</code></a>。</p>
<p>有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-information-schema-fulltext_index-tables.html" target="_blank" rel="noopener">第14.15.4节“ InnoDB INFORMATION_SCHEMA FULLTEXT索引表”</a>。</p>
<br>

<h3 id="14-6-3-Tablespace"><a href="#14-6-3-Tablespace" class="headerlink" title="14.6.3 Tablespace"></a>14.6.3 Tablespace</h3><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-system-tablespace.html" target="_blank" rel="noopener">14.6.3.1系统表空间</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-file-per-table-tablespaces.html" target="_blank" rel="noopener">14.6.3.2每表文件表空间</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-undo-tablespaces.html" target="_blank" rel="noopener">14.6.3.3撤消表空间</a></li>
</ul>
<p>本节涵盖与<code>InnoDB</code> 表空间有关的主题。</p>
<h4 id="14-6-3-1系统表空间"><a href="#14-6-3-1系统表空间" class="headerlink" title="14.6.3.1系统表空间"></a>14.6.3.1系统表空间</h4><p>系统表空间是<code>InnoDB</code>数据字典，Doublewrite Buffer，Change Buffer和 Undo Log的存储区 。如果在系统表空间中创建表，而不是在每个表文件中创建表，则它也可能包含表和索引数据。</p>
<p>系统表空间可以具有一个或多个数据文件。默认情况下，<code>ibdata1</code>在数据目录中创建一个名为的系统表空间数据文件 。系统表空间数据文件的大小和数量由<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_data_file_path" target="_blank" rel="noopener"><code>innodb_data_file_path</code></a>启动选项定义。有关配置信息，请参阅《 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-init-startup-configuration.html#innodb-startup-data-file-configuration" target="_blank" rel="noopener">系统表空间数据文件配置》</a>。</p>
<p>本节中以下主题下提供了有关系统表空间的其他信息：</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-system-tablespace.html#innodb-resize-system-tablespace" target="_blank" rel="noopener">调整系统表空间的大小</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-system-tablespace.html#innodb-raw-devices" target="_blank" rel="noopener">对系统表空间使用原始磁盘分区</a></li>
</ul>
<h5 id="调整系统表空间的大小"><a href="#调整系统表空间的大小" class="headerlink" title="调整系统表空间的大小"></a>调整系统表空间的大小</h5><p>本节介绍如何增加或减少系统表空间的大小。</p>
<h6 id="增加系统表空间的大小"><a href="#增加系统表空间的大小" class="headerlink" title="增加系统表空间的大小"></a>增加系统表空间的大小</h6><p>增加系统表空间大小的最简单方法是将其配置为自动扩展。为此，请<code>autoextend</code>为设置中的最后一个数据文件指定 属性<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_data_file_path" target="_blank" rel="noopener"><code>innodb_data_file_path</code></a> ，然后重新启动服务器。例如：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">innodb_data_file_path</span>=ibdata1:<span class="number">10</span>MB:autoextend</span><br></pre></td></tr></table></figure>

<p>当<code>autoextend</code>指定的属性，则数据文件自动大小由8MB增量因为需要空间增加。所述 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_autoextend_increment" target="_blank" rel="noopener"><code>innodb_autoextend_increment</code></a> 可变控制增量大小。</p>
<p>您还可以通过添加另一个数据文件来增加系统表空间的大小。为此：</p>
<ol>
<li>停止MySQL服务器。</li>
<li>如果<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_data_file_path" target="_blank" rel="noopener"><code>innodb_data_file_path</code></a> 使用<code>autoextend</code> 属性定义了设置中的最后一个数据文件，则将 其删除，然后修改size属性以反映当前数据文件的大小。要确定要指定的适当数据文件大小，请检查文件系统中的文件大小，并将该值四舍五入为最接近的MB值，其中MB等于1024 x 1024。</li>
<li>将新的数据文件追加到 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_data_file_path" target="_blank" rel="noopener"><code>innodb_data_file_path</code></a> 设置中，可以选择指定 <code>autoextend</code>属性。该 <code>autoextend</code>属性只能在最后一个数据文件中指定 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_data_file_path" target="_blank" rel="noopener"><code>innodb_data_file_path</code></a> 的设置。</li>
<li>启动MySQL服务器。</li>
</ol>
<p>例如，此表空间具有一个自动扩展数据文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innodb_data_home_dir =</span><br><span class="line">innodb_data_file_path = /ibdata/ibdata1:10M:autoextend</span><br></pre></td></tr></table></figure>

<p>假设数据文件随着时间增长到988MB。这是<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_data_file_path" target="_blank" rel="noopener"><code>innodb_data_file_path</code></a> 修改大小属性以反映当前数据文件大小之后，并指定新的50MB自动扩展数据文件之后的设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innodb_data_home_dir =</span><br><span class="line">innodb_data_file_path = /ibdata/ibdata1:988M;/disk2/ibdata2:50M:autoextend</span><br></pre></td></tr></table></figure>

<p>添加新数据文件时，请勿指定现有文件名。<code>InnoDB</code>启动服务器时，将创建并初始化新的数据文件。</p>
<p>注意：</p>
<blockquote>
<p> 您不能通过更改其大小属性来增加现有系统表空间数据文件的大小。例如，在启动服务器时，将<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_data_file_path" target="_blank" rel="noopener"><code>innodb_data_file_path</code></a>设置从更改 <code>ibdata1:10M:autoextend</code>为 <code>ibdata1:12M:autoextend</code>会产生以下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; [ERROR] [MY-012263] [InnoDB] The Auto-extending innodb_system </span><br><span class="line">&gt; data file &apos;./ibdata1&apos; is of a different size 640 pages (rounded down to MB) than </span><br><span class="line">&gt; specified in the .cnf file: initial 768 pages, max 0 (relevant if non-zero) pages!</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>该错误表明现有数据文件大小（以<code>InnoDB</code>页表示）与配置文件中指定的大小不同。如果遇到此错误，请恢复先前的 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_data_file_path" target="_blank" rel="noopener"><code>innodb_data_file_path</code></a> 设置，然后参考系统表空间调整大小说明。</p>
<p><code>InnoDB</code>页面大小由<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_page_size" target="_blank" rel="noopener"><code>innodb_page_size</code></a>变量定义 。默认值为16384字节。</p>
</blockquote>
<h6 id="减少InnoDB系统表空间的大小"><a href="#减少InnoDB系统表空间的大小" class="headerlink" title="减少InnoDB系统表空间的大小"></a>减少InnoDB系统表空间的大小</h6><p>您不能从系统表空间中删除数据文件。要减小系统表空间大小，请使用以下过程：</p>
<ol>
<li><p>使用<a href="https://dev.mysql.com/doc/refman/5.6/en/mysqldump.html" target="_blank" rel="noopener"><strong>mysqldump</strong></a>转储所有 <code>InnoDB</code>表，包括 模式中的<code>InnoDB</code>表 <code>mysql</code>。使用以下查询标识 模式中的<code>InnoDB</code>表 <code>mysql</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT TABLE_NAME from INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA='mysql' and ENGINE='InnoDB';</span><br><span class="line">+<span class="comment">----------------------+</span></span><br><span class="line">| table_name           |</span><br><span class="line">+<span class="comment">----------------------+</span></span><br><span class="line">| innodb_index_stats   |</span><br><span class="line">| innodb_table_stats   |</span><br><span class="line">| slave_master_info    |</span><br><span class="line">| slave_relay_log_info |</span><br><span class="line">| slave_worker_info    |</span><br><span class="line">+<span class="comment">----------------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止服务器。</p>
</li>
<li><p>删除所有现有的表空间文件（<code>*.ibd</code>），包括 <code>ibdata</code>和<code>ib_log</code> 文件。不要忘记删除 架构<code>*.ibd</code> 中表的文件<code>mysql</code>。</p>
</li>
<li><p>删除表的所有<code>.frm</code>文件 <code>InnoDB</code>。</p>
</li>
<li><p>为新系统表空间配置数据文件。请参阅 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-init-startup-configuration.html#innodb-startup-data-file-configuration" target="_blank" rel="noopener">系统表空间数据文件配置</a>。</p>
</li>
<li><p>重新启动服务器。</p>
</li>
<li><p>导入转储文件。</p>
</li>
</ol>
<p>注意</p>
<p>如果您的数据库仅使用<code>InnoDB</code> 引擎，则转储<strong>所有</strong>数据库，停止服务器，删除所有数据库和<code>InnoDB</code>日志文件，重新启动服务器以及导入转储文件可能更简单 。</p>
<h5 id="对系统表空间使用原始磁盘分区"><a href="#对系统表空间使用原始磁盘分区" class="headerlink" title="对系统表空间使用原始磁盘分区"></a>对系统表空间使用原始磁盘分区</h5><p>您可以将原始磁盘分区用作<code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_system_tablespace" target="_blank" rel="noopener">系统表空间</a>中的数据文件 。此技术可在Windows以及某些Linux和Unix系统上启用无缓冲I / O，而不会增加文件系统开销。在有和没有原始分区的情况下执行测试，以验证此更改是否确实提高了系统性能。</p>
<p>使用原始磁盘分区时，请确保运行MySQL服务器的用户ID具有该分区的读写特权。例如，如果您以<code>mysql</code>用户身份运行服务器 ，则分区必须可由读取和写入<code>mysql</code>。如果使用该<a href="https://dev.mysql.com/doc/refman/5.6/en/server-options.html#option_mysqld_memlock" target="_blank" rel="noopener"><code>--memlock</code></a>选项运行服务器，则该服务器必须以身份运行<code>root</code>，因此该分区必须可由读取和写入<code>root</code>。</p>
<p>下述步骤涉及选项文件的修改。有关更多信息，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/option-files.html" target="_blank" rel="noopener">第4.2.2.2节“使用选项文件”</a>。</p>
<h6 id="在Linux和Unix系统上分配原始磁盘分区"><a href="#在Linux和Unix系统上分配原始磁盘分区" class="headerlink" title="在Linux和Unix系统上分配原始磁盘分区"></a>在Linux和Unix系统上分配原始磁盘分区</h6><ol>
<li><p>When you create a new data file, specify the keyword <code>newraw</code> immediately after the data file size for the <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_data_file_path" target="_blank" rel="noopener"><code>innodb_data_file_path</code></a> option. The partition must be at least as large as the size that you specify. Note that 1MB in <code>InnoDB</code> is 1024 × 1024 bytes, whereas 1MB in disk specifications usually means 1,000,000 bytes.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_data_home_dir=</span><br><span class="line">innodb_data_file_path=/dev/hdd1:3Gnewraw;/dev/hdd2:2Gnewraw</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新启动服务器。<code>InnoDB</code>注意 <code>newraw</code>关键字并初始化新分区。但是，请不要创建或更改任何 <code>InnoDB</code>表。否则，当您下次重新启动服务器时，将<code>InnoDB</code> 重新初始化分区，并且所做的更改将丢失。（为安全起见，<code>InnoDB</code>当<code>newraw</code>指定任何分区时，防止用户修改数据 。）</p>
</li>
<li><p>后<code>InnoDB</code>已初始化新的分区，停止服务器，更改<code>newraw</code> 数据文件规范<code>raw</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_data_home_dir=</span><br><span class="line">innodb_data_file_path=/dev/hdd1:3Graw;/dev/hdd2:2Graw</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新启动服务器。<code>InnoDB</code>现在允许进行更改。</p>
</li>
</ol>
<h6 id="在Windows上分配原始磁盘分区"><a href="#在Windows上分配原始磁盘分区" class="headerlink" title="在Windows上分配原始磁盘分区"></a>在Windows上分配原始磁盘分区</h6><p>在Windows系统上，适用于Linux和Unix系统的相同步骤和随附的准则，只是<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_data_file_path" target="_blank" rel="noopener"><code>innodb_data_file_path</code></a>Windows上的 设置略有不同。</p>
<ol>
<li><p>创建新的数据文件时，请在<code>newraw</code>该<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_data_file_path" target="_blank" rel="noopener"><code>innodb_data_file_path</code></a> 选项的数据文件大小后立即 指定关键字 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_data_home_dir=</span><br><span class="line">innodb_data_file_path=//./D::10Gnewraw</span><br></pre></td></tr></table></figure>

<p>在<code>//./</code>相当于Windows语法<code>\\.\</code>用于访问物理驱动器。在上面的示例中，<code>D:</code>是分区的驱动器号。</p>
</li>
<li><p>重新启动服务器。<code>InnoDB</code>注意 <code>newraw</code>关键字并初始化新分区。</p>
</li>
<li><p>后<code>InnoDB</code>已初始化新的分区，停止服务器，更改<code>newraw</code> 数据文件规范<code>raw</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_data_home_dir=</span><br><span class="line">innodb_data_file_path=//./D::10Graw</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新启动服务器。<code>InnoDB</code>现在允许进行更改。</p>
</li>
</ol>
<h4 id="14-6-3-2-File-Per-Table-Tablespaces"><a href="#14-6-3-2-File-Per-Table-Tablespaces" class="headerlink" title="14.6.3.2 File-Per-Table-Tablespaces"></a>14.6.3.2 File-Per-Table-Tablespaces</h4><p>每表文件表空间包含单个<code>InnoDB</code>表的数据和索引 ，并存储在文件系统中自己的数据文件中。</p>
<p>每节文件表空间特征在本节的以下主题下描述：</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-file-per-table-tablespaces.html#innodb-file-per-table-configuration" target="_blank" rel="noopener">每表文件表空间配置</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-file-per-table-tablespaces.html#innodb-file-per-table-data-files" target="_blank" rel="noopener">每表文件表空间数据文件</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-file-per-table-tablespaces.html#innodb-file-per-table-advantages" target="_blank" rel="noopener">每表文件表空间的优势</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-file-per-table-tablespaces.html#innodb-file-per-table-disadvantages" target="_blank" rel="noopener">每表文件表空间的缺点</a></li>
</ul>
<h5 id="每表文件表空间配置"><a href="#每表文件表空间配置" class="headerlink" title="每表文件表空间配置"></a>每表文件表空间配置</h5><p><code>InnoDB</code>默认情况下，在每个表文件表空间中创建表。此行为由<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a>变量控制 。禁用在系统表空间中创建表的<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a> 原因<code>InnoDB</code>。</p>
<p>的<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a> 设置可以在选项文件来指定，或者使用在运行时配置的 <a href="https://dev.mysql.com/doc/refman/5.6/en/set-variable.html" target="_blank" rel="noopener"><code>SET GLOBAL</code></a>语句。在运行时更改设置需要足够的特权来设置全局系统变量。请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/system-variable-privileges.html" target="_blank" rel="noopener">第5.1.8.1节“系统变量特权”</a>。</p>
<p>选项文件：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">innodb_file_per_table</span>=<span class="literal">ON</span></span><br></pre></td></tr></table></figure>

<p><a href="https://dev.mysql.com/doc/refman/5.6/en/set-variable.html" target="_blank" rel="noopener"><code>SET GLOBAL</code></a>在运行时 使用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL innodb_file_per_table=ON;</span><br></pre></td></tr></table></figure>

<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a>在MySQL 5.6和更高版本中默认启用。如果需要考虑与MySQL早期版本的向后兼容性，则可以考虑禁用它。</p>
<p>警告</p>
<p>禁用 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a> 可防止表复制<a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>操作将驻留在系统表空间中的表隐式移动到每个表文件表空间。表复制<a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>操作将使用当前<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a> 设置重新创建表。添加或删除二级索引时，此行为不适用，也不适用于 <a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>使用该<code>INPLACE</code>算法的操作。</p>
<h5 id="每表文件表空间数据文件"><a href="#每表文件表空间数据文件" class="headerlink" title="每表文件表空间数据文件"></a>每表文件表空间数据文件</h5><p><code>.idb</code>在MySQL数据目录下的架构目录 中的数据文件中，将创建一个每表文件表空间 。该<code>.ibd</code>文件以表（<code>*</code>table_name<code>*.ibd</code>）命名。例如，在MySQL数据目录下的目录中<code>test.t1</code> 创建表的数据文件<code>test</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE test;  </span><br><span class="line">  </span><br><span class="line">mysql&gt; CREATE TABLE t1 (</span><br><span class="line">   id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">   name VARCHAR(100) </span><br><span class="line"> ) ENGINE = InnoDB; </span><br><span class="line"> </span><br><span class="line">shell&gt; cd /path/to/mysql/data/test</span><br><span class="line">shell&gt; ls </span><br><span class="line">t1.ibd</span><br></pre></td></tr></table></figure>

<p>您可以使用该语句的<code>DATA DIRECTORY</code>子句 <a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>在数据目录外部隐式创建每表文件表空间数据文件。有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-create-table-external.html" target="_blank" rel="noopener">第14.6.1.2节“在外部创建表”</a>。</p>
<h5 id="每表文件表空间的优势"><a href="#每表文件表空间的优势" class="headerlink" title="每表文件表空间的优势"></a>每表文件表空间的优势</h5><p>每表文件表空间比共享系统表空间具有以下优点。</p>
<ul>
<li>截断或删除每个表文件表空间中创建的表后，磁盘空间将返回操作系统。截断或删除存储在系统表空间中的表会在系统表空间内创建可用空间，该可用空间仅可用于 <code>InnoDB</code>数据。换句话说，在表被截断或删除后，系统表空间的大小不会缩小。</li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a> 对驻留在系统表空间中的表进行表 复制操作可能会增加表空间占用的磁盘空间量。此类操作可能需要与表中的数据加索引一样多的额外空间。该空间不会像每个表文件表空间那样释放回操作系统。</li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/truncate-table.html" target="_blank" rel="noopener"><code>TRUNCATE TABLE</code></a> 在每个表文件表空间中的表上执行时，性能会更好。</li>
<li>可以在单独的存储设备上创建每表文件表空间数据文件，以进行I / O优化，空间管理或备份。请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-create-table-external.html" target="_blank" rel="noopener">第14.6.1.2节“在外部创建表”</a>。</li>
<li>您可以从另一个MySQL实例导入位于每个表文件表空间中的表。请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-table-import.html" target="_blank" rel="noopener">第14.6.1.3节“导入InnoDB表”</a>。</li>
<li>在每表文件表空间中创建的表使用梭子鱼文件格式。请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-file-format.html" target="_blank" rel="noopener">第14.10节“ InnoDB文件格式管理”</a>。梭子鱼文件格式启用<code>DYNAMIC</code>与<code>COMPRESSED</code> 行格式关联的功能 。请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-row-format.html" target="_blank" rel="noopener">第14.11节“ InnoDB行格式”</a>。</li>
<li>当发生数据损坏，备份或二进制日志不可用或无法重新启动MySQL服务器实例时，存储在单个表空间数据文件中的表可以节省时间并提高成功恢复的机会。</li>
<li>您可以使用MySQL Enterprise Backup快速备份或还原在每表文件表空间中创建的表，而不会中断其他<code>InnoDB</code> 表的使用。这对于具有不同备份计划的表或需要较少备份频率的表很有用。有关详细信息，请参见 <a href="https://dev.mysql.com/doc/mysql-enterprise-backup/3.12/en/partial.html" target="_blank" rel="noopener">进行部分备份</a>。</li>
<li>每表文件表空间允许通过监视表空间数据文件的大小来监视文件系统上的表大小。</li>
<li>当通用的Linux文件系统不允许并发写入到一个单一的文件，如系统表空间的数据文件 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_flush_method" target="_blank" rel="noopener"><code>innodb_flush_method</code></a>设置为<code>O_DIRECT</code>。因此，结合使用每表文件表空间和此设置时，可能会提高性能。</li>
<li>共享系统表空间中的表包含<code>InnoDB</code>64TB表空间大小限制，该表包含数据字典和Undo Log等其他结构。相比之下，每个表的每个文件表空间都有64TB的大小限制，这为单个表的大小增加提供了足够的空间。</li>
</ul>
<h5 id="每表文件表空间的缺点"><a href="#每表文件表空间的缺点" class="headerlink" title="每表文件表空间的缺点"></a>每表文件表空间的缺点</h5><p>与共享系统表空间相比，每表文件表空间具有以下缺点。</p>
<ul>
<li>使用每表文件表空间，每个表可能有未使用的空间，只能由同一表的行使用，如果管理不当，则会浪费空间。</li>
<li><code>fsync</code>对每个表的多个数据文件而不是共享系统表空间数据文件执行操作。由于 <code>fsync</code>操作是针对每个文件的，因此无法合并针对多个表的写操作，这可能导致更多的<code>fsync</code> 操作总数。</li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/mysqld.html" target="_blank" rel="noopener"><strong>mysqld</strong></a>必须为每个表文件空间保留一个打开的文件句柄，如果每个表文件空间中有许多表，则可能会影响性能。</li>
<li>每个表都有其自己的数据文件时，需要更多的文件描述符。</li>
<li>可能存在更多碎片，这可能会影响 <a href="https://dev.mysql.com/doc/refman/5.6/en/drop-table.html" target="_blank" rel="noopener"><code>DROP TABLE</code></a>表扫描性能。但是，如果管理碎片，则每表文件表空间可以提高这些操作的性能。</li>
<li>删除驻留在每个表文件表空间中的表时，将扫描缓冲池，对于大型缓冲池可能要花费几秒钟。使用宽泛的内部锁定执行扫描，这可能会延迟其他操作。</li>
<li>该<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_autoextend_increment" target="_blank" rel="noopener"><code>innodb_autoextend_increment</code></a> 变量定义用于在自动扩展系统表空间文件变满时扩展其大小的增量大小，该 变量不适用于每表文件表空间文件，无论<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_autoextend_increment" target="_blank" rel="noopener"><code>innodb_autoextend_increment</code></a> 设置如何，该文件都将自动扩展 。每个表的初始文件表扩展名很少，之后扩展名以4MB为增量。</li>
</ul>
<h4 id="14-6-3-3-Undo-Tablespaces"><a href="#14-6-3-3-Undo-Tablespaces" class="headerlink" title="14.6.3.3 Undo Tablespaces"></a>14.6.3.3 Undo Tablespaces</h4><p>撤消表空间包含Undo Log，Undo Log是Undo Log记录的集合，其中包含有关如何通过事务撤消对聚集索引记录的最新更改的信息。Undo Log段中包含Undo Log。该 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_rollback_segments" target="_blank" rel="noopener"><code>innodb_rollback_segments</code></a>变量定义分配给每个撤消表空间的回滚段的数量。</p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_undo_log" target="_blank" rel="noopener">Undo Log</a>可以存储在一个或多个<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_undo_tablespace" target="_blank" rel="noopener">撤消表空间中，</a>而不是 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_system_tablespace" target="_blank" rel="noopener">系统表空间中</a>。此布局与默认配置不同，在默认配置中，Undo Log位于<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_system_tablespace" target="_blank" rel="noopener">系统表空间中</a>。Undo Log的I / O模式使撤消表空间成为<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_ssd" target="_blank" rel="noopener">SSD</a>存储的理想候选者 ，同时将系统表空间保留在硬盘存储上。</p>
<p>所使用的撤消表空间的数量<code>InnoDB</code> 由<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_undo_tablespaces" target="_blank" rel="noopener"><code>innodb_undo_tablespaces</code></a> 配置选项控制 。仅在初始化MySQL实例时才能配置此选项。此后无法更改。</p>
<p>撤消表空间和这些表空间内的各个 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_segment" target="_blank" rel="noopener">段</a>不能删除。</p>
<h5 id="配置撤消表空间"><a href="#配置撤消表空间" class="headerlink" title="配置撤消表空间"></a>配置撤消表空间</h5><p>要为MySQL实例配置撤消表空间，请执行以下步骤。假定您在将配置部署到生产系统之前正在测试实例上执行该过程。</p>
<p>重要</p>
<p>撤消表空间的数量只能在初始化MySQL实例时配置，并且在实例生命周期内是固定的。</p>
<ol>
<li><p>使用<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_undo_directory" target="_blank" rel="noopener"><code>innodb_undo_directory</code></a> 配置选项为撤消表空间指定<u><strong>目录位置</strong></u> 。如果未指定目录位置，则在数据目录中创建撤消表空间。</p>
</li>
<li><p>使用<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_rollback_segments" target="_blank" rel="noopener"><code>innodb_rollback_segments</code></a> 配置选项定义回滚段的数量 。从一个相对较低的值开始，然后随着时间的推移逐渐增加它，以检查对性能的影响。默认设置为 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_rollback_segments" target="_blank" rel="noopener"><code>innodb_rollback_segments</code></a>128，这也是最大值。</p>
<p>一个回退段始终分配给系统表空间。因此，要将回滚段分配给撤消表空间，请设置 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_rollback_segments" target="_blank" rel="noopener"><code>innodb_rollback_segments</code></a>为大于1的值。例如，如果您有两个撤消表空间，则设置 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_rollback_segments" target="_blank" rel="noopener"><code>innodb_rollback_segments</code></a>为3可以为两个撤消表空间中的每一个分配一个回滚段。回滚段以循环方式分布在撤消表空间中。</p>
<p>配置单独的撤消表空间时，系统表空间中的回滚段将变为非活动状态。</p>
</li>
<li><p>使用该<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_undo_tablespaces" target="_blank" rel="noopener"><code>innodb_undo_tablespaces</code></a> 选项定义撤消表空间的数量 。在MySQL实例的生命周期中，指定的还原表空间数量是固定的，因此，如果不确定最佳值，请从高端进行估算。</p>
</li>
<li><p>使用您选择的选项值创建一个新的MySQL测试实例。</p>
</li>
<li><p>在测试实例上使用实际的工作负载，并使用与生产服务器类似的数据量来测试配置。</p>
</li>
<li><p>对I / O密集型工作负载的性能进行基准测试。</p>
</li>
<li><p>定期增加价值 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_rollback_segments" target="_blank" rel="noopener"><code>innodb_rollback_segments</code></a> 并重新运行性能测试，直到I / O性能没有进一步提高。</p>
</li>
</ol>
<br>

<h3 id="14-6-4-InnoDB数据字典"><a href="#14-6-4-InnoDB数据字典" class="headerlink" title="14.6.4 InnoDB数据字典"></a>14.6.4 InnoDB数据字典</h3><p>所述<code>InnoDB</code>数据字典由包含元数据的用于跟踪对象的如<u><strong>表，索引，和表中的列的内部系统表</strong></u>。元数据实际上位于<code>InnoDB</code>系统表空间中。由于历史原因，数据字典元数据在某种程度上与<code>InnoDB</code>表元数据文件（<code>.frm</code>文件）中存储的信息重叠 。</p>
<br>

<h3 id="14-6-5-Doublewrite-Buffer"><a href="#14-6-5-Doublewrite-Buffer" class="headerlink" title="14.6.5 Doublewrite Buffer"></a>14.6.5 Doublewrite Buffer</h3><p>doublewrite缓冲区是位于系统表空间中的存储区域，在此之前，<code>InnoDB</code>将从页面<code>InnoDB</code>缓冲池中刷新的页面写入页面，然后再将页面写入数据文件中的适当位置。仅在刷新页面并将页面写入doublewrite缓冲区之后，才 <code>InnoDB</code>将页面写入其适当位置。如果在页面写入过程中发生操作系统，存储子系统或 <a href="https://dev.mysql.com/doc/refman/5.6/en/mysqld.html" target="_blank" rel="noopener"><strong>mysqld</strong></a>进程崩溃，<code>InnoDB</code>以后可以在崩溃恢复期间从doublewrite缓冲区中找到该页面的良好副本。</p>
<p>尽管数据总是被写入两次，但Doublewrite Buffer并不需要两倍的I / O开销或两倍的I / O操作。<code>fsync()</code> 只需对操作系统进行一次调用，就可以将数据作为一个较大的顺序块写入Doublewrite Buffer本身。</p>
<p>默认情况下，Doublewrite Buffer处于启用状态。要禁用Doublewrite Buffer，请设置 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_doublewrite" target="_blank" rel="noopener"><code>innodb_doublewrite</code></a>为0。</p>
<br>

<h3 id="14-6-6-Redo-Log"><a href="#14-6-6-Redo-Log" class="headerlink" title="14.6.6 Redo Log"></a>14.6.6 Redo Log</h3><p>Redo Log是基于磁盘的数据结构，在崩溃恢复期间用于纠正不完整事务写入的数据。在正常操作期间，Redo Log对更改请求数据的请求进行编码，这些请求是由SQL语句或低级API调用引起的。在初始化期间以及接受连接之前，会自动重播未完成意外关闭之前未完成更新数据文件的修改。有关Redo Log在崩溃恢复中的作用的信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-recovery.html" target="_blank" rel="noopener">第14.18.2节“ InnoDB恢复”</a>。</p>
<p>默认情况下，Redo Log在磁盘上由两个名为<code>ib_logfile0</code>和的 文件物理表示<code>ib_logfile1</code>。MySQL以循环方式写入Redo Log文件。Redo Log中的数据按照受影响的记录进行编码；此数据统称为重做。通过Redo Log的数据传递以不断增加的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_lsn" target="_blank" rel="noopener">LSN</a>值表示。</p>
<p>有关相关信息，请参阅 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-init-startup-configuration.html#innodb-startup-log-file-configuration" target="_blank" rel="noopener">Redo Log文件配置</a>和 <a href="https://dev.mysql.com/doc/refman/5.6/en/optimizing-innodb-logging.html" target="_blank" rel="noopener">第8.5.4节“优化InnoDBRedo Log”</a>。</p>
<h4 id="更改Redo-Log文件的数量或大小"><a href="#更改Redo-Log文件的数量或大小" class="headerlink" title="更改Redo Log文件的数量或大小"></a>更改Redo Log文件的数量或大小</h4><p>要在MySQL 5.6.7或更早版本中更改<code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_redo_log" target="_blank" rel="noopener">Redo Log</a>文件的数量或大小，请执行以下步骤：</p>
<ol>
<li><p>如果<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_fast_shutdown" target="_blank" rel="noopener"><code>innodb_fast_shutdown</code></a>设置为2，则设置 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_fast_shutdown" target="_blank" rel="noopener"><code>innodb_fast_shutdown</code></a>为1：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL innodb_fast_shutdown = 1;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确保 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_fast_shutdown" target="_blank" rel="noopener"><code>innodb_fast_shutdown</code></a>未将其设置为2后，停止MySQL服务器并确保其关闭且没有错误（以确保日志中没有未完成事务的信息）。</p>
</li>
<li><p>将旧的日志文件复制到一个安全的地方，以防在关闭过程中出现问题并且需要它们来恢复表空间。</p>
</li>
<li><p>从日志文件目录中删除旧的日志文件。</p>
</li>
<li><p>编辑<code>my.cnf</code>以更改日志文件配置。</p>
</li>
<li><p>再次启动MySQL服务器。<a href="https://dev.mysql.com/doc/refman/5.6/en/mysqld.html" target="_blank" rel="noopener"><strong>mysqld</strong></a>发现<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-storage-engine.html" target="_blank" rel="noopener"><code>InnoDB</code></a>启动时不存在任何日志文件，并创建了新的日志文件。</p>
</li>
</ol>
<p>该<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_fast_shutdown" target="_blank" rel="noopener"><code>innodb_fast_shutdown</code></a> 改变的数量或大小时设置不再是相关的<code>InnoDB</code>日志文件。此外，尽管您可能仍希望将旧日志文件复制到一个安全的地方作为备份，但是不再需要删除旧日志文件。要更改<code>InnoDB</code>日志文件的数量或大小 ，请执行以下步骤：</p>
<ol>
<li>停止MySQL服务器，并确保它关闭且没有错误。</li>
<li>编辑<code>my.cnf</code>以更改日志文件配置。要更改日志文件的大小，请配置 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_log_file_size" target="_blank" rel="noopener"><code>innodb_log_file_size</code></a>。要增加日志文件的数量，请配置 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_log_files_in_group" target="_blank" rel="noopener"><code>innodb_log_files_in_group</code></a>。</li>
<li>再次启动MySQL服务器。</li>
</ol>
<p>如果<code>InnoDB</code>检测到 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_log_file_size" target="_blank" rel="noopener"><code>innodb_log_file_size</code></a>与Redo Log文件大小不同，它将编写日志检查点，关闭并删除旧的日志文件，以请求的大小创建新的日志文件，然后打开新的日志文件。</p>
<h4 id="组提交以Redo-Log刷新"><a href="#组提交以Redo-Log刷新" class="headerlink" title="组提交以Redo Log刷新"></a>组提交以Redo Log刷新</h4><p><code>InnoDB</code>像任何其他 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_acid" target="_blank" rel="noopener">符合ACID</a>的数据库引擎一样，在提交事务之前刷新事务的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_redo_log" target="_blank" rel="noopener">Redo Log</a>。<code>InnoDB</code> 使用<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_group_commit" target="_blank" rel="noopener">组提交</a> 功能将多个此类刷新请求分组在一起，以避免每次提交都进行一次刷新。使用组提交， <code>InnoDB</code>可以对日志文件进行一次写入操作，以对大约同时提交的多个用户事务执行提交操作，从而显着提高了吞吐量。</p>
<p>有关性能<code>COMMIT</code>和其他事务操作的更多信息 ，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/optimizing-innodb-transaction-management.html" target="_blank" rel="noopener">第8.5.2节“优化InnoDB事务管理”</a>。</p>
<br>

<h3 id="14-6-7-Undo-Logs"><a href="#14-6-7-Undo-Logs" class="headerlink" title="14.6.7 Undo Logs"></a>14.6.7 Undo Logs</h3><p><u><strong><em>回滚段</em></strong></u></p>
<p>InnoDB采用回滚段的方式来维护undo log的并发写入和持久化。回滚段实际上是一种 Undo 文件组织方式，每个回滚段又有多个undo log slot。</p>
<p>一共128个回滚段，每个回滚段维护了一个段头页，在该page中又划分了1024个slot (TRX_RSEG_N_SLOTS)，每个slot又对应到一个undo log对象，因此理论上InnoDB最多支持 96 * 1024个普通事务。</p>
<ol>
<li>rseg0预留在系统表空间ibdata中;</li>
<li>rseg 1~rseg 32这32个回滚段存放于临时表的系统表空间中;</li>
<li>rseg33~ 则根据配置存放到独立undo表空间中（如果没有打开独立Undo表空间，则存放于ibdata中）</li>
</ol>
<p><u><strong><em>Undo Log</em></strong></u></p>
<p>​        undo Log是与单个读写事务关联的 <code>undo Log</code> 记录的集合。undo Log 记录包含如何 撤消事务对 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_clustered_index" target="_blank" rel="noopener">聚簇索引</a> 记录的最新更改 的信息。如果另一个事务读取原始数据，就需要在 undo Log记录读取。</p>
<p>​        undo Log存在于 <code>undo log segment</code>。默认情况下，<code>undo log segment</code> 实际上是 <code>system tablespace</code> 的一部分 ，但它们也可以驻留在 <code>undo log tablespace</code> 中。有关更多信息，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-undo-tablespaces.html" target="_blank" rel="noopener">第14.6.3.3节“撤消表空间”</a>。</p>
<ol>
<li><p><code>InnoDB</code>支持128个回滚段，通过参数 <code>innodb_rollback_segments</code> 定义；</p>
</li>
<li><p>一个 <code>rollback segment</code> 支持的 事务数 取决（ <code>rollback segment</code> 中 <code>undo slots</code> 的数量） 和 （每个事务所需的 undo log 数）；</p>
</li>
<li><p>一个<code>rollback segment</code> 中 <code>undo slots</code> 的数量 又会因为 <code>innodb_page_size</code> 不同而不同；</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>InnoDB Page Size</th>
<th>rollback segment 中的 undo slots 数（innodb_page_size/ 16）</th>
</tr>
</thead>
<tbody><tr>
<td><code>4096 (4KB)</code></td>
<td><code>256</code></td>
</tr>
<tr>
<td><code>8192 (8KB)</code></td>
<td><code>512</code></td>
</tr>
<tr>
<td><code>16384 (16KB)</code></td>
<td><code>1024</code></td>
</tr>
</tbody></table>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191203205602.png" alt></p>
<p>以下每种操作类型，一个事务最多可以分配两个 undo Log：</p>
<ol>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a> 操作 在事务提交前只对当前事务可见，因此产生的Undo日志可以在事务提交后直接删除；</li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.6/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a> 操作 产生的Undo日志被归成一类，即update_undo；</li>
</ol>
<p>undo Log根据需要分配。例如，一个事务执行<code>INSERT</code>， <code>UPDATE</code> 和 <code>DELETE</code> 操作被分配了两个undo Log，仅执行<a href="https://dev.mysql.com/doc/refman/5.6/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>操作的事务被分配有一个 undo Log；</p>
<p>分配给事务的Undo Log在其持续时间内始终与事务相关；</p>
<p>给定上述因素，可以使用以下公式来估计<code>InnoDB</code>能够支持的并发读写事务数。</p>
<blockquote>
<p>注意：在达到 <code>InnoDB</code> 能够支持的并发读写事务数之前，事务可能会遇到并发事务限制错误。当分配给事务的 <code>rollback segment</code> 用完 <code>undo slots</code> 时，就会发生这种情况。在这种情况下，请尝试重新运行事务</p>
</blockquote>
<ul>
<li><p>如果每个事务执行任一个 insert 或 update 或 delete 操作，InnoDB支持的 并发读-写事务的数目： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(innodb_page_size / 16) * innodb_rollback_segments</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果每个事务执行任一个 insert 和（ update 或 delete） 操作，InnoDB支持的 并发读-写事务的数目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(innodb_page_size / 16 / 2) * innodb_rollback_segments</span><br></pre></td></tr></table></figure>

</li>
</ul>
<br>

<h2 id="14-12-InnoDB磁盘I-O和文件空间管理"><a href="#14-12-InnoDB磁盘I-O和文件空间管理" class="headerlink" title="14.12 InnoDB磁盘I / O和文件空间管理"></a>14.12 InnoDB磁盘I / O和文件空间管理</h2><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-disk-io.html" target="_blank" rel="noopener">14.12.1 InnoDB磁盘I / O</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-file-space.html" target="_blank" rel="noopener">14.12.2文件空间管理</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-checkpoints.html" target="_blank" rel="noopener">14.12.3 InnoDB检查点</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-file-defragmenting.html" target="_blank" rel="noopener">14.12.4对表进行碎片整理</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-truncate-table-reclaim-space.html" target="_blank" rel="noopener">14.12.5使用TRUNCATE TABLE回收磁盘空间</a></li>
</ul>
<p>作为DBA，您必须管理磁盘I / O以防止I / O子系统饱和，并管理磁盘空间以避免填满存储设备。该<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_acid" target="_blank" rel="noopener">ACID</a>设计模型需要一定量的I / O可能似乎是多余的，但有助于确保数据的可靠性。在这些限制内， <code>InnoDB</code>尝试优化数据库工作和磁盘文件的组织，以最大程度地减少磁盘I / O的数量。有时，I / O会推迟到数据库不忙之前，或者直到所有内容都需要进入一致状态为止，例如在<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_fast_shutdown" target="_blank" rel="noopener">快速关闭</a>后重新启动数据库期间。</p>
<p>本节讨论默认类型的MySQL表（也称为<code>InnoDB</code>表）对I / O和磁盘空间的主要注意事项 ：</p>
<ul>
<li>控制用于提高查询性能的后台I / O数量。</li>
<li>启用或禁用可提供额外耐用性的功能，但需要付出额外的I / O代价。</li>
<li>将表组织成许多小文件，一些大文件或两者的组合。</li>
<li>使Redo Log文件的大小与日志文件已满时发生的I / O活动保持平衡。</li>
<li>如何重组表以获得最佳查询性能。</li>
</ul>
<h3 id="14-12-1-InnoDB磁盘I-O"><a href="#14-12-1-InnoDB磁盘I-O" class="headerlink" title="14.12.1 InnoDB磁盘I / O"></a>14.12.1 InnoDB磁盘I / O</h3><p><code>InnoDB</code>在可能的情况下使用异步磁盘I / O，方法是创建多个线程来处理I / O操作，同时允许其他数据库操作在I / O仍在进行时继续进行。在Linux和Windows平台上，<code>InnoDB</code>使用可用的OS和库函数来执行“ 本机 ”异步I / O。在其他平台上，<code>InnoDB</code>仍然使用I / O线程，但是这些线程实际上可能会等待I / O请求完成。该技术称为“ 模拟 ” 异步I / O。</p>
<h4 id="预读"><a href="#预读" class="headerlink" title="预读"></a>预读</h4><p>如果<code>InnoDB</code>可以确定很快有可能需要数据的可能性很大，它将执行预读操作将数据带入缓冲池，以便在内存中可用。对连续数据进行一些大的读取请求可能比对几个分散的小请求进行效率更高。有两种预读启发式<code>InnoDB</code>：</p>
<ul>
<li>在顺序预读中，如果<code>InnoDB</code> 注意到对表空间中某个段的访问模式是顺序的，则它会将一批数据库页的读取提前发布到I / O系统。</li>
<li>在随机预读中，如果<code>InnoDB</code>注意到表空间中的某些区域似乎正在被完全读入缓冲池，则它将剩余的读操作发布到I / O系统。</li>
</ul>
<p>有关配置<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-performance-read_ahead.html" target="_blank" rel="noopener">预读</a>启发式方法的信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-performance-read_ahead.html" target="_blank" rel="noopener">第14.8.3.3节“配置InnoDB缓冲池预取（预读）”</a>。</p>
<h4 id="Doublewrite-Buffer"><a href="#Doublewrite-Buffer" class="headerlink" title="Doublewrite Buffer"></a>Doublewrite Buffer</h4><p><code>InnoDB</code>使用一种新颖的文件刷新技术，该技术涉及一种称为<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_doublewrite_buffer" target="_blank" rel="noopener">doublewrite缓冲区</a>的结构 ，默认情况下（<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_doublewrite" target="_blank" rel="noopener"><code>innodb_doublewrite=ON</code></a>）已启用。它增加了崩溃或断电后的恢复安全性，并通过减少<code>fsync()</code>操作需求来提高大多数Unix版本的性能。</p>
<p>在将页面<code>InnoDB</code> 写到数据文件之前，首先将它们写到称为doublewrite缓冲区的连续表空间区域中。仅在完成对双<code>InnoDB</code> 写缓冲区的写入和刷新之后，才将页面写入数据文件中的相应位置。如果在页面写入过程中发生操作系统，存储子系统或 <a href="https://dev.mysql.com/doc/refman/5.6/en/mysqld.html" target="_blank" rel="noopener"><strong>mysqld</strong></a>进程崩溃（导致<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_torn_page" target="_blank" rel="noopener">页面损坏的</a> 情况），<code>InnoDB</code>则以后可以在恢复期间从doublewrite缓冲区中找到该页面的良好副本。</p>
<h3 id="14-12-2文件空间管理"><a href="#14-12-2文件空间管理" class="headerlink" title="14.12.2文件空间管理"></a>14.12.2文件空间管理</h3><p>您使用<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_data_file_path" target="_blank" rel="noopener"><code>innodb_data_file_path</code></a> 配置选项在配置文件中定义的数据文件 形成<code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_system_tablespace" target="_blank" rel="noopener">系统表空间</a>。这些文件在逻辑上串联在一起形成系统表空间。没有使用中的条带化。您无法定义表在系统表空间中的分配位置。在新创建的系统表空间中，<code>InnoDB</code>从第一个数据文件开始分配空间。</p>
<p>为避免将所有表和索引存储在系统表空间内所带来的问题，可以启用 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a> 配置选项（默认选项），该选项将每个新创建的表存储在单独的表空间文件中（扩展名为 <code>.ibd</code>）。对于以这种方式存储的表，磁盘文件中的碎片较少，并且当表被截断时，该空间将返回给操作系统，而不是仍由InnoDB在系统表空间中保留。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191203205602.png" alt></p>
<blockquote>
<pre><code>在整理InnoDB存储引擎的索引的时候，发现B+树是离不开页面page的。所以先整理InnoDB的数据存储结构。</code></pre><p>关键词：Pages, Extents, Segments, and Tablespaces</p>
<p><strong>如何存储表</strong><br>MySQL 使用 InnoDB 存储表时，会将表的定义和数据索引等信息分开存储，其中前者存储在 .frm 文件中，后者存储在 .ibd 文件中，这一节就会对这两种不同的文件分别进行介绍。</p>
<p><strong>.frm</strong></p>
<p>无论在 MySQL 中选择了哪个存储引擎，所有的 MySQL 表都会在硬盘上创建一个 .frm 文件用来描述表的格式或者说定义； .frm 文件的格式在不同的平台上都是相同的。</p>
<p><strong>.ibd 文件</strong><br>InnoDB 中用于存储数据的文件总共有两个部分，一是系统表空间文件，包括 ibdata1、 ibdata2 等文件，其中存储了 InnoDB 系统信息和用户数据库表数据和索引，是所有表公用的。<br>当打开 innodb_file_per_table 选项时， .ibd 文件就是每一个表独有的表空间，文件存储了当前表的数据和相关的索引数据。</p>
<p><strong>表空间</strong><br>      innodb存储引擎在存储设计上模仿了Oracle的存储结构，其数据是按照表空间进行管理的。新建一个数据库时，innodb存储引擎会初始化一个名为ibdata1 的表空间文件，默认情况下，这个文件会存储所有表的数据，以及我们所熟知但看不到的系统表sys_tables、sys_columns、sys_indexes 、sys_fields等。此外，还会存储用来保证数据完整性的回滚段数据，当然这部分数据在新版本的MySQL中，已经可以通过参数来设置回滚段的存储位置了；</p>
<p>​    innodb存储引擎的设计很灵活，可以通过参数innodb_file_per_table来设置，使得每一个表都对应一个自己的独立表空间文件，而不是存储到公共的ibdata1文件中。独立的表空间文件之存储对应表的B+树数据、索引和插入缓冲等信息，其余信息还是存储在默认表空间中。</p>
<pre><code>这个文件所存储的内容主要就是B+树（索引），一个表可以有多个索引，也就是在一个文件中，可以存储多个索引，而如果一个表没有索引的话，用来存储数据的被称为聚簇索引，也就是说这也是一个索引。最终的结论是，ibd文件存储的就是一个表的所有索引数据。 索引文件有段（segment）,簇（extends）（有的文章翻译为区），页面（page）组成。</code></pre><p>  关于行记录格式，单独整理一篇。</p>
<p><strong>段（segment</strong><br>      段是表空间文件中的主要组织结构，它是一个逻辑概念，用来管理物理文件，是构成索引、表、回滚段的基本元素。<br>     上图中显示了表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等。InnoDB存储引擎表是索引组织的（index organized），因此数据即索引，索引即数据。那么数据段即为B+树的页节点（上图的leaf node segment），索引段即为B+树的非索引节点（上图的non-leaf node segment）。</p>
<p>   创建一个索引（B+树）时会同时创建两个段，分别是内节点段和叶子段，内节点段用来管理（存储）B+树非叶子（页面）的数据，叶子段用来管理（存储）B+树叶子节点的数据；也就是说，在索引数据量一直增长的过程中，所有新的存储空间的申请，都是从“段”这个概念中申请的。</p>
<p>  为了介绍索引为目的，所以不展开介绍回滚段等内容。</p>
<p><strong>区/簇（extents）</strong><br>     段是个逻辑概念，innodb引入了簇的概念，在代码中被称为extent；</p>
<pre><code>簇是由64个连续的页组成的，每个页大小为16KB，即每个簇的大小为1MB。簇是构成段的基本元素，一个段由若干个簇构成。一个簇是物理上连续分配的一个段空间，每一个段至少会有一个簇，在创建一个段时会创建一个默认的簇。如果存储数据时，一个簇已经不足以放下更多的数据，此时需要从这个段中分配一个新的簇来存放新的数据。一个段所管理的空间大小是无限的，可以一直扩展下去，但是扩展的最小单位就是簇。</code></pre><p><strong>页（page）</strong><br>InnoDB有页（page）的概念，可以理解为簇的细化。页是InnoDB磁盘管理的最小单位。</p>
<p>常见的页类型有：<br>数据页（B-tree Node）。<br>Undo页（Undo Log Page）。<br>系统页（System Page）。<br>事务数据页（Transaction system Page）。<br>插入缓冲位图页（Insert Buffer Bitmap）。<br>插入缓冲空闲列表页（Insert Buffer Free List）。<br>未压缩的二进制大对象页（Uncompressed BLOB Page）。<br>压缩的二进制大对象页（Compressed BLOB Page）。</p>
<pre><code>在逻辑上（页面号都是从小到大连续的）及物理上都是连续的。在向表中插入数据时，如果一个页面已经被写完，系统会从当前簇中分配一个新的空闲页面处理使用，如果当前簇中的64个页面都被分配完，系统会从当前页面所在段中分配一个新的簇，然后再从这个簇中分配一个新的页面来使用；</code></pre></blockquote>
<h4 id="页面，范围，段和表空间"><a href="#页面，范围，段和表空间" class="headerlink" title="页面，范围，段和表空间"></a>页面，范围，段和表空间</h4><p>每个表空间由数据库<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_page" target="_blank" rel="noopener">页面</a>组成 。MySQL实例中的每个表空间都具有相同的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_page_size" target="_blank" rel="noopener">页面大小</a>。默认情况下，所有表空间的页面大小均为16KB；您可以<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_page_size" target="_blank" rel="noopener"><code>innodb_page_size</code></a>在创建MySQL实例时通过指定选项将页面大小减小到8KB或4KB 。</p>
<p>这些页面分为 大小为1MB的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_extent" target="_blank" rel="noopener">扩展</a>区（64个连续的16KB页面，128个8KB页面或256个4KB页面）。在 “ 文件 ”表空间内被称为 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_segment" target="_blank" rel="noopener">段</a>在 <code>InnoDB</code>。（这些段与<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_rollback_segment" target="_blank" rel="noopener">回滚段</a>不同， <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_rollback_segment" target="_blank" rel="noopener">回滚段</a>实际上包含许多表空间段。）</p>
<p>当段在表空间内增长时， <code>InnoDB</code>将前32页一次分配给它。之后，<code>InnoDB</code>开始将整个扩展区分配给该段。<code>InnoDB</code> 一次最多可以向一个大段中添加4个扩展区，以确保数据的良好顺序。</p>
<p>为中的每个索引分配了两个段 <code>InnoDB</code>。一个用于 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_b_tree" target="_blank" rel="noopener">B树</a>的非叶节点，另一个用于叶节点。将叶子节点保持在磁盘上连续可以实现更好的顺序I / O操作，因为这些叶子节点包含实际的表数据。</p>
<p>表空间中的某些页面包含其他页面的位图，因此表空间中的某些扩展数据<code>InnoDB</code>块无法整体分配给段，而只能分配给单个页面。</p>
<p>当您通过发出一条<a href="https://dev.mysql.com/doc/refman/5.6/en/show-table-status.html" target="_blank" rel="noopener"><code>SHOW TABLE STATUS</code></a>语句在表空间中请求可用空间时，请 <code>InnoDB</code>报告表空间中绝对可用的扩展区。<code>InnoDB</code>始终保留一定程度的清理和其他内部用途；这些保留的范围不包括在可用空间中。</p>
<p>从表中删除数据时，将<code>InnoDB</code> 收缩相应的B树索引。释放的空间是否可供其他用户使用取决于删除模式是否将单个页面或扩展区释放到表空间中。删除表或删除表中的所有行可以保证将空间释放给其他用户，但请记住，删除的行仅通过<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_purge" target="_blank" rel="noopener">清除</a>操作才能物理删除， <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_purge" target="_blank" rel="noopener">清除</a>操作会在不再需要事务回滚或一致读取后的一段时间自动发生。 。（请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-multi-versioning.html" target="_blank" rel="noopener">第14.3节“ InnoDB多版本”</a>。）</p>
<p>要查看有关表空间的信息，请使用表空间监视器。请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-monitors.html" target="_blank" rel="noopener">第14.17节“ InnoDB监视器”</a>。</p>
<h4 id="页面如何与表格行相关"><a href="#页面如何与表格行相关" class="headerlink" title="页面如何与表格行相关"></a>页面如何与表格行相关</h4><p>最大行长度略小于数据库页面的一半。例如，对于默认的16KB <code>InnoDB</code>页面大小，最大行长度略小于8KB ，这是由<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_page_size" target="_blank" rel="noopener"><code>innodb_page_size</code></a> 配置选项定义的。</p>
<p>如果一行没有超过页面限制的一半，则所有行都将存储在页面内。如果某行超出了半页限制，那么 将选择<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_variable_length_type" target="_blank" rel="noopener">可变长度列</a>用于外部页外存储，直到该行适合半页之内。可变长度列的外部页外存储因行格式而异：</p>
<ul>
<li><p><em>紧凑和冗余行格式</em></p>
<p>当将可变长度列选择用于外部页外存储时，<code>InnoDB</code>将前768个字节本地存储在该行中，其余部分从外部存储到溢出页中。每个此类列都有其自己的溢出页面列表。768字节的前缀附带一个20字节的值，该值存储列的真实长度，并指向存储剩余值的溢出列表。请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-row-format.html" target="_blank" rel="noopener">第14.11节“ InnoDB行格式”</a>。</p>
</li>
<li><p><em>动态和压缩行格式</em></p>
<p>如果将可变长度列选择用于外部页外存储，<code>InnoDB</code>则在行中本地存储一个20字节的指针，其余部分在外部存储到溢出页中。请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-row-format.html" target="_blank" rel="noopener">第14.11节“ InnoDB行格式”</a>。</p>
</li>
</ul>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/blob.html" target="_blank" rel="noopener"><code>LONGBLOB</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.6/en/blob.html" target="_blank" rel="noopener"><code>LONGTEXT</code></a>列必须小于4GB，并且总行长（包括 <a href="https://dev.mysql.com/doc/refman/5.6/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.6/en/blob.html" target="_blank" rel="noopener"><code>TEXT</code></a>列）必须小于4GB。</p>
<h3 id="14-12-3-InnoDB检查点"><a href="#14-12-3-InnoDB检查点" class="headerlink" title="14.12.3 InnoDB检查点"></a>14.12.3 InnoDB检查点</h3><p>使你的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_log_file" target="_blank" rel="noopener">日志文件</a>非常大时可以减少磁盘I / O的 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_checkpoint" target="_blank" rel="noopener">检查点</a>。通常将日志文件的总大小设置为与缓冲池一样大，甚至更大。尽管从MySQL 5.5开始，过去大型日志文件可能会使崩溃恢复花费大量时间，但崩溃恢复的性能增强使崩溃后可以快速启动使用大型日志文件。（严格来说，对于具有InnoDB插件1.0.7和更高版本的MySQL 5.1，可以实现这种性能改进。对于MySQL 5.5，可以在默认的InnoDB存储引擎中实现此改进。）</p>
<h4 id="检查点处理的工作原理"><a href="#检查点处理的工作原理" class="headerlink" title="检查点处理的工作原理"></a>检查点处理的工作原理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InnoDB`实现称为[模糊检查点](https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_fuzzy_checkpointing)的 [检查点](https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_checkpoint)机制。小批量地从缓冲池中刷新已修改的数据库页面。无需单批刷新缓冲池，这会在检查点过程中中断用户SQL语句的处理。 `InnoDB</span><br></pre></td></tr></table></figure>

<p>在<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_crash_recovery" target="_blank" rel="noopener">崩溃恢复</a>期间， <code>InnoDB</code>查找写入日志文件的检查点标签。它知道在标签之前对数据库的所有修改都存在于数据库的磁盘映像中。然后<code>InnoDB</code>从检查点向前扫描日志文件，将记录的修改应用于数据库。</p>
<h3 id="14-12-4对表进行碎片整理"><a href="#14-12-4对表进行碎片整理" class="headerlink" title="14.12.4对表进行碎片整理"></a>14.12.4对表进行碎片整理</h3><p>随机插入二级索引或从二级索引中删除可能导致索引碎片化。碎片意味着磁盘上索引页的物理顺序与页面上记录的索引顺序不接近，或者64页块中有许多未使用的页已分配给索引。</p>
<p>碎片的一个症状是表占用的空间超过了它应 “占用”的空间。到底有多少是很难确定的。所有<code>InnoDB</code>数据和索引都存储在<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_b_tree" target="_blank" rel="noopener">B树中</a>，它们的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_fill_factor" target="_blank" rel="noopener">填充因子</a>可能在50％到100％之间变化。碎片化的另一个症状是，这样的表扫描花费的时间比“ 应该 ”花费的时间更多 ：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> non_indexed_column &lt;&gt; <span class="number">12345</span>;</span><br></pre></td></tr></table></figure>

<p>前面的查询要求MySQL执行全表扫描，这是大型表的最慢查询类型。</p>
<p>为了加快索引扫描的速度，您可以定期执行 “ null ” <a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a> 操作，这会导致MySQL重建表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span></span><br></pre></td></tr></table></figure>

<p>在MySQL 5.6.3中，你也可以使用 执行 “ 空 ”，重建表alter操作。以前，该选项已被识别但被忽略。 <a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE *</code>tbl_name<code>* FORCE</code></a><code>FORCE</code></p>
<p>在MySQL 5.6.17，双方 并 使用 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-online-ddl.html" target="_blank" rel="noopener">在线DDL</a>。有关更多信息，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-online-ddl.html" target="_blank" rel="noopener">第14.13节“ InnoDB和在线DDL”</a>。 <a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE *</code>tbl_name<code>* ENGINE=INNODB</code></a><a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE *</code>tbl_name<code>* FORCE</code></a></p>
<p>执行碎片整理操作的另一种方法是使用 <a href="https://dev.mysql.com/doc/refman/5.6/en/mysqldump.html" target="_blank" rel="noopener"><strong>mysqldump</strong></a>将表转储到文本文件，删除表并从转储文件重新加载它。</p>
<p>如果对索引的插入总是递增的，并且记录仅从末尾删除，则<code>InnoDB</code> 文件空间管理算法可确保不会发生索引中的碎片。</p>
<h3 id="14-12-5使用TRUNCATE-TABLE回收磁盘空间"><a href="#14-12-5使用TRUNCATE-TABLE回收磁盘空间" class="headerlink" title="14.12.5使用TRUNCATE TABLE回收磁盘空间"></a>14.12.5使用TRUNCATE TABLE回收磁盘空间</h3><p>当回收操作系统的磁盘空间 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_truncate" target="_blank" rel="noopener">截断</a>的 <code>InnoDB</code>表，该表必须存放在自己的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_ibd_file" target="_blank" rel="noopener">的.ibd</a>文件。若要将表存储在其自己的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_ibd_file" target="_blank" rel="noopener">.ibd</a> 文件中，<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a>必须在创建表时启用该表。此外，被截断的表和其他表之间不能有 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_foreign_key" target="_blank" rel="noopener">外键</a>约束，否则 <code>TRUNCATE TABLE</code>操作将失败。但是，允许在同一表的两列之间使用外键约束。</p>
<p>截断表后，将其删除并在新<code>.ibd</code>文件中重新创建 ，并将释放的空间返回给操作系统。这与<code>InnoDB</code>存储在 <code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_system_tablespace" target="_blank" rel="noopener">系统表空间</a> （在时创建的表 <code>innodb_file_per_table=OFF</code>）中<code>InnoDB</code>的表被截断相反 ，后者在表被截断后只能 使用释放的空间。</p>
<p>截断表并将磁盘空间返回给操作系统的能力还意味着 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_physical_backup" target="_blank" rel="noopener">物理备份</a>可以更小。截断存储在系统表空间中的表（时创建的表 <code>innodb_file_per_table=OFF</code>）在系统表空间中留下未使用空间的块。</p>
<br>

<h2 id="14-17-InnoDB监视器"><a href="#14-17-InnoDB监视器" class="headerlink" title="14.17 InnoDB监视器"></a>14.17 InnoDB监视器</h2><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-monitor-types.html" target="_blank" rel="noopener">14.17.1 InnoDB监视器类型</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-enabling-monitors.html" target="_blank" rel="noopener">14.17.2启用InnoDB监视器</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-standard-monitor.html" target="_blank" rel="noopener">14.17.3 InnoDB标准监视器和锁定监视器输出</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-tablespace-monitor.html" target="_blank" rel="noopener">14.17.4 InnoDB表空间监视器输出</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-table-monitor.html" target="_blank" rel="noopener">14.17.5 InnoDB表监视器输出</a></li>
</ul>
<p><code>InnoDB</code>监视器提供有关 <code>InnoDB</code>内部状态的信息。此信息对于性能调整很有用。</p>
<h3 id="14-17-1-InnoDB监视器类型"><a href="#14-17-1-InnoDB监视器类型" class="headerlink" title="14.17.1 InnoDB监视器类型"></a>14.17.1 InnoDB监视器类型</h3><p><code>InnoDB</code>监视器 有四种类型：</p>
<ul>
<li><p>标准<code>InnoDB</code>监视器显示以下类型的信息：</p>
<ul>
<li>主后台线程完成的工作</li>
<li>信号量等待</li>
<li>有关最新外键和死锁错误的数据</li>
<li>锁等待交易</li>
<li>活动交易持有的表和记录锁</li>
<li>待处理的I / O操作和相关统计信息</li>
<li>插入缓冲区和自适应哈希索引统计信息</li>
<li>Redo Log数据</li>
<li>缓冲池统计</li>
<li>行操作数据</li>
</ul>
</li>
<li><p>该<code>InnoDB</code>锁监控打印附加锁信息作为标准的一部分 <code>InnoDB</code>监视器输出。</p>
</li>
<li><p>的<code>InnoDB</code>表空间监视器打印在共享表文件的段的列表并验证表分配的数据结构。</p>
</li>
<li><p>该<code>InnoDB</code>表监控打印内容<code>InnoDB</code>的内部数据字典。</p>
<p>注意</p>
<p>Tablespace Monitor和Table Monitor已过时，并将在以后的MySQL版本中删除。可以从<code>InnoDB</code> <code>INFORMATION_SCHEMA</code>表中获得表监视器的类似信息 。请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-i_s-tables.html" target="_blank" rel="noopener">第21.30节“ INFORMATION_SCHEMA InnoDB表”</a>。</p>
</li>
</ul>
<p>有关<code>InnoDB</code>表和表空间监视器的其他信息，请参见 <a href="http://www.markleith.co.uk/?p=25" target="_blank" rel="noopener">Mark Leith：InnoDB表和表空间监视器</a>。</p>
<h3 id="14-17-2启用InnoDB监视器"><a href="#14-17-2启用InnoDB监视器" class="headerlink" title="14.17.2启用InnoDB监视器"></a>14.17.2启用InnoDB监视器</h3><p>当<code>InnoDB</code>监视器用于周期性输出使能，<code>InnoDB</code>将输出写入 <a href="https://dev.mysql.com/doc/refman/5.6/en/mysqld.html" target="_blank" rel="noopener"><strong>的mysqld</strong></a>服务器标准错误输出（<code>stderr</code>）每15秒，约。</p>
<p><code>InnoDB</code>将监视器的输出发送到 内存缓冲区，<code>stderr</code>而不是<code>stdout</code>固定大小的缓冲区，以免潜在的缓冲区溢出。</p>
<p>在Windows上，<code>stderr</code>除非另有配置，否则定向到默认日志文件。如果要将输出定向到控制台窗口而不是错误日志，请从控制台窗口中带有<a href="https://dev.mysql.com/doc/refman/5.6/en/server-options.html#option_mysqld_console" target="_blank" rel="noopener"><code>--console</code></a>选项的命令提示符启动服务器 。有关更多信息，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/error-log-windows.html" target="_blank" rel="noopener">第5.4.2.1节“ Windows上的错误记录”</a>。</p>
<p>在Unix和类似Unix的系统上，<code>stderr</code>除非另行配置，否则通常直接指向终端。有关更多信息，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/error-log-unix.html" target="_blank" rel="noopener">第5.4.2.2节“在Unix和类似Unix的系统上记录错误”</a>。</p>
<p><code>InnoDB</code>仅在您实际希望查看监视器信息时才应启用监视器，因为输出生成会导致性能降低。另外，如果将监视器输出定向到错误日志，则如果以后忘记通过删除监视器表来禁用监视器，则日志可能会变得很大。</p>
<p>注意</p>
<p>为了帮助进行故障排除，请在某些情况下<code>InnoDB</code> 临时启用标准<code>InnoDB</code>Monitor输出。有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-troubleshooting.html" target="_blank" rel="noopener">第14.21节“ InnoDB故障排除”</a>。</p>
<p>每个监视器都以包含时间戳和监视器名称的标题开头。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">=====================================</span><br><span class="line">2014-10-16 16:28:15 7feee43c5700 INNODB MONITOR OUTPUT</span><br><span class="line">=====================================</span><br></pre></td></tr></table></figure>

<p>标准<code>InnoDB</code>监视器（<code>INNODB MONITOR OUTPUT</code>）的标头也用于锁定监视器，因为锁定监视器在增加额外的锁定信息的情况下会产生相同的输出。</p>
<p>启用<code>InnoDB</code>标准监视器和锁定监视器以进行定期输出可以通过以下两种方法之一执行：</p>
<ul>
<li><p>使用<code>CREATE TABLE</code>语句创建<code>InnoDB</code>与监视器关联的特别命名的表。例如，要启用标准<code>InnoDB</code>Monitor，您将创建一个<code>InnoDB</code>名为的表 <code>innodb_monitor</code>。还使用该<code>CREATE TABLE</code>方法启用了表空间监视器和表监视器。</p>
<p>使用<a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>语法只是<code>InnoDB</code> 通过MySQL的SQL解析器将命令传递给引擎的一种方法。唯一重要的是表名以及它是一个<code>InnoDB</code> 表。表的结构与创建表的数据库无关。如果关闭服务器，则在重新启动服务器时监视器不会自动重新启动。删除监视器表并发出新的 <a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>语句以启动监视器。</p>
<p>注意</p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>启用<code>InnoDB</code>监视器 的方法已过时，将来的发行版中可能会删除该方法。从MySQL 5.6.16开始，您可以使用和 系统变量启用标准<code>InnoDB</code> Monitor和<code>InnoDB</code>Lock Monitor 。 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_status_output" target="_blank" rel="noopener"><code>innodb_status_output</code></a><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_status_output_locks" target="_blank" rel="noopener"><code>innodb_status_output_locks</code></a></p>
</li>
<li><p>使用 MySQL 5.6.16中引入的 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_status_output" target="_blank" rel="noopener"><code>innodb_status_output</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_status_output_locks" target="_blank" rel="noopener"><code>innodb_status_output_locks</code></a>系统变量。</p>
</li>
</ul>
<p>该<a href="https://dev.mysql.com/doc/refman/5.6/en/privileges-provided.html#priv_process" target="_blank" rel="noopener"><code>PROCESS</code></a>权限才能启用或禁用<code>InnoDB</code>监视器。</p>
<h4 id="启用标准InnoDB监视器"><a href="#启用标准InnoDB监视器" class="headerlink" title="启用标准InnoDB监视器"></a>启用标准InnoDB监视器</h4><p>要启用标准InnoDB Monitor的定期输出，请创建<code>innodb_monitor</code>表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> innodb_monitor (a <span class="built_in">INT</span>) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span>;</span><br></pre></td></tr></table></figure>

<p>要禁用标准<code>InnoDB</code>监视器，请删除表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> innodb_monitor;</span><br></pre></td></tr></table></figure>

<p>从MySQL 5.6.16开始，您还可以<code>InnoDB</code>通过将<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_status_output" target="_blank" rel="noopener"><code>innodb_status_output</code></a>系统变量设置为来启用标准 Monitor <code>ON</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> innodb_status_output=<span class="keyword">ON</span>;</span><br></pre></td></tr></table></figure>

<p>要禁用标准<code>InnoDB</code>监视器，请设置 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_status_output" target="_blank" rel="noopener"><code>innodb_status_output</code></a>为 <code>OFF</code>。</p>
<p>关闭服务器时，该 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_status_output" target="_blank" rel="noopener"><code>innodb_status_output</code></a>变量将设置为默认<code>OFF</code>值。</p>
<h4 id="启用InnoDB锁定监视器"><a href="#启用InnoDB锁定监视器" class="headerlink" title="启用InnoDB锁定监视器"></a>启用InnoDB锁定监视器</h4><p>要启用<code>InnoDB</code>锁定监视器以进行定期输出，请创建<code>innodb_lock_monitor</code>表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> innodb_lock_monitor (a <span class="built_in">INT</span>) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span>;</span><br></pre></td></tr></table></figure>

<p>要禁用<code>InnoDB</code>锁定监视器，请删除表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> innodb_lock_monitor;</span><br></pre></td></tr></table></figure>

<p>从MySQL 5.6.16开始，您还可以<code>InnoDB</code>通过将<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_status_output_locks" target="_blank" rel="noopener"><code>innodb_status_output_locks</code></a>系统变量设置为来启用 锁定监视器 <code>ON</code>。与<a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>启用<code>InnoDB</code>监视器 的 方法一样， 必须同时启用<code>InnoDB</code>标准监视器和 <code>InnoDB</code>锁定监视器，才能 <code>InnoDB</code>定期打印锁定监视器数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> innodb_status_output=<span class="keyword">ON</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> innodb_status_output_locks=<span class="keyword">ON</span>;</span><br></pre></td></tr></table></figure>

<p>关闭服务器时， <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_status_output" target="_blank" rel="noopener"><code>innodb_status_output</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_status_output_locks" target="_blank" rel="noopener"><code>innodb_status_output_locks</code></a> 变量将设置为默认<code>OFF</code>值。</p>
<p>要禁用<code>InnoDB</code>锁定监视器，请设置 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_status_output_locks" target="_blank" rel="noopener"><code>innodb_status_output_locks</code></a>为 <code>OFF</code>。设置 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_status_output" target="_blank" rel="noopener"><code>innodb_status_output</code></a>为OFF也将禁用标准<code>InnoDB</code>监视器。</p>
<p>注意</p>
<p>要启用<code>InnoDB</code>锁定监视器的 <a href="https://dev.mysql.com/doc/refman/5.6/en/show-engine.html" target="_blank" rel="noopener"><code>SHOW ENGINE INNODB STATUS</code></a>输出，只需启用 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_status_output_locks" target="_blank" rel="noopener"><code>innodb_status_output_locks</code></a>。</p>
<h4 id="获得标准的InnoDB监视器按需输出"><a href="#获得标准的InnoDB监视器按需输出" class="headerlink" title="获得标准的InnoDB监视器按需输出"></a>获得标准的InnoDB监视器按需输出</h4><p>作为启用标准<code>InnoDB</code>Monitor定期输出的替代方法 ，您可以<code>InnoDB</code>使用<a href="https://dev.mysql.com/doc/refman/5.6/en/show-engine.html" target="_blank" rel="noopener"><code>SHOW ENGINE INNODB STATUS</code></a>SQL语句按需获取标准Monitor输出，该语句将输出提取到客户端程序。如果您使用的是<a href="https://dev.mysql.com/doc/refman/5.6/en/mysql.html" target="_blank" rel="noopener"><strong>mysql</strong></a> 交互式客户端，则将常用的分号语句终止符替换为，则输出更具可读性<code>\G</code>：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW ENGINE INNODB STATUS\G</span><br></pre></td></tr></table></figure>

<p><a href="https://dev.mysql.com/doc/refman/5.6/en/show-engine.html" target="_blank" rel="noopener"><code>SHOW ENGINE INNODB STATUS</code></a><code>InnoDB</code> 如果<code>InnoDB</code>启用了锁定监视器，则输出还包括锁定监视器数据。</p>
<h4 id="将标准InnoDB监视器输出定向到状态文件"><a href="#将标准InnoDB监视器输出定向到状态文件" class="headerlink" title="将标准InnoDB监视器输出定向到状态文件"></a>将标准InnoDB监视器输出定向到状态文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InnoDB`通过`--innodb-status-file`在启动时指定选项，可以启用 标准监视器输出并将其定向到状态文件 。使用此选项时，`InnoDB`将 在数据目录中创建一个名称为文件的文件 ，并大约每15秒将输出写入其中。 `innodb_status.*`pid`*</span><br></pre></td></tr></table></figure>

<p><code>InnoDB</code>正常关闭服务器后，将删除状态文件。如果发生异常关闭，则可能必须手动删除状态文件。</p>
<p>该<code>--innodb-status-file</code>选项仅供临时使用，因为输出生成会影响性能，并且 文件会随着时间变得很大。 <code>innodb_status.*</code>pid<code>*</code></p>
<h4 id="启用InnoDB表空间监视器"><a href="#启用InnoDB表空间监视器" class="headerlink" title="启用InnoDB表空间监视器"></a>启用InnoDB表空间监视器</h4><p>要为<code>InnoDB</code>表空间监视器启用定期输出，请创建 <code>innodb_tablespace_monitor</code>表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> innodb_tablespace_monitor (a <span class="built_in">INT</span>) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span>;</span><br></pre></td></tr></table></figure>

<p>要禁用标准<code>InnoDB</code>表空间监视器，请删除表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> innodb_tablespace_monitor;</span><br></pre></td></tr></table></figure>

<p>注意</p>
<p>Tablespace Monitor已弃用，并将在以后的MySQL版本中删除。</p>
<h4 id="启用InnoDB表监视器"><a href="#启用InnoDB表监视器" class="headerlink" title="启用InnoDB表监视器"></a>启用InnoDB表监视器</h4><p>要为<code>InnoDB</code>表监视器启用定期输出，请创建<code>innodb_table_monitor</code>表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> innodb_table_monitor (a <span class="built_in">INT</span>) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span>;</span><br></pre></td></tr></table></figure>

<p>要禁用<code>InnoDB</code>表监视器，请删除表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> innodb_table_monitor;</span><br></pre></td></tr></table></figure>

<p>注意</p>
<p>Tablespace Monitor已弃用，并将在以后的MySQL版本中删除。</p>
<h3 id="14-17-3-InnoDB标准监视器和锁定监视器输出"><a href="#14-17-3-InnoDB标准监视器和锁定监视器输出" class="headerlink" title="14.17.3 InnoDB标准监视器和锁定监视器输出"></a>14.17.3 InnoDB标准监视器和锁定监视器输出</h3><p>锁定监视器与标准监视器相同，只是它包含其他锁定信息。为任一监视器启用定期输出会打开同一输出流，但是如果启用了锁定监视器，则该流将包含其他信息。例如，如果启用“标准监视器”和“锁定监视器”，则将打开单个输出流。在禁用锁定监视器之前，流中将包含其他锁定信息。</p>
<p>使用该<a href="https://dev.mysql.com/doc/refman/5.6/en/show-engine.html" target="_blank" rel="noopener"><code>SHOW ENGINE INNODB STATUS</code></a>语句生成时，Standard Monitor的输出限制为1MB 。此限制不适用于写入服务器标准错误输出（<code>stderr</code>）的输出。</p>
<p>标准监视器输出示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW ENGINE INNODB STATUS\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Type: InnoDB</span><br><span class="line">  Name:</span><br><span class="line">Status:</span><br><span class="line">=====================================</span><br><span class="line">2014-10-17 10:33:50 7f47bcd64700 INNODB MONITOR OUTPUT</span><br><span class="line">=====================================</span><br><span class="line">Per second averages calculated from the last 6 seconds</span><br><span class="line"><span class="comment">-----------------</span></span><br><span class="line">BACKGROUND THREAD</span><br><span class="line"><span class="comment">-----------------</span></span><br><span class="line">srv_master_thread loops: 167 srv_active, 0 srv_shutdown, 3023 srv_idle</span><br><span class="line">srv_master_thread log <span class="keyword">flush</span> <span class="keyword">and</span> writes: <span class="number">3190</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">SEMAPHORES</span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">OS <span class="keyword">WAIT</span> <span class="built_in">ARRAY</span> INFO: reservation <span class="keyword">count</span> <span class="number">1040</span></span><br><span class="line">OS <span class="keyword">WAIT</span> <span class="built_in">ARRAY</span> INFO: signal <span class="keyword">count</span> <span class="number">959</span></span><br><span class="line"><span class="keyword">Mutex</span> spin waits <span class="number">677</span>, rounds <span class="number">20336</span>, OS waits <span class="number">644</span></span><br><span class="line">RW-<span class="keyword">shared</span> spins <span class="number">180</span>, rounds <span class="number">5400</span>, OS waits <span class="number">180</span></span><br><span class="line">RW-excl spins <span class="number">0</span>, rounds <span class="number">6420</span>, OS waits <span class="number">214</span></span><br><span class="line">Spin rounds per <span class="keyword">wait</span>: <span class="number">30.04</span> <span class="keyword">mutex</span>, <span class="number">30.00</span> RW-<span class="keyword">shared</span>, <span class="number">6420.00</span> RW-excl</span><br><span class="line"><span class="comment">------------------------</span></span><br><span class="line">LATEST <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> <span class="keyword">ERROR</span></span><br><span class="line"><span class="comment">------------------------</span></span><br><span class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-17</span> <span class="number">09</span>:<span class="number">51</span>:<span class="number">31</span> <span class="number">7</span>f47bcde6700 <span class="keyword">Transaction</span>:</span><br><span class="line"><span class="keyword">TRANSACTION</span> <span class="number">436786</span>, ACTIVE <span class="number">0</span> sec inserting</span><br><span class="line">mysql <span class="keyword">tables</span> <span class="keyword">in</span> <span class="keyword">use</span> <span class="number">1</span>, <span class="keyword">locked</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">lock</span> <span class="keyword">struct</span>(s), <span class="keyword">heap</span> <span class="keyword">size</span> <span class="number">1184</span>, <span class="number">3</span> <span class="keyword">row</span> <span class="keyword">lock</span>(s), <span class="keyword">undo</span> <span class="keyword">log</span> entries <span class="number">3</span></span><br><span class="line">MySQL <span class="keyword">thread</span> <span class="keyword">id</span> <span class="number">1</span>, OS <span class="keyword">thread</span> handle <span class="number">0x7f47bcde6700</span>, <span class="keyword">query</span> <span class="keyword">id</span> <span class="number">96</span> localhost</span><br><span class="line">root <span class="keyword">update</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">child</span> <span class="keyword">VALUES</span></span><br><span class="line">    (<span class="literal">NULL</span>, <span class="number">1</span>)</span><br><span class="line">    , (<span class="literal">NULL</span>, <span class="number">2</span>)</span><br><span class="line">    , (<span class="literal">NULL</span>, <span class="number">3</span>)</span><br><span class="line">    , (<span class="literal">NULL</span>, <span class="number">4</span>)</span><br><span class="line">    , (<span class="literal">NULL</span>, <span class="number">5</span>)</span><br><span class="line">    , (<span class="literal">NULL</span>, <span class="number">6</span>)</span><br><span class="line"><span class="keyword">Foreign</span> <span class="keyword">key</span> <span class="keyword">constraint</span> fails <span class="keyword">for</span> <span class="keyword">table</span> <span class="string">`mysql`</span>.<span class="string">`child`</span>:</span><br><span class="line">,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`child_ibfk_1`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`parent_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`parent`</span></span><br><span class="line">  (<span class="string">`id`</span>)</span><br><span class="line"> <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span></span><br><span class="line">Trying <span class="keyword">to</span> <span class="keyword">add</span> <span class="keyword">in</span> <span class="keyword">child</span> <span class="keyword">table</span>, <span class="keyword">in</span> <span class="keyword">index</span> <span class="string">`par_ind`</span> tuple:</span><br><span class="line"><span class="keyword">DATA</span> TUPLE: <span class="number">2</span> <span class="keyword">fields</span>;</span><br><span class="line"> 0: len 4; hex 80000003; asc     ;;</span><br><span class="line"> 1: len 4; hex 80000003; asc     ;;</span><br><span class="line"></span><br><span class="line">But in parent table `mysql`.`parent`, in index `PRIMARY`,</span><br><span class="line">the closest match we can find is record:</span><br><span class="line">PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 80000004; asc     ;;</span><br><span class="line"> 1: len 6; hex 00000006aa26; asc      &amp;;;</span><br><span class="line"> 2: len 7; hex 9d000001610137; asc     a 7;;</span><br><span class="line"><span class="comment">------------------------</span></span><br><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line"><span class="comment">------------------------</span></span><br><span class="line">2014-10-17 09:52:38 7f47bcde6700</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 436801, ACTIVE 12 sec starting index read</span><br><span class="line">mysql tables in <span class="keyword">use</span> <span class="number">1</span>, <span class="keyword">locked</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">LOCK</span> <span class="keyword">WAIT</span> <span class="number">2</span> <span class="keyword">lock</span> <span class="keyword">struct</span>(s), <span class="keyword">heap</span> <span class="keyword">size</span> <span class="number">360</span>, <span class="number">1</span> <span class="keyword">row</span> <span class="keyword">lock</span>(s)</span><br><span class="line">MySQL <span class="keyword">thread</span> <span class="keyword">id</span> <span class="number">2</span>, OS <span class="keyword">thread</span> handle <span class="number">0x7f47bcda5700</span>, <span class="keyword">query</span> <span class="keyword">id</span> <span class="number">102</span> localhost</span><br><span class="line">root updating</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> i = <span class="number">1</span></span><br><span class="line">*** (<span class="number">1</span>) WAITING <span class="keyword">FOR</span> THIS <span class="keyword">LOCK</span> <span class="keyword">TO</span> BE GRANTED:</span><br><span class="line"><span class="built_in">RECORD</span> LOCKS <span class="keyword">space</span> <span class="keyword">id</span> <span class="number">3693</span> page <span class="keyword">no</span> <span class="number">3</span> n bits <span class="number">72</span> <span class="keyword">index</span> <span class="string">`GEN_CLUST_INDEX`</span> <span class="keyword">of</span></span><br><span class="line"><span class="keyword">table</span> <span class="string">`mysql`</span>.<span class="string">`t`</span> trx <span class="keyword">id</span> <span class="number">436801</span> lock_mode X waiting</span><br><span class="line"><span class="built_in">Record</span> <span class="keyword">lock</span>, <span class="keyword">heap</span> <span class="keyword">no</span> <span class="number">2</span> <span class="keyword">PHYSICAL</span> <span class="built_in">RECORD</span>: n_fields <span class="number">4</span>; compact format; info</span><br><span class="line">bits 0</span><br><span class="line"> 0: len 6; hex 000000003a00; asc     : ;;</span><br><span class="line"> 1: len 6; hex 00000006aa3f; asc      ?;;</span><br><span class="line"> 2: len 7; hex ad0000021d0110; asc        ;;</span><br><span class="line"> 3: len 4; hex 80000001; asc     ;;</span><br><span class="line"></span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 436800, ACTIVE 34 sec starting index read</span><br><span class="line">mysql tables in <span class="keyword">use</span> <span class="number">1</span>, <span class="keyword">locked</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">lock</span> <span class="keyword">struct</span>(s), <span class="keyword">heap</span> <span class="keyword">size</span> <span class="number">1184</span>, <span class="number">3</span> <span class="keyword">row</span> <span class="keyword">lock</span>(s)</span><br><span class="line">MySQL <span class="keyword">thread</span> <span class="keyword">id</span> <span class="number">1</span>, OS <span class="keyword">thread</span> handle <span class="number">0x7f47bcde6700</span>, <span class="keyword">query</span> <span class="keyword">id</span> <span class="number">103</span> localhost</span><br><span class="line">root updating</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> i = <span class="number">1</span></span><br><span class="line">*** (<span class="number">2</span>) HOLDS THE <span class="keyword">LOCK</span>(S):</span><br><span class="line"><span class="built_in">RECORD</span> LOCKS <span class="keyword">space</span> <span class="keyword">id</span> <span class="number">3693</span> page <span class="keyword">no</span> <span class="number">3</span> n bits <span class="number">72</span> <span class="keyword">index</span> <span class="string">`GEN_CLUST_INDEX`</span> <span class="keyword">of</span></span><br><span class="line"><span class="keyword">table</span> <span class="string">`mysql`</span>.<span class="string">`t`</span> trx <span class="keyword">id</span> <span class="number">436800</span> <span class="keyword">lock</span> <span class="keyword">mode</span> S</span><br><span class="line"><span class="built_in">Record</span> <span class="keyword">lock</span>, <span class="keyword">heap</span> <span class="keyword">no</span> <span class="number">1</span> <span class="keyword">PHYSICAL</span> <span class="built_in">RECORD</span>: n_fields <span class="number">1</span>; compact format; info</span><br><span class="line">bits 0 0: len 8; hex 73757072656d756d; asc supremum;;</span><br><span class="line"></span><br><span class="line">Record <span class="keyword">lock</span>, <span class="keyword">heap</span> <span class="keyword">no</span> <span class="number">2</span> <span class="keyword">PHYSICAL</span> <span class="built_in">RECORD</span>: n_fields <span class="number">4</span>; compact format; info</span><br><span class="line">bits 0</span><br><span class="line"> 0: len 6; hex 000000003a00; asc     : ;;</span><br><span class="line"> 1: len 6; hex 00000006aa3f; asc      ?;;</span><br><span class="line"> 2: len 7; hex ad0000021d0110; asc        ;;</span><br><span class="line"> 3: len 4; hex 80000001; asc     ;;</span><br><span class="line"></span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 3693 page no 3 n bits 72 index `GEN_CLUST_INDEX` of</span><br><span class="line">table `mysql`.`t` trx id 436800 lock_mode X waiting</span><br><span class="line">Record <span class="keyword">lock</span>, <span class="keyword">heap</span> <span class="keyword">no</span> <span class="number">2</span> <span class="keyword">PHYSICAL</span> <span class="built_in">RECORD</span>: n_fields <span class="number">4</span>; compact format; info</span><br><span class="line">bits 0</span><br><span class="line"> 0: len 6; hex 000000003a00; asc     : ;;</span><br><span class="line"> 1: len 6; hex 00000006aa3f; asc      ?;;</span><br><span class="line"> 2: len 7; hex ad0000021d0110; asc        ;;</span><br><span class="line"> 3: len 4; hex 80000001; asc     ;;</span><br><span class="line"></span><br><span class="line">*** WE ROLL BACK TRANSACTION (1)</span><br><span class="line"><span class="comment">------------</span></span><br><span class="line">TRANSACTIONS</span><br><span class="line"><span class="comment">------------</span></span><br><span class="line">Trx id counter 437661</span><br><span class="line"><span class="keyword">Purge</span> done <span class="keyword">for</span> trx<span class="string">'s n:o &lt; 437657 undo n:o &lt; 0 state: running but</span></span><br><span class="line"><span class="string">idle History list length 371</span></span><br><span class="line"><span class="string">LIST OF TRANSACTIONS FOR EACH SESSION:</span></span><br><span class="line"><span class="string">---TRANSACTION 0, not started</span></span><br><span class="line"><span class="string">MySQL thread id 10, OS thread handle 0x7f47bcd64700, query id 1001 localhost</span></span><br><span class="line"><span class="string">root init</span></span><br><span class="line"><span class="string">SHOW ENGINE INNODB STATUS</span></span><br><span class="line"><span class="string">---TRANSACTION 436801, not started</span></span><br><span class="line"><span class="string">MySQL thread id 2, OS thread handle 0x7f47bcda5700, query id 102 localhost</span></span><br><span class="line"><span class="string">root ceaning up</span></span><br><span class="line"><span class="string">---TRANSACTION 437660, ACTIVE 0 sec inserting</span></span><br><span class="line"><span class="string">mysql tables in use 1, locked 1</span></span><br><span class="line"><span class="string">43 lock struct(s), heap size 6544, 6474 row lock(s), undo log entries 7124</span></span><br><span class="line"><span class="string">MySQL thread id 14, OS thread handle 0x7f47bcde6700, query id 1000 localhost</span></span><br><span class="line"><span class="string">root update</span></span><br><span class="line"><span class="string">INSERT INTO `dept_emp` VALUES (100258,'</span>d002<span class="string">','</span><span class="number">1994</span><span class="number">-03</span><span class="number">-21</span><span class="string">','</span><span class="number">9999</span><span class="number">-01</span><span class="number">-01</span><span class="string">'),</span></span><br><span class="line"><span class="string">(100259, '</span>d005<span class="string">','</span><span class="number">1998</span><span class="number">-11</span><span class="number">-04</span><span class="string">','</span><span class="number">9999</span><span class="number">-01</span><span class="number">-01</span><span class="string">'),(100259,'</span>d008<span class="string">','</span><span class="number">1988</span><span class="number">-02</span><span class="number">-03</span><span class="string">',</span></span><br><span class="line"><span class="string">'</span><span class="number">1998</span><span class="number">-11</span><span class="number">-04</span><span class="string">'),(100 260,'</span>d005<span class="string">','</span><span class="number">1998</span><span class="number">-09</span><span class="number">-18</span><span class="string">','</span><span class="number">9999</span><span class="number">-01</span><span class="number">-01</span><span class="string">'),(100261,'</span>d004<span class="string">',</span></span><br><span class="line"><span class="string">'</span><span class="number">1989</span><span class="number">-03</span><span class="number">-11</span><span class="string">','</span><span class="number">9999</span><span class="number">-01</span><span class="number">-01</span><span class="string">'), (100262,'</span>d008<span class="string">','</span><span class="number">1996</span><span class="number">-08</span><span class="number">-12</span><span class="string">','</span><span class="number">9999</span><span class="number">-01</span><span class="number">-01</span><span class="string">'),</span></span><br><span class="line"><span class="string">(100263,'</span>d002<span class="string">','</span><span class="number">1998</span><span class="number">-06</span><span class="number">-24</span><span class="string">','</span><span class="number">1998</span><span class="number">-10</span><span class="number">-0</span> <span class="number">5</span><span class="string">'),(100264,'</span>d005<span class="string">','</span><span class="number">1989</span><span class="number">-11</span><span class="number">-09</span><span class="string">',</span></span><br><span class="line"><span class="string">'</span><span class="number">9999</span><span class="number">-01</span><span class="number">-01</span><span class="string">'),(100265,'</span>d001<span class="string">','</span><span class="number">1992</span><span class="number">-06</span><span class="number">-27</span><span class="string">','</span><span class="number">9999</span>- <span class="number">01</span><span class="number">-01</span><span class="string">'),(100266,'</span>d009<span class="string">',</span></span><br><span class="line"><span class="string">'</span><span class="number">1990</span><span class="number">-09</span><span class="number">-10</span><span class="string">','</span><span class="number">9999</span><span class="number">-01</span><span class="number">-01</span><span class="string">'),(100267,'</span>d009<span class="string">','</span><span class="number">1992</span><span class="number">-04</span><span class="number">-14</span><span class="string">','</span><span class="number">9</span> <span class="number">999</span><span class="number">-01</span><span class="number">-01</span><span class="string">'),</span></span><br><span class="line"><span class="string">(100268,'</span>d005<span class="string">','</span><span class="number">1998</span><span class="number">-05</span><span class="number">-01</span><span class="string">','</span><span class="number">2000</span><span class="number">-04</span><span class="number">-07</span><span class="string">'),(100269,'</span>d007<span class="string">','</span><span class="number">1994</span><span class="number">-01</span><span class="number">-02</span><span class="string">',</span></span><br><span class="line"><span class="string">'</span><span class="number">1999</span><span class="number">-09</span><span class="number">-18</span><span class="string">'),(100269,'</span>d009<span class="string">','</span><span class="number">1999</span><span class="number">-09</span>-</span><br><span class="line"><span class="comment">--------</span></span><br><span class="line"><span class="keyword">FILE</span> I/O</span><br><span class="line"><span class="comment">--------</span></span><br><span class="line">I/O <span class="keyword">thread</span> <span class="number">0</span> state: waiting <span class="keyword">for</span> completed aio requests (<span class="keyword">insert</span> buffer <span class="keyword">thread</span>)</span><br><span class="line">I/O <span class="keyword">thread</span> <span class="number">1</span> state: waiting <span class="keyword">for</span> completed aio requests (<span class="keyword">log</span> <span class="keyword">thread</span>)</span><br><span class="line">I/O <span class="keyword">thread</span> <span class="number">2</span> state: waiting <span class="keyword">for</span> completed aio requests (<span class="keyword">read</span> <span class="keyword">thread</span>)</span><br><span class="line">I/O <span class="keyword">thread</span> <span class="number">3</span> state: waiting <span class="keyword">for</span> completed aio requests (<span class="keyword">read</span> <span class="keyword">thread</span>)</span><br><span class="line">I/O <span class="keyword">thread</span> <span class="number">4</span> state: waiting <span class="keyword">for</span> completed aio requests (<span class="keyword">read</span> <span class="keyword">thread</span>)</span><br><span class="line">I/O <span class="keyword">thread</span> <span class="number">5</span> state: waiting <span class="keyword">for</span> completed aio requests (<span class="keyword">read</span> <span class="keyword">thread</span>)</span><br><span class="line">I/O <span class="keyword">thread</span> <span class="number">6</span> state: waiting <span class="keyword">for</span> completed aio requests (write <span class="keyword">thread</span>)</span><br><span class="line">I/O <span class="keyword">thread</span> <span class="number">7</span> state: waiting <span class="keyword">for</span> completed aio requests (write <span class="keyword">thread</span>)</span><br><span class="line">I/O <span class="keyword">thread</span> <span class="number">8</span> state: waiting <span class="keyword">for</span> completed aio requests (write <span class="keyword">thread</span>)</span><br><span class="line">I/O <span class="keyword">thread</span> <span class="number">9</span> state: waiting <span class="keyword">for</span> completed aio requests (write <span class="keyword">thread</span>)</span><br><span class="line">Pending <span class="keyword">normal</span> aio <span class="keyword">reads</span>: <span class="number">0</span> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>] , aio writes: <span class="number">0</span> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>] ,</span><br><span class="line"> ibuf aio <span class="keyword">reads</span>: <span class="number">0</span>, <span class="keyword">log</span> i/o<span class="string">'s: 0, sync i/o'</span>s: <span class="number">0</span></span><br><span class="line">Pending flushes (fsync) <span class="keyword">log</span>: <span class="number">0</span>; buffer pool: 0</span><br><span class="line">344 OS file reads, 45666 OS file writes, 4030 OS fsyncs</span><br><span class="line">0.00 reads/s, 0 avg bytes/read, 202.80 writes/s, 48.33 fsyncs/s</span><br><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> BUFFER <span class="keyword">AND</span> ADAPTIVE <span class="keyword">HASH</span> <span class="keyword">INDEX</span></span><br><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line">Ibuf: <span class="keyword">size</span> <span class="number">1</span>, free <span class="keyword">list</span> <span class="keyword">len</span> <span class="number">0</span>, seg <span class="keyword">size</span> <span class="number">2</span>, <span class="number">0</span> merges</span><br><span class="line">merged <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br><span class="line">discarded <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">4425293</span>, node <span class="keyword">heap</span> has <span class="number">143</span> buffer(s)</span><br><span class="line"><span class="number">137083.82</span> <span class="keyword">hash</span> searches/s, <span class="number">2495.92</span> non-<span class="keyword">hash</span> searches/s</span><br><span class="line"><span class="comment">---</span></span><br><span class="line"><span class="keyword">LOG</span></span><br><span class="line"><span class="comment">---</span></span><br><span class="line"><span class="keyword">Log</span> <span class="keyword">sequence</span> <span class="built_in">number</span> <span class="number">3091027710</span></span><br><span class="line"><span class="keyword">Log</span> flushed up <span class="keyword">to</span>   <span class="number">3090240098</span></span><br><span class="line">Pages flushed up <span class="keyword">to</span> <span class="number">3074432960</span></span><br><span class="line"><span class="keyword">Last</span> checkpoint <span class="keyword">at</span>  <span class="number">3050856266</span></span><br><span class="line"><span class="number">0</span> pending <span class="keyword">log</span> writes, <span class="number">0</span> pending chkp writes</span><br><span class="line"><span class="number">1187</span> <span class="keyword">log</span> i/o<span class="string">'s done, 14.67 log i/o'</span>s/<span class="keyword">second</span></span><br><span class="line"><span class="comment">----------------------</span></span><br><span class="line">BUFFER POOL <span class="keyword">AND</span> <span class="keyword">MEMORY</span></span><br><span class="line"><span class="comment">----------------------</span></span><br><span class="line">Total <span class="keyword">memory</span> allocated <span class="number">2197815296</span>; in additional pool allocated 0</span><br><span class="line">Dictionary memory allocated 155455</span><br><span class="line">Buffer pool size   131071</span><br><span class="line">Free buffers       92158</span><br><span class="line">Database pages     38770</span><br><span class="line">Old database pages 14271</span><br><span class="line">Modified db pages  619</span><br><span class="line">Pending reads 0</span><br><span class="line">Pending writes: LRU 0, <span class="keyword">flush</span> <span class="keyword">list</span> <span class="number">0</span>, single page <span class="number">0</span></span><br><span class="line">Pages made young <span class="number">4</span>, <span class="keyword">not</span> young <span class="number">0</span></span><br><span class="line"><span class="number">0.00</span> youngs/s, <span class="number">0.00</span> non-youngs/s</span><br><span class="line">Pages <span class="keyword">read</span> <span class="number">322</span>, created <span class="number">38448</span>, written <span class="number">42083</span></span><br><span class="line"><span class="number">0.00</span> <span class="keyword">reads</span>/s, <span class="number">222.30</span> creates/s, <span class="number">159.47</span> writes/s</span><br><span class="line">Buffer pool hit rate <span class="number">1000</span> / <span class="number">1000</span>, young-making rate <span class="number">0</span> / <span class="number">1000</span> <span class="keyword">not</span> <span class="number">0</span> / <span class="number">1000</span></span><br><span class="line">Pages <span class="keyword">read</span> ahead <span class="number">0.00</span>/s, evicted <span class="keyword">without</span> <span class="keyword">access</span> <span class="number">0.00</span>/s, Random <span class="keyword">read</span> ahead</span><br><span class="line"><span class="number">0.00</span>/s</span><br><span class="line">LRU <span class="keyword">len</span>: <span class="number">38770</span>, unzip_LRU <span class="keyword">len</span>: <span class="number">0</span></span><br><span class="line">I/O <span class="keyword">sum</span>[<span class="number">0</span>]:cur[<span class="number">0</span>], unzip <span class="keyword">sum</span>[<span class="number">0</span>]:cur[<span class="number">0</span>]</span><br><span class="line"><span class="comment">----------------------</span></span><br><span class="line">INDIVIDUAL BUFFER POOL INFO</span><br><span class="line"><span class="comment">----------------------</span></span><br><span class="line"><span class="comment">---BUFFER POOL 0</span></span><br><span class="line">Buffer pool <span class="keyword">size</span>   <span class="number">65536</span></span><br><span class="line">Free buffers       <span class="number">46120</span></span><br><span class="line"><span class="keyword">Database</span> pages     <span class="number">19345</span></span><br><span class="line"><span class="keyword">Old</span> <span class="keyword">database</span> pages <span class="number">7121</span></span><br><span class="line">Modified db pages  <span class="number">291</span></span><br><span class="line">Pending <span class="keyword">reads</span> <span class="number">0</span></span><br><span class="line">Pending writes: LRU <span class="number">0</span>, <span class="keyword">flush</span> <span class="keyword">list</span> <span class="number">0</span>, single page <span class="number">0</span></span><br><span class="line">Pages made young <span class="number">3</span>, <span class="keyword">not</span> young <span class="number">0</span></span><br><span class="line"><span class="number">0.00</span> youngs/s, <span class="number">0.00</span> non-youngs/s</span><br><span class="line">Pages <span class="keyword">read</span> <span class="number">163</span>, created <span class="number">19182</span>, written <span class="number">21149</span></span><br><span class="line"><span class="number">0.00</span> <span class="keyword">reads</span>/s, <span class="number">103.48</span> creates/s, <span class="number">83.15</span> writes/s</span><br><span class="line">Buffer pool hit rate <span class="number">1000</span> / <span class="number">1000</span>, young-making rate <span class="number">0</span> / <span class="number">1000</span> <span class="keyword">not</span> <span class="number">0</span> / <span class="number">1000</span></span><br><span class="line">Pages <span class="keyword">read</span> ahead <span class="number">0.00</span>/s, evicted <span class="keyword">without</span> <span class="keyword">access</span> <span class="number">0.00</span>/s, Random <span class="keyword">read</span> ahead</span><br><span class="line"><span class="number">0.00</span>/s</span><br><span class="line">LRU <span class="keyword">len</span>: <span class="number">19345</span>, unzip_LRU <span class="keyword">len</span>: <span class="number">0</span></span><br><span class="line">I/O <span class="keyword">sum</span>[<span class="number">0</span>]:cur[<span class="number">0</span>], unzip <span class="keyword">sum</span>[<span class="number">0</span>]:cur[<span class="number">0</span>]</span><br><span class="line"><span class="comment">---BUFFER POOL 1</span></span><br><span class="line">Buffer pool <span class="keyword">size</span>   <span class="number">65535</span></span><br><span class="line">Free buffers       <span class="number">46038</span></span><br><span class="line"><span class="keyword">Database</span> pages     <span class="number">19425</span></span><br><span class="line"><span class="keyword">Old</span> <span class="keyword">database</span> pages <span class="number">7150</span></span><br><span class="line">Modified db pages  <span class="number">328</span></span><br><span class="line">Pending <span class="keyword">reads</span> <span class="number">0</span></span><br><span class="line">Pending writes: LRU <span class="number">0</span>, <span class="keyword">flush</span> <span class="keyword">list</span> <span class="number">0</span>, single page <span class="number">0</span></span><br><span class="line">Pages made young <span class="number">1</span>, <span class="keyword">not</span> young <span class="number">0</span></span><br><span class="line"><span class="number">0.00</span> youngs/s, <span class="number">0.00</span> non-youngs/s</span><br><span class="line">Pages <span class="keyword">read</span> <span class="number">159</span>, created <span class="number">19266</span>, written <span class="number">20934</span></span><br><span class="line"><span class="number">0.00</span> <span class="keyword">reads</span>/s, <span class="number">118.81</span> creates/s, <span class="number">76.32</span> writes/s</span><br><span class="line">Buffer pool hit rate <span class="number">1000</span> / <span class="number">1000</span>, young-making rate <span class="number">0</span> / <span class="number">1000</span> <span class="keyword">not</span> <span class="number">0</span> / <span class="number">1000</span></span><br><span class="line">Pages <span class="keyword">read</span> ahead <span class="number">0.00</span>/s, evicted <span class="keyword">without</span> <span class="keyword">access</span> <span class="number">0.00</span>/s, Random <span class="keyword">read</span> ahead</span><br><span class="line"><span class="number">0.00</span>/s</span><br><span class="line">LRU <span class="keyword">len</span>: <span class="number">19425</span>, unzip_LRU <span class="keyword">len</span>: <span class="number">0</span></span><br><span class="line">I/O <span class="keyword">sum</span>[<span class="number">0</span>]:cur[<span class="number">0</span>], unzip <span class="keyword">sum</span>[<span class="number">0</span>]:cur[<span class="number">0</span>]</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line"><span class="keyword">ROW</span> <span class="keyword">OPERATIONS</span></span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line"><span class="number">0</span> queries inside <span class="keyword">InnoDB</span>, <span class="number">0</span> queries <span class="keyword">in</span> queue</span><br><span class="line"><span class="number">0</span> <span class="keyword">read</span> views <span class="keyword">open</span> inside <span class="keyword">InnoDB</span></span><br><span class="line"><span class="keyword">Main</span> <span class="keyword">thread</span> process no. <span class="number">54607</span>, <span class="keyword">id</span> <span class="number">139946075744000</span>, state: sleeping</span><br><span class="line"><span class="built_in">Number</span> <span class="keyword">of</span> <span class="keyword">rows</span> inserted <span class="number">12163964</span>, <span class="keyword">updated</span> <span class="number">0</span>, deleted <span class="number">3</span>, <span class="keyword">read</span> <span class="number">4</span></span><br><span class="line"><span class="number">67807.03</span> inserts/s, <span class="number">0.00</span> updates/s, <span class="number">0.00</span> deletes/s, <span class="number">0.00</span> <span class="keyword">reads</span>/s</span><br><span class="line"><span class="comment">----------------------------</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">OF</span> <span class="keyword">INNODB</span> MONITOR <span class="keyword">OUTPUT</span></span><br><span class="line">============================</span><br></pre></td></tr></table></figure>

<h4 id="标准监视器输出部分"><a href="#标准监视器输出部分" class="headerlink" title="标准监视器输出部分"></a>标准监视器输出部分</h4><p>有关标准监视器报告的每个度量的说明，请参阅 《<a href="https://dev.mysql.com/doc/mysql-em-plugin/en/" target="_blank" rel="noopener">Oracle Enterprise Manager for MySQL数据库用户指南》中的“ </a><a href="https://dev.mysql.com/doc/mysql-em-plugin/en/myoem-metrics.html" target="_blank" rel="noopener">度量”</a>一章 。</p>
<ul>
<li><p><code>Status</code></p>
<p>本节显示时间戳，监视器名称以及每秒平均值所基于的秒数。秒数是从当前时间到最后一次<code>InnoDB</code>打印监视器输出之间经过的时间。</p>
</li>
<li><p><code>BACKGROUND THREAD</code></p>
<p>这些<code>srv_master_thread</code>行显示了由主后台线程完成的工作。</p>
</li>
<li><p><code>SEMAPHORES</code></p>
<p>本节报告线程等待信号量的统计信息，并统计线程需要旋转或等待互斥量或rw-lock信号量的次数。等待信号量的大量线程可能是磁盘I / O或内部争用的结果<code>InnoDB</code>。争用可能是由于查询的高度并行性或操作系统线程调度中的问题。<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_thread_concurrency" target="_blank" rel="noopener"><code>innodb_thread_concurrency</code></a> 在这种情况下，将系统变量设置为 小于默认值可能会有所帮助。该<code>Spin rounds per wait</code> 行显示每个操作系统等待互斥锁的自旋锁轮数。</p>
</li>
<li><p><code>LATEST FOREIGN KEY ERROR</code></p>
<p>本节提供有关最新外键约束错误的信息。如果没有发生此类错误，则不存在。内容包括失败的语句以及有关失败的约束以及所引用和引用表的信息。</p>
</li>
<li><p><code>LATEST DETECTED DEADLOCK</code></p>
<p>本节提供有关最新死锁的信息。如果没有发生死锁，则不存在。内容显示涉及哪些事务，每个尝试执行的语句，它们拥有和需要的锁，以及哪个事务<code>InnoDB</code> 决定回滚以打破死锁。<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-locking.html" target="_blank" rel="noopener">第14.7.1节“ InnoDB锁定”</a>中说明了本节中报告的锁定模式 。</p>
</li>
<li><p><code>TRANSACTIONS</code></p>
<p>如果此部分报告锁定等待，则您的应用程序可能具有锁定争用。输出还可以帮助跟踪事务死锁的原因。</p>
</li>
<li><p><code>FILE I/O</code></p>
<p>本节提供有关<code>InnoDB</code>用于执行各种I / O的线程的信息 。其中的前几个专用于常规 <code>InnoDB</code>处理。内容还显示有关挂起的I / O操作的信息和有关I / O性能的统计信息。</p>
<p>这些线程的数量由<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_read_io_threads" target="_blank" rel="noopener"><code>innodb_read_io_threads</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_write_io_threads" target="_blank" rel="noopener"><code>innodb_write_io_threads</code></a> 参数控制 。请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html" target="_blank" rel="noopener">第14.14节“ InnoDB启动选项和系统变量”</a>。</p>
</li>
<li><p><code>INSERT BUFFER AND ADAPTIVE HASH INDEX</code></p>
<p>本部分显示 <code>InnoDB</code>插入缓冲区（也称为<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_change_buffer" target="_blank" rel="noopener">Change Buffer</a>）和自适应哈希索引的状态。</p>
<p>有关相关信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-change-buffer.html" target="_blank" rel="noopener">第14.5.2节“Change Buffer”</a>和 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-adaptive-hash.html" target="_blank" rel="noopener">第14.5.3节“自适应哈希索引”</a>。</p>
</li>
<li><p><code>LOG</code></p>
<p>本部分显示有关<code>InnoDB</code>日志的信息 。内容包括当前日志序列号，已将日志刷新到磁盘的距离以及<code>InnoDB</code>上次执行检查点的位置 。（请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-checkpoints.html" target="_blank" rel="noopener">第14.12.3节“ InnoDB检查点”</a>。）本节还显示有关挂起的写入和写入性能统计信息。</p>
</li>
<li><p><code>BUFFER POOL AND MEMORY</code></p>
<p>本节为您提供有关已读和已写页面的统计信息。您可以从这些数字中计算出查询当前正在执行多少个数据文件I / O操作。</p>
<p>有关缓冲池统计信息的描述，请参阅 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-buffer-pool.html#innodb-buffer-pool-monitoring" target="_blank" rel="noopener">使用InnoDB Standard Monitor监视缓冲池</a>。有关缓冲池操作的更多信息，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-buffer-pool.html" target="_blank" rel="noopener">第14.5.1节“缓冲池”</a>。</p>
</li>
<li><p><code>ROW OPERATIONS</code></p>
<p>本节显示了主线程在做什么，包括每种行操作的数量和性能比率。</p>
</li>
</ul>
<h3 id="14-17-4-InnoDB表空间监视器输出"><a href="#14-17-4-InnoDB表空间监视器输出" class="headerlink" title="14.17.4 InnoDB表空间监视器输出"></a>14.17.4 InnoDB表空间监视器输出</h3><p>注意</p>
<p>该<code>InnoDB</code>表空间监视器是过时的，并且可以在未来版本中删除。</p>
<p>的<code>InnoDB</code>表空间监视器打印关于共享表的文件段的信息，并验证该表空间分配数据结构。表空间监视器未描述使用该<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a>选项创建的每表文件表空间 。</p>
<p><code>InnoDB</code>表空间监视器输出 示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">================================================</span><br><span class="line">090408 21:28:09 INNODB TABLESPACE MONITOR OUTPUT</span><br><span class="line">================================================</span><br><span class="line">FILE SPACE INFO: id 0</span><br><span class="line">size 13440, free limit 3136, free extents 28</span><br><span class="line">not full frag extents 2: used pages 78, full frag extents 3</span><br><span class="line">first seg id not used 0 23845</span><br><span class="line">SEGMENT id 0 1 space 0; page 2; res 96 used 46; full ext 0</span><br><span class="line">fragm pages 32; free extents 0; not full extents 1: pages 14</span><br><span class="line">SEGMENT id 0 2 space 0; page 2; res 1 used 1; full ext 0</span><br><span class="line">fragm pages 1; free extents 0; not full extents 0: pages 0</span><br><span class="line">SEGMENT id 0 3 space 0; page 2; res 1 used 1; full ext 0</span><br><span class="line">fragm pages 1; free extents 0; not full extents 0: pages 0</span><br><span class="line">...</span><br><span class="line">SEGMENT id 0 15 space 0; page 2; res 160 used 160; full ext 2</span><br><span class="line">fragm pages 32; free extents 0; not full extents 0: pages 0</span><br><span class="line">SEGMENT id 0 488 space 0; page 2; res 1 used 1; full ext 0</span><br><span class="line">fragm pages 1; free extents 0; not full extents 0: pages 0</span><br><span class="line">SEGMENT id 0 17 space 0; page 2; res 1 used 1; full ext 0</span><br><span class="line">fragm pages 1; free extents 0; not full extents 0: pages 0</span><br><span class="line">...</span><br><span class="line">SEGMENT id 0 171 space 0; page 2; res 592 used 481; full ext 7</span><br><span class="line">fragm pages 16; free extents 0; not full extents 2: pages 17</span><br><span class="line">SEGMENT id 0 172 space 0; page 2; res 1 used 1; full ext 0</span><br><span class="line">fragm pages 1; free extents 0; not full extents 0: pages 0</span><br><span class="line">SEGMENT id 0 173 space 0; page 2; res 96 used 44; full ext 0</span><br><span class="line">fragm pages 32; free extents 0; not full extents 1: pages 12</span><br><span class="line">...</span><br><span class="line">SEGMENT id 0 601 space 0; page 2; res 1 used 1; full ext 0</span><br><span class="line">fragm pages 1; free extents 0; not full extents 0: pages 0</span><br><span class="line">NUMBER of file segments: 73</span><br><span class="line">Validating tablespace</span><br><span class="line">Validation ok</span><br><span class="line"><span class="comment">---------------------------------------</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">OF</span> <span class="keyword">INNODB</span> <span class="keyword">TABLESPACE</span> MONITOR <span class="keyword">OUTPUT</span></span><br><span class="line">=======================================</span><br></pre></td></tr></table></figure>

<p>表空间监视器输出包括有关共享表空间整体的信息，其后是一个列表，其中包含表空间内每个段的细分。</p>
<p>在此示例中，使用默认 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_page_size" target="_blank" rel="noopener">页面大小</a>，表空间由每个16KB的数据库页面组成。这些页面分为大小为1MB的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_extent" target="_blank" rel="noopener">扩展</a>区（连续64个页面）。</p>
<p>显示总体表空间信息的输出的初始部分具有以下格式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FILE SPACE INFO: id 0</span><br><span class="line">size 13440, free limit 3136, free extents 28</span><br><span class="line">not full frag extents 2: used pages 78, full frag extents 3</span><br><span class="line">first seg id not used 0 23845</span><br></pre></td></tr></table></figure>

<p>表空间的总体信息包括以下值：</p>
<ul>
<li><p><code>id</code></p>
<p>表空间ID。值为0表示共享表空间。</p>
</li>
<li><p><code>size</code></p>
<p>当前表空间大小（以页为单位）。</p>
</li>
<li><p><code>free limit</code></p>
<p>空闲列表尚未初始化的最小页码。达到或超过此限制的页面是免费的。</p>
</li>
<li><p><code>free extents</code></p>
<p>免费范围的数量。</p>
</li>
<li><p><code>not full frag extents</code>， <code>used pages</code></p>
<p>未完全填充的片段扩展区数，以及这些扩展区中已分配的页数。</p>
</li>
<li><p><code>full frag extents</code></p>
<p>完全完整的片段范围的数量。</p>
</li>
<li><p><code>first seg id not used</code></p>
<p>第一个未使用的段ID。</p>
</li>
</ul>
<p>各个细分受众群信息具有以下格式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SEGMENT id 0 15 space 0; page 2; res 160 used 160; full ext 2</span><br><span class="line">fragm pages 32; free extents 0; not full extents 0: pages 0</span><br></pre></td></tr></table></figure>

<p>细分信息包括以下值：</p>
<ul>
<li><p><code>id</code>：</p>
<p>细分ID。</p>
</li>
<li><p><code>space</code>， <code>page</code></p>
<p>表空间号和段“ inode ”所在的表空间内的页面。表空间号0表示共享表空间。 <code>InnoDB</code>使用inode来跟踪表空间中的段。为段显示的其他字段（<code>id</code>，<code>res</code>等）从inode中的信息派生。</p>
</li>
<li><p><code>res</code></p>
<p>为该段分配（保留）的页面数。</p>
</li>
<li><p><code>used</code></p>
<p>段正在使用的已分配页面数。</p>
</li>
<li><p><code>full ext</code></p>
<p>完全使用的为段分配的扩展区数。</p>
</li>
<li><p><code>fragm pages</code></p>
<p>已分配给该段的初始页面数。</p>
</li>
<li><p><code>free extents</code></p>
<p>完全未使用的为段分配的扩展区数。</p>
</li>
<li><p><code>not full extents</code></p>
<p>为该段分配的部分使用的扩展区数。</p>
</li>
<li><p><code>pages</code></p>
<p>在未满范围内使用的页面数。</p>
</li>
</ul>
<p>当一个段增长时，它从一个页面开始，并 <code>InnoDB</code>一次为其分配前几页，最多32页（这是<code>fragm pages</code> 值）。之后，<code>InnoDB</code>分配完整范围。<code>InnoDB</code>一次最多可以向一个大段中添加4个扩展区，以确保数据的良好顺序。</p>
<p>对于前面显示的示例段，它具有32个片段页面，外加2个完整扩展（每个64页），在分配的160个页面中总共使用了160个页面。以下部分包含32个片段页面和一个部分完整的范围，使用14个页面，在分配的96个页面中总共使用了46个页面：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SEGMENT id 0 1 space 0; page 2; res 96 used 46; full ext 0</span><br><span class="line">fragm pages 32; free extents 0; not full extents 1: pages 14</span><br></pre></td></tr></table></figure>

<p>如果在扩展区分配之后<code>fragm pages</code>某些个别页面已被重新分配，则为其分配扩展区的段的值可能小于32。</p>
<h3 id="14-17-5-InnoDB表监视器输出"><a href="#14-17-5-InnoDB表监视器输出" class="headerlink" title="14.17.5 InnoDB表监视器输出"></a>14.17.5 InnoDB表监视器输出</h3><p>注意</p>
<p>该<code>InnoDB</code>表监控已弃用，可能在将来的版本中删除。可以从<code>InnoDB</code> <code>INFORMATION_SCHEMA</code>表中获得类似的信息。请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-i_s-tables.html" target="_blank" rel="noopener">第21.30节“ INFORMATION_SCHEMA InnoDB表”</a>。</p>
<p>该<code>InnoDB</code>表监控打印内容<code>InnoDB</code>的内部数据字典。</p>
<p>输出每个表包含一个部分。在 <code>SYS_FOREIGN</code>与 <code>SYS_FOREIGN_COLS</code>部分是维持大约外键的信息的内部数据字典表。表监视器表和每个用户创建的<code>InnoDB</code>表也有一些部分。假设已在<code>test</code>数据库中创建以下两个表 ：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">parent</span></span><br><span class="line">(</span><br><span class="line">  par_id    <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  fname      <span class="built_in">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">  lname      <span class="built_in">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (par_id),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> (lname, fname)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">child</span></span><br><span class="line">(</span><br><span class="line">  par_id      <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  child_id    <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">name</span>        <span class="built_in">VARCHAR</span>(<span class="number">40</span>),</span><br><span class="line">  birth       <span class="built_in">DATE</span>,</span><br><span class="line">  weight      <span class="built_in">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">  misc_info   <span class="built_in">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">  last_update <span class="built_in">TIMESTAMP</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (par_id, child_id),</span><br><span class="line">  <span class="keyword">INDEX</span> (<span class="keyword">name</span>),</span><br><span class="line">  <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (par_id) <span class="keyword">REFERENCES</span> <span class="keyword">parent</span> (par_id)</span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span></span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span></span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span>;</span><br></pre></td></tr></table></figure>

<p>然后，表监视器的输出将类似于以下内容（略微更改）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">===========================================</span><br><span class="line">090420 12:09:32 INNODB TABLE MONITOR OUTPUT</span><br><span class="line">===========================================</span><br><span class="line"><span class="comment">--------------------------------------</span></span><br><span class="line">TABLE: name SYS_FOREIGN, id 0 11, columns 7, indexes 3, appr.rows 1</span><br><span class="line">  COLUMNS: ID: DATA_VARCHAR DATA_ENGLISH len 0;</span><br><span class="line">           FOR_NAME: DATA_VARCHAR DATA_ENGLISH len 0;</span><br><span class="line">           REF_NAME: DATA_VARCHAR DATA_ENGLISH len 0;</span><br><span class="line">           N_COLS: DATA_INT len 4;</span><br><span class="line">           DB_ROW_ID: DATA_SYS prtype 256 len 6;</span><br><span class="line">           DB_TRX_ID: DATA_SYS prtype 257 len 6;</span><br><span class="line">  INDEX: name ID_IND, id 0 11, fields 1/6, uniq 1, type 3</span><br><span class="line">   root page 46, appr.key vals 1, leaf pages 1, size pages 1</span><br><span class="line">   FIELDS:  ID DB_TRX_ID DB_ROLL_PTR FOR_NAME REF_NAME N_COLS</span><br><span class="line">  INDEX: name FOR_IND, id 0 12, fields 1/2, uniq 2, type 0</span><br><span class="line">   root page 47, appr.key vals 1, leaf pages 1, size pages 1</span><br><span class="line">   FIELDS:  FOR_NAME ID</span><br><span class="line">  INDEX: name REF_IND, id 0 13, fields 1/2, uniq 2, type 0</span><br><span class="line">   root page 48, appr.key vals 1, leaf pages 1, size pages 1</span><br><span class="line">   FIELDS:  REF_NAME ID</span><br><span class="line"><span class="comment">--------------------------------------</span></span><br><span class="line">TABLE: name SYS_FOREIGN_COLS, id 0 12, columns 7, indexes 1, appr.rows 1</span><br><span class="line">  COLUMNS: ID: DATA_VARCHAR DATA_ENGLISH len 0;</span><br><span class="line">           POS: DATA_INT len 4;</span><br><span class="line">           FOR_COL_NAME: DATA_VARCHAR DATA_ENGLISH len 0;</span><br><span class="line">           REF_COL_NAME: DATA_VARCHAR DATA_ENGLISH len 0;</span><br><span class="line">           DB_ROW_ID: DATA_SYS prtype 256 len 6;</span><br><span class="line">           DB_TRX_ID: DATA_SYS prtype 257 len 6;</span><br><span class="line">  INDEX: name ID_IND, id 0 14, fields 2/6, uniq 2, type 3</span><br><span class="line">   root page 49, appr.key vals 1, leaf pages 1, size pages 1</span><br><span class="line">   FIELDS:  ID POS DB_TRX_ID DB_ROLL_PTR FOR_COL_NAME REF_COL_NAME</span><br><span class="line"><span class="comment">--------------------------------------</span></span><br><span class="line">TABLE: name test/child, id 0 14, columns 10, indexes 2, appr.rows 201</span><br><span class="line">  COLUMNS: par_id: DATA_INT DATA_BINARY_TYPE DATA_NOT_NULL len 4;</span><br><span class="line">           child_id: DATA_INT DATA_BINARY_TYPE DATA_NOT_NULL len 4;</span><br><span class="line">           name: DATA_VARCHAR prtype 524303 len 40;</span><br><span class="line">           birth: DATA_INT DATA_BINARY_TYPE len 3;</span><br><span class="line">           weight: DATA_FIXBINARY DATA_BINARY_TYPE len 5;</span><br><span class="line">           misc_info: DATA_VARCHAR prtype 524303 len 255;</span><br><span class="line">           last_update: DATA_INT DATA_UNSIGNED DATA_BINARY_TYPE DATA_NOT_NULL len 4;</span><br><span class="line">           DB_ROW_ID: DATA_SYS prtype 256 len 6;</span><br><span class="line">           DB_TRX_ID: DATA_SYS prtype 257 len 6;</span><br><span class="line">  INDEX: name PRIMARY, id 0 17, fields 2/9, uniq 2, type 3</span><br><span class="line">   root page 52, appr.key vals 201, leaf pages 5, size pages 6</span><br><span class="line">   FIELDS:  par_id child_id DB_TRX_ID DB_ROLL_PTR name birth weight misc_info last_update</span><br><span class="line">  INDEX: name name, id 0 18, fields 1/3, uniq 3, type 0</span><br><span class="line">   root page 53, appr.key vals 210, leaf pages 1, size pages 1</span><br><span class="line">   FIELDS:  name par_id child_id</span><br><span class="line">  FOREIGN KEY CONSTRAINT test/child_ibfk_1: test/child ( par_id )</span><br><span class="line">             REFERENCES test/parent ( par_id )</span><br><span class="line"><span class="comment">--------------------------------------</span></span><br><span class="line">TABLE: name test/innodb_table_monitor, id 0 15, columns 4, indexes 1, appr.rows 0</span><br><span class="line">  COLUMNS: i: DATA_INT DATA_BINARY_TYPE len 4;</span><br><span class="line">           DB_ROW_ID: DATA_SYS prtype 256 len 6;</span><br><span class="line">           DB_TRX_ID: DATA_SYS prtype 257 len 6;</span><br><span class="line">  INDEX: name GEN_CLUST_INDEX, id 0 19, fields 0/4, uniq 1, type 1</span><br><span class="line">   root page 193, appr.key vals 0, leaf pages 1, size pages 1</span><br><span class="line">   FIELDS:  DB_ROW_ID DB_TRX_ID DB_ROLL_PTR i</span><br><span class="line"><span class="comment">--------------------------------------</span></span><br><span class="line">TABLE: name test/parent, id 0 13, columns 6, indexes 2, appr.rows 299</span><br><span class="line">  COLUMNS: par_id: DATA_INT DATA_BINARY_TYPE DATA_NOT_NULL len 4;</span><br><span class="line">           fname: DATA_CHAR prtype 524542 len 20;</span><br><span class="line">           lname: DATA_CHAR prtype 524542 len 20;</span><br><span class="line">           DB_ROW_ID: DATA_SYS prtype 256 len 6;</span><br><span class="line">           DB_TRX_ID: DATA_SYS prtype 257 len 6;</span><br><span class="line">  INDEX: name PRIMARY, id 0 15, fields 1/5, uniq 1, type 3</span><br><span class="line">   root page 50, appr.key vals 299, leaf pages 2, size pages 3</span><br><span class="line">   FIELDS:  par_id DB_TRX_ID DB_ROLL_PTR fname lname</span><br><span class="line">  INDEX: name lname, id 0 16, fields 2/3, uniq 2, type 2</span><br><span class="line">   root page 51, appr.key vals 300, leaf pages 1, size pages 1</span><br><span class="line">   FIELDS:  lname fname par_id</span><br><span class="line">  FOREIGN KEY CONSTRAINT test/child_ibfk_1: test/child ( par_id )</span><br><span class="line">             REFERENCES test/parent ( par_id )</span><br><span class="line"><span class="comment">-----------------------------------</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">OF</span> <span class="keyword">INNODB</span> <span class="keyword">TABLE</span> MONITOR <span class="keyword">OUTPUT</span></span><br><span class="line">==================================</span><br></pre></td></tr></table></figure>

<p>对于每个表，表监视器输出包含一个部分，该部分显示有关表的常规信息以及有关其列，索引和外键的特定信息。</p>
<p>每个表的常规信息包括表名（ 内部表以外的格式），其ID，列数和索引数以及大概的行数。 <code>*</code>db_name<code>*/*</code>tbl_name<code>*</code></p>
<p><code>COLUMNS</code>表部分 的一部分列出了表中的每一列。每列的信息指示其名称和数据类型特征。某些内部列由添加<code>InnoDB</code>，例如 <code>DB_ROW_ID</code>（行ID）， <code>DB_TRX_ID</code>（事务ID）和 <code>DB_ROLL_PTR</code>（指向回滚/撤消数据的指针）。</p>
<ul>
<li><p><code>DATA_*</code>xxx<code>*</code></p>
<p>这些符号表示数据类型。给定列可能有多个 符号。 <code>DATA_*</code>xxx<code>*</code></p>
</li>
<li><p><code>prtype</code></p>
<p>列的“ 精确 ”类型。该字段包括诸如列数据类型，字符集代码，可空性，带符号以及是否为二进制字符串之类的信息。此字段在<code>innobase/include/data0type.h</code>源文件中描述 。</p>
</li>
<li><p><code>len</code></p>
<p>列长度（以字节为单位）。</p>
</li>
</ul>
<p><code>INDEX</code>表部分的 每一部分提供一个表索引的名称和特征：</p>
<ul>
<li><p><code>name</code></p>
<p>索引名称。如果名称为<code>PRIMARY</code>，则索引为主键。如果名称为 <code>GEN_CLUST_INDEX</code>，则索引为聚集索引，如果表定义不包含主键或非<code>NULL</code> 唯一索引，则聚集索引将自动创建。请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-index-types.html" target="_blank" rel="noopener">第14.6.2.1节“聚集索引和二级索引”</a>。</p>
</li>
<li><p><code>id</code></p>
<p>索引ID。</p>
</li>
<li><p><code>fields</code></p>
<p>索引中的字段数， 格式为： <code>*</code>m<code>*/*</code>n<code>*</code></p>
<ul>
<li><em><code>m</code></em>是用户定义的列数；也就是说，您将在<code>CREATE TABLE</code> 语句的索引定义中看到的列数。</li>
<li><em><code>n</code></em>是索引列的总数，包括内部添加的索引列。对于聚集索引，总数包括表定义中的其他列，以及内部添加的所有列。对于二级索引，总数包括主键中不属于二级索引的列。</li>
</ul>
</li>
<li><p><code>uniq</code></p>
<p>足以唯一确定索引值的前导字段数。</p>
</li>
<li><p><code>type</code></p>
<p>索引类型。这是一个位字段。例如，1表示聚集索引，2表示唯一索引，因此聚集索引（始终包含唯一值）的<code>type</code>值将为3。<code>type</code>值为0 的索引 既不是聚集也不是唯一。标志值在<code>innobase/include/dict0mem.h</code>源文件中定义 。</p>
</li>
<li><p><code>root page</code></p>
<p>索引根页号。</p>
</li>
<li><p><code>appr. key vals</code></p>
<p>近似索引基数。</p>
</li>
<li><p><code>leaf pages</code></p>
<p>索引中叶子页的大概数量。</p>
</li>
<li><p><code>size pages</code></p>
<p>索引中的大约总页数。</p>
</li>
<li><p><code>FIELDS</code></p>
<p>索引中字段的名称。对于自动生成的聚集索引，字段列表以内部<code>DB_ROW_ID</code>（行ID）字段开头。 <code>DB_TRX_ID</code>并且 <code>DB_ROLL_PTR</code>总是在内部构成聚簇索引之后，紧跟构成主键的字段。对于二级索引，最终字段是主键中不属于二级索引的字段。</p>
</li>
</ul>
<p>表部分的末尾列出了<code>FOREIGN KEY</code>适用于表的定义。无论表是引用表还是引用表，都会显示此信息。</p>
<h2 id="14-21-InnoDB故障排除"><a href="#14-21-InnoDB故障排除" class="headerlink" title="14.21 InnoDB故障排除"></a>14.21 InnoDB故障排除</h2><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/error-creating-innodb.html" target="_blank" rel="noopener">14.21.1对InnoDB I / O问题进行故障排除</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/forcing-innodb-recovery.html" target="_blank" rel="noopener">14.21.2强制InnoDB恢复</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-troubleshooting-datadict.html" target="_blank" rel="noopener">14.21.3对InnoDB数据字典操作进行故障排除</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-error-handling.html" target="_blank" rel="noopener">14.21.4 InnoDB错误处理</a></li>
</ul>
<p>以下一般准则适用于故障排除 <code>InnoDB</code>问题：</p>
<ul>
<li><p>当操作失败或怀疑有错误时，请查看MySQL服务器错误日志（请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/error-log.html" target="_blank" rel="noopener">第5.4.2节“错误日志”</a>）。 <a href="https://dev.mysql.com/doc/refman/5.6/en/server-error-reference.html" target="_blank" rel="noopener">第B.3.1节“服务器错误消息参考”</a>提供了有关<code>InnoDB</code>您可能遇到的一些常见特定错误的故障排除信息 。</p>
</li>
<li><p>如果故障与<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_deadlock" target="_blank" rel="noopener">死锁</a>有关 ，请在<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_print_all_deadlocks" target="_blank" rel="noopener"><code>innodb_print_all_deadlocks</code></a> 启用该选项的情况下运行， 以便将有关每个死锁的详细信息打印到MySQL服务器错误日志中。有关死锁的信息，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-deadlocks.html" target="_blank" rel="noopener">第14.7.5节“ InnoDB中的死锁”</a>。</p>
</li>
<li><p>与<code>InnoDB</code>数据字典有关的问题包括失败的<a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a> 语句（孤立表文件），无法打开 <code>InnoDB</code>文件以及系统找不到指定的路径错误。有关此类问题和错误的信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-troubleshooting-datadict.html" target="_blank" rel="noopener">第14.21.3节“对InnoDB数据字典操作进行故障排除”</a>。</p>
</li>
<li><p>在进行故障排除时，通常最好从命令提示符下运行MySQL服务器，而不是通过 <a href="https://dev.mysql.com/doc/refman/5.6/en/mysqld-safe.html" target="_blank" rel="noopener"><strong>mysqld_safe</strong></a>或作为Windows服务运行。然后，您可以查看<a href="https://dev.mysql.com/doc/refman/5.6/en/mysqld.html" target="_blank" rel="noopener"><strong>mysqld</strong></a>打印到控制台的内容，因此可以更好地了解正在发生的情况。在Windows上，使用选项启动<a href="https://dev.mysql.com/doc/refman/5.6/en/mysqld.html" target="_blank" rel="noopener"><strong>mysqld</strong></a>以 <a href="https://dev.mysql.com/doc/refman/5.6/en/server-options.html#option_mysqld_console" target="_blank" rel="noopener"><code>--console</code></a>将输出定向到控制台窗口。</p>
</li>
<li><p>使<code>InnoDB</code>监视器能够获取有关问题的信息（请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-monitors.html" target="_blank" rel="noopener">第14.17节“ InnoDB监视器”</a>）。如果问题与性能有关，或者服务器似乎已挂起，则应启用标准监视器以打印有关的内部状态的信息<code>InnoDB</code>。如果问题出在锁上，请启用锁监视器。如果问题出在创建表或其他数据字典操作中，请启用表监视器以打印<code>InnoDB</code>内部数据字典的内容 。要查看表空间信息，请启用表空间监视器。</p>
<p><code>InnoDB``InnoDB</code>在以下情况下临时启用标准 Monitor输出：</p>
<ul>
<li>长时间的信号灯等待</li>
<li><code>InnoDB</code> 在缓冲池中找不到可用的块</li>
<li>超过67％的缓冲池被锁堆或自适应哈希索引占用</li>
</ul>
</li>
<li><p>如果怀疑表已损坏，请<a href="https://dev.mysql.com/doc/refman/5.6/en/check-table.html" target="_blank" rel="noopener"><code>CHECK TABLE</code></a>在该表上运行 。</p>
</li>
</ul>
<h3 id="14-21-1对InnoDB-I-O问题进行故障排除"><a href="#14-21-1对InnoDB-I-O问题进行故障排除" class="headerlink" title="14.21.1对InnoDB I / O问题进行故障排除"></a>14.21.1对InnoDB I / O问题进行故障排除</h3><p><code>InnoDB</code>I / O问题 的疑难解答步骤取决于问题发生的时间：在MySQL服务器启动期间，或在正常操作过程中，由于文件系统级别的问题而导致DML或DDL语句失败。</p>
<h4 id="初始化问题"><a href="#初始化问题" class="headerlink" title="初始化问题"></a>初始化问题</h4><p>如果在<code>InnoDB</code>尝试初始化其表空间或日志文件时出现问题，请删除由<code>InnoDB</code>：所有 <code>ibdata</code>文件和所有<code>ib_logfile</code>文件创建的所有 文件。如果已经创建了一些 <code>InnoDB</code>表，还请从MySQL数据库目录中删除<code>.frm</code>这些表的相应 文件，以及<code>.ibd</code>如果使用多个表空间的所有 文件。然后<code>InnoDB</code>再次尝试 创建数据库。为了最简单的故障排除，请从命令提示符启动MySQL服务器，以便了解发生了什么。</p>
<h4 id="运行时问题"><a href="#运行时问题" class="headerlink" title="运行时问题"></a>运行时问题</h4><p>如果<code>InnoDB</code>在文件操作过程中显示操作系统错误，通常该问题具有以下解决方案之一：</p>
<ul>
<li>确保<code>InnoDB</code>数据文件目录和<code>InnoDB</code>日志目录存在。</li>
<li>确保<a href="https://dev.mysql.com/doc/refman/5.6/en/mysqld.html" target="_blank" rel="noopener"><strong>mysqld</strong></a>具有在这些目录中创建文件的访问权限。</li>
<li>确保<a href="https://dev.mysql.com/doc/refman/5.6/en/mysqld.html" target="_blank" rel="noopener"><strong>mysqld</strong></a>可以读取正确的 文件<code>my.cnf</code>或<code>my.ini</code>选项文件，以便它以您指定的选项开头。</li>
<li>确保磁盘未满，并且没有超出任何磁盘配额。</li>
<li>确保为子目录和数据文件指定的名称不冲突。</li>
<li>仔细检查<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_data_home_dir" target="_blank" rel="noopener"><code>innodb_data_home_dir</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_data_file_path" target="_blank" rel="noopener"><code>innodb_data_file_path</code></a>值的语法 。特别是，<code>MAX</code>该<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_data_file_path" target="_blank" rel="noopener"><code>innodb_data_file_path</code></a>选项中的任何值 都是硬限制，超过该限制会导致致命错误。</li>
</ul>
<h3 id="14-21-2强制InnoDB恢复"><a href="#14-21-2强制InnoDB恢复" class="headerlink" title="14.21.2强制InnoDB恢复"></a>14.21.2强制InnoDB恢复</h3><p>要调查数据库页面损坏，您可以使用来从数据库中转储表 <a href="https://dev.mysql.com/doc/refman/5.6/en/select-into.html" target="_blank" rel="noopener"><code>SELECT ... INTO OUTFILE</code></a>。通常，以这种方式获得的大多数数据都是完整的。严重损坏可能导致语句或 后台操作崩溃或断言，甚至导致前滚恢复崩溃。在这种情况下，您可以使用该 选项在阻止后台操作运行的同时强制启动存储引擎，以便转储表。例如，您可以在重新启动服务器之前将以下行添加到选项文件的部分中： <code>SELECT * FROM *</code>tbl_name<code>*``InnoDB``InnoDB</code><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_force_recovery" target="_blank" rel="noopener"><code>innodb_force_recovery</code></a><code>InnoDB``[mysqld]</code></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">innodb_force_recovery</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>有关使用选项文件的信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/option-files.html" target="_blank" rel="noopener">第4.2.2.2节“使用选项文件”</a>。</p>
<p>警告</p>
<p>仅<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_force_recovery" target="_blank" rel="noopener"><code>innodb_force_recovery</code></a> 在紧急情况下设置为大于0的值，以便您可以启动<code>InnoDB</code>和转储表。这样做之前，请确保您拥有数据库的备份副本，以防万一您需要重新创建它。值大于等于4可能会永久损坏数据文件。<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_force_recovery" target="_blank" rel="noopener"><code>innodb_force_recovery</code></a>在数据库的单独物理副本上成功测试设置之后，请仅在生产服务器实例上使用 4或更大的设置。强制<code>InnoDB</code>恢复时，应始终从头开始， <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_force_recovery" target="_blank" rel="noopener"><code>innodb_force_recovery=1</code></a>并根据需要仅逐渐增加该值。</p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_force_recovery" target="_blank" rel="noopener"><code>innodb_force_recovery</code></a>默认情况下为0（正常启动而不强制恢复）。允许的非零值 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_force_recovery" target="_blank" rel="noopener"><code>innodb_force_recovery</code></a>是1到6。较大的值包括较小值的功能。例如，值3包含值1和2的所有功能。</p>
<p>如果能够转储 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_force_recovery" target="_blank" rel="noopener"><code>innodb_force_recovery</code></a>值为3或更小的表，则相对安全的是，仅丢失损坏的单个页面上的某些数据。4或更大的值被认为是危险的，因为数据文件可能会永久损坏。值6被认为是过大的，因为数据库页面处于过时状态，这反过来可能会使<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_b_tree" target="_blank" rel="noopener">B树</a> 和其他数据库结构遭受更多破坏。</p>
<p>为了安全起见，请<code>InnoDB</code>防止 <a href="https://dev.mysql.com/doc/refman/5.6/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>， <a href="https://dev.mysql.com/doc/refman/5.6/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>或 <a href="https://dev.mysql.com/doc/refman/5.6/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>在<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_force_recovery" target="_blank" rel="noopener"><code>innodb_force_recovery</code></a>大于0 时进行操作 。从MySQL 5.6.15开始， 在只读模式下<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_force_recovery" target="_blank" rel="noopener"><code>innodb_force_recovery</code></a>设置4个或更多位置<code>InnoDB</code>。</p>
<ul>
<li><p><code>1</code> （<code>SRV_FORCE_IGNORE_CORRUPT</code>）</p>
<p>使服务器即使检测到损坏的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_page" target="_blank" rel="noopener">页面</a>也可以运行 。尝试 跳过损坏的索引记录和页，这有助于转储表。 <code>SELECT * FROM *</code>tbl_name<code>*</code></p>
</li>
<li><p><code>2</code> （<code>SRV_FORCE_NO_BACKGROUND</code>）</p>
<p>阻止<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_master_thread" target="_blank" rel="noopener">主线程</a>和任何<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_purge_thread" target="_blank" rel="noopener">清除线程</a>运行。如果在<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_purge" target="_blank" rel="noopener">清除</a>操作期间发生崩溃，则此恢复值可防止崩溃 。</p>
</li>
<li><p><code>3</code> （<code>SRV_FORCE_NO_TRX_UNDO</code>）</p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_crash_recovery" target="_blank" rel="noopener">崩溃恢复</a>后 不运行事务 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_rollback" target="_blank" rel="noopener">回滚</a>。</p>
</li>
<li><p><code>4</code> （<code>SRV_FORCE_NO_IBUF_MERGE</code>）</p>
<p>防止<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_insert_buffer" target="_blank" rel="noopener">插入缓冲区</a>合并操作。如果它们会导致崩溃，请不要这样做。不计算表 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_statistics" target="_blank" rel="noopener">统计信息</a>。此值可能会永久损坏数据文件。使用此值后，准备删除并重新创建所有二级索引。从MySQL 5.6.15开始，设置<code>InnoDB</code>为只读。</p>
</li>
<li><p><code>5</code> （<code>SRV_FORCE_NO_UNDO_LOG_SCAN</code>）</p>
<p>启动数据库时 不查看<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_undo_log" target="_blank" rel="noopener">Undo Log</a>： <code>InnoDB</code>甚至将未完成的事务也视为已提交。此值可能会永久损坏数据文件。从MySQL 5.6.15开始，设置<code>InnoDB</code>为只读。</p>
</li>
<li><p><code>6</code> （<code>SRV_FORCE_NO_LOG_REDO</code>）</p>
<p>不进行与<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_redo_log" target="_blank" rel="noopener">恢复</a>有关的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_redo_log" target="_blank" rel="noopener">Redo Log前</a> 滚。此值可能会永久损坏数据文件。使数据库页面处于过时状态，从而可能导致B树和其他数据库结构遭受更多破坏。从MySQL 5.6.15开始，设置<code>InnoDB</code>为只读。</p>
</li>
</ul>
<p>您可以<a href="https://dev.mysql.com/doc/refman/5.6/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>从表中转储它们。随着 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_force_recovery" target="_blank" rel="noopener"><code>innodb_force_recovery</code></a>3或更低就可以值<code>DROP</code>或 <code>CREATE</code>表。从MySQL 5.6.27开始， <a href="https://dev.mysql.com/doc/refman/5.6/en/drop-table.html" target="_blank" rel="noopener"><code>DROP TABLE</code></a>还支持<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_force_recovery" target="_blank" rel="noopener"><code>innodb_force_recovery</code></a>大于3 的值。</p>
<p>如果您知道给定的表导致回滚崩溃，则可以将其删除。如果遇到由于批量导入或失败而导致的失控回滚<a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>，则可以<a href="https://dev.mysql.com/doc/refman/5.6/en/mysqld.html" target="_blank" rel="noopener"><strong>终止mysqld</strong></a>进程并设置 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_force_recovery" target="_blank" rel="noopener"><code>innodb_force_recovery</code></a>为 <code>3</code>不回滚就启动数据库，然后<code>DROP</code>启动导致失控回滚的表。</p>
<p>如果表数据中的损坏阻止您转储整个表内容，则带有子句的查询可能能够转储损坏部分后的表部分。 <code>ORDER BY *</code>primary_key<code>* DESC</code></p>
<p>如果一个高<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_force_recovery" target="_blank" rel="noopener"><code>innodb_force_recovery</code></a> 值是必需的开始<code>InnoDB</code>，有可能是，可能导致（含有查询的复杂查询损坏的数据结构<code>WHERE</code>，<code>ORDER BY</code>或其它条款）失败。在这种情况下，您可能只能运行基本<code>SELECT * FROM t</code> 查询。</p>
<h3 id="14-21-3对InnoDB数据字典操作进行故障排除"><a href="#14-21-3对InnoDB数据字典操作进行故障排除" class="headerlink" title="14.21.3对InnoDB数据字典操作进行故障排除"></a>14.21.3对InnoDB数据字典操作进行故障排除</h3><p>有关表定义的信息既存储在<code>.frm</code>文件中，又存储 在InnoDB <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_data_dictionary" target="_blank" rel="noopener">数据字典中</a>。如果您移动<code>.frm</code>文件，或者服务器在数据字典操作过程中崩溃，则这些信息源可能会变得不一致。</p>
<p>如果数据字典损坏或一致性问题使您无法启动<code>InnoDB</code>，请参阅 <a href="https://dev.mysql.com/doc/refman/5.6/en/forcing-innodb-recovery.html" target="_blank" rel="noopener">第14.21.2节“强制InnoDB恢复”</a>以获取有关手动恢复的信息。</p>
<h4 id="由于孤立表导致CREATE-TABLE失败"><a href="#由于孤立表导致CREATE-TABLE失败" class="headerlink" title="由于孤立表导致CREATE TABLE失败"></a>由于孤立表导致CREATE TABLE失败</h4><p>数据字典不同步的症状是 <a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>语句失败。如果发生这种情况，请查看服务器的错误日志。如果日志表明<code>InnoDB</code>内部数据字典中已经存在该 表，则<code>InnoDB</code>表空间文件中有一个孤立表，该表没有相应的<code>.frm</code>文件。错误消息如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">InnoDB: Error: table test/parent already exists in InnoDB internal</span><br><span class="line">InnoDB: data dictionary. Have you deleted the .frm file</span><br><span class="line">InnoDB: and not used DROP TABLE? Have you used DROP DATABASE</span><br><span class="line">InnoDB: for InnoDB tables in MySQL version &lt;= 3.23.43?</span><br><span class="line">InnoDB: See the Restrictions section of the InnoDB manual.</span><br><span class="line">InnoDB: You can drop the orphaned table inside InnoDB by</span><br><span class="line">InnoDB: creating an InnoDB table with the same name in another</span><br><span class="line">InnoDB: database and moving the .frm file to the current database.</span><br><span class="line">InnoDB: Then MySQL thinks the table exists, and DROP TABLE will</span><br><span class="line">InnoDB: succeed.</span><br></pre></td></tr></table></figure>

<p>您可以按照错误消息中给出的说明删除孤立表。如果仍然无法<a href="https://dev.mysql.com/doc/refman/5.6/en/drop-table.html" target="_blank" rel="noopener"><code>DROP TABLE</code></a>成功使用 ，则问题可能是由于<a href="https://dev.mysql.com/doc/refman/5.6/en/mysql.html" target="_blank" rel="noopener"><strong>mysql</strong></a>客户端中的名称完成 。要解决此问题，请使用 选项启动<a href="https://dev.mysql.com/doc/refman/5.6/en/mysql.html" target="_blank" rel="noopener"><strong>mysql</strong></a>客户端， <a href="https://dev.mysql.com/doc/refman/5.6/en/mysql-command-options.html#option_mysql_auto-rehash" target="_blank" rel="noopener"><code>--skip-auto-rehash</code></a>然后重试<a href="https://dev.mysql.com/doc/refman/5.6/en/drop-table.html" target="_blank" rel="noopener"><code>DROP TABLE</code></a>。（启用名称完成功能后，<a href="https://dev.mysql.com/doc/refman/5.6/en/mysql.html" target="_blank" rel="noopener"><strong>mysql</strong></a>试图构造一个表名称列表，当存在上述问题时，该列表将失败。）</p>
<h4 id="无法打开文件错误"><a href="#无法打开文件错误" class="headerlink" title="无法打开文件错误"></a>无法打开文件错误</h4><p>数据字典不同步的另一个症状是MySQL打印出一个无法打开<code>InnoDB</code>文件的错误 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1016: Can&apos;t open file: &apos;child2.ibd&apos;. (errno: 1)</span><br></pre></td></tr></table></figure>

<p>在错误日志中，您可以找到以下消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InnoDB: Cannot find table test/child2 from the internal data dictionary</span><br><span class="line">InnoDB: of InnoDB though the .frm file for the table exists. Maybe you</span><br><span class="line">InnoDB: have deleted and recreated InnoDB data files but have forgotten</span><br><span class="line">InnoDB: to delete the corresponding .frm files of InnoDB tables?</span><br></pre></td></tr></table></figure>

<p>这意味着存在一个孤立<code>.frm</code> 文件，里面没有对应的表 <code>InnoDB</code>。您可以<code>.frm</code>通过手动删除孤立 文件来删除它。</p>
<h4 id="孤立的中间表"><a href="#孤立的中间表" class="headerlink" title="孤立的中间表"></a>孤立的中间表</h4><p>如果MySQL在就地<a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>操作（<code>ALGORITHM=INPLACE</code>）中间退出，则 可能会留下孤立的中间表，该表占用了系统空间。本节介绍如何识别和删除孤立的中间表。</p>
<p>中间表名称以<code>#sql-ib</code>前缀（例如 <code>#sql-ib87-856498050</code>）开头 。随附 <code>.frm</code>文件具有 <code>#sql-*</code>前缀，并且命名不同（例如<code>#sql-36ab_2.frm</code>）。</p>
<p>要识别系统上的孤立中间表，可以查看<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-monitors.html" target="_blank" rel="noopener">表监视器的</a>输出或查询 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-sys-tables-table.html" target="_blank" rel="noopener"><code>INFORMATION_SCHEMA.INNODB_SYS_TABLES</code></a>。查找以开头的表名<code>#sql</code>。如果原始表位于 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_file_per_table" target="_blank" rel="noopener">每个</a> 表文件<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_file_per_table" target="_blank" rel="noopener">表</a>空间中，<code>#sql-*.ibd</code>则孤立中间表的表空间文件（该 文件）应在数据库目录中可见。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_SYS_TABLES <span class="keyword">WHERE</span> <span class="keyword">NAME</span> <span class="keyword">LIKE</span> <span class="string">'%#sql%'</span>;</span><br></pre></td></tr></table></figure>

<p>要删除孤立的中间表，请执行以下步骤：</p>
<ol>
<li><p>在数据库目录中，重命名 <code>#sql-*.frm</code>文件以匹配孤立中间表的基本名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; mv #sql-36ab_2.frm #sql-ib87-856498050.frm</span><br></pre></td></tr></table></figure>

<p>注意</p>
<p>如果没有<code>.frm</code>文件，则可以重新创建它。该<code>.frm</code>文件必须具有与孤立中间表相同的表架构（它必须具有相同的列和索引），并且必须放置在孤立中间表的数据库目录中。</p>
</li>
<li><p>通过发出一条<a href="https://dev.mysql.com/doc/refman/5.6/en/drop-table.html" target="_blank" rel="noopener"><code>DROP TABLE</code></a>语句，在表名前面加上前缀 <code>#mysql50#</code>并将表名括在反引号中来删除孤立的中间表 。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DROP TABLE `#mysql50##sql-ib87-856498050`;</span><br></pre></td></tr></table></figure>

<p>该<code>#mysql50#</code>前缀告诉MySQL忽略<code>file name safe encoding</code>在MySQL 5.1中引入的。要对具有特殊字符（例如，“ ＃ ”）的表名执行SQL语句，需要将表名括在反引号中。</p>
</li>
</ol>
<h4 id="孤儿临时表"><a href="#孤儿临时表" class="headerlink" title="孤儿临时表"></a>孤儿临时表</h4><p>如果MySQL在表复制<a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>操作（<code>ALGORITHM=COPY</code>）中间退出，则 可能会留下一个孤立的临时表，该表会占用系统空间。本节介绍如何识别和删除孤立的临时表。</p>
<p>孤立的临时表名称以<code>#sql-</code>前缀（例如 <code>#sql-540_3</code>）开头 。随附 <code>.frm</code>文件的名称与孤立临时表的名称相同。</p>
<p>注意</p>
<p>如果没有<code>.frm</code>文件，则可以重新创建它。该<code>.frm</code>文件必须具有与孤立临时表相同的表架构（它必须具有相同的列和索引），并且必须放置在孤立临时表的数据库目录中。</p>
<p>要在系统上标识孤立的临时表，可以查看 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-monitors.html" target="_blank" rel="noopener">表监视器的</a>输出或查询 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-sys-tables-table.html" target="_blank" rel="noopener"><code>INFORMATION_SCHEMA.INNODB_SYS_TABLES</code></a>。查找以开头的表名<code>#sql</code>。如果原始表位于 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_file_per_table" target="_blank" rel="noopener">每个</a> 表文件<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_file_per_table" target="_blank" rel="noopener">表</a>空间中，<code>#sql-*.ibd</code>则孤立临时表的表空间文件（该 文件）应该在数据库目录中可见。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_SYS_TABLES <span class="keyword">WHERE</span> <span class="keyword">NAME</span> <span class="keyword">LIKE</span> <span class="string">'%#sql%'</span>;</span><br></pre></td></tr></table></figure>

<p>要删除孤立的临时表，请通过发出一条<a href="https://dev.mysql.com/doc/refman/5.6/en/drop-table.html" target="_blank" rel="noopener"><code>DROP TABLE</code></a>语句来删除该表，在该表 名的前面加上前缀，<code>#mysql50#</code>并将表名括在反引号中。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DROP TABLE `#mysql50##sql-540_3`;</span><br></pre></td></tr></table></figure>

<p>该<code>#mysql50#</code>前缀告诉MySQL忽略 <code>file name safe encoding</code>在MySQL 5.1中引入的。要对具有特殊字符（例如，“ ＃ ”）的表名执行SQL语句，需要将表名括在反引号中。</p>
<h4 id="表空间不存在"><a href="#表空间不存在" class="headerlink" title="表空间不存在"></a>表空间不存在</h4><p>与<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a> 启用，如果可能会出现以下消息 <code>.frm</code>或<code>.ibd</code>文件（或两者）丢失：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InnoDB: in InnoDB data dictionary has tablespace id N,</span><br><span class="line">InnoDB: but tablespace with that id or name does not exist. Have</span><br><span class="line">InnoDB: you deleted or moved .ibd files?</span><br><span class="line">InnoDB: This may also be a table created with CREATE TEMPORARY TABLE</span><br><span class="line">InnoDB: whose .ibd and .frm files MySQL automatically removed, but the</span><br><span class="line">InnoDB: table still exists in the InnoDB internal data dictionary.</span><br></pre></td></tr></table></figure>

<p>如果发生这种情况，请尝试以下步骤解决问题：</p>
<ol>
<li><code>.frm</code>在其他一些数据库目录中 创建一个匹配文件，并将其复制到孤立表所在的数据库目录中。</li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/drop-table.html" target="_blank" rel="noopener"><code>DROP TABLE</code></a>原始表的 发行。那应该成功删除该表，并且 <code>InnoDB</code>应该在错误日志中显示一条警告，指出该<code>.ibd</code>文件已丢失。</li>
</ol>
<h4 id="恢复每表孤立文件ibd文件"><a href="#恢复每表孤立文件ibd文件" class="headerlink" title="恢复每表孤立文件ibd文件"></a>恢复每表孤立文件ibd文件</h4><p>此过程描述了如何将<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_file_per_table" target="_blank" rel="noopener">每表</a> 孤立<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_file_per_table" target="_blank" rel="noopener">文件</a>还原 <code>.ibd</code>到另一个MySQL实例。如果系统表空间丢失或不可恢复，并且要<code>.ibd</code> 在新的MySQL实例上还原文件备份，则可以使用此过程。</p>
<p>该过程假定您只有 <code>.ibd</code>文件备份，并且要恢复到最初创建孤立<code>.ibd</code>文件的MySQL版本 ，并且 <code>.ibd</code>文件备份是干净的。有关创建干净备份的信息<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-migration.html" target="_blank" rel="noopener">，</a>请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-migration.html" target="_blank" rel="noopener">第14.6.1.4节“移动或复制InnoDB表”</a>。</p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-table-import.html" target="_blank" rel="noopener">第14.6.1.3节“导入InnoDB表”</a>中 概述的表导入限制 适用于此过程。</p>
<ol>
<li><p>在新的MySQL实例上，在同名数据库中重新创建表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE sakila;</span><br><span class="line"></span><br><span class="line">mysql&gt; USE sakila;</span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE actor (</span><br><span class="line">         actor_id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">         first_name VARCHAR(45) NOT NULL,</span><br><span class="line">         last_name VARCHAR(45) NOT NULL,</span><br><span class="line">         last_update TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">         PRIMARY <span class="keyword">KEY</span>  (actor_id),</span><br><span class="line">         <span class="keyword">KEY</span> idx_actor_last_name (last_name)</span><br><span class="line">       )<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>
</li>
<li><p>丢弃新创建的表的表空间。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE sakila.actor DISCARD TABLESPACE;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将孤立<code>.ibd</code>文件从备份目录复制到新的数据库目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; cp /backup_directory/actor.ibd path/to/mysql-5.6/data/sakila/</span><br></pre></td></tr></table></figure>
</li>
<li><p>确保<code>.ibd</code>文件具有必要的文件权限。</p>
</li>
<li><p>导入孤立<code>.ibd</code>文件。发出警告，指示<code>InnoDB</code>将尝试在不进行模式验证的情况下导入文件。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE sakila.actor IMPORT TABLESPACE; SHOW WARNINGS;    </span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.15 sec)</span><br><span class="line"></span><br><span class="line">Warning | 1810 | InnoDB: IO Read error: (2, No such file or directory)</span><br><span class="line">Error opening './sakila/actor.cfg', will attempt to import</span><br><span class="line">without schema verification</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询表以确认<code>.ibd</code> 文件已成功还原。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT COUNT(*) FROM sakila.actor;</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| count(*) |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">|      200 |</span><br><span class="line">+<span class="comment">----------+</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="14-21-4-InnoDB错误处理"><a href="#14-21-4-InnoDB错误处理" class="headerlink" title="14.21.4 InnoDB错误处理"></a>14.21.4 InnoDB错误处理</h3><p>以下各项描述了如何<code>InnoDB</code> 执行错误处理。<code>InnoDB</code>有时仅回滚失败的语句，而其他时候回滚整个事务。</p>
<ul>
<li><p>如果<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_tablespace" target="_blank" rel="noopener">表</a>空间中的文件空间用完 ，<code>Table is full</code>则会发生MySQL 错误并 <code>InnoDB</code>回滚SQL语句。</p>
</li>
<li><p>一个事务<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_deadlock" target="_blank" rel="noopener">死锁</a> 导致<code>InnoDB</code>要 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_rollback" target="_blank" rel="noopener">回滚</a>整个 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_transaction" target="_blank" rel="noopener">事务</a>。发生这种情况时，请重试整个事务。</p>
<p>锁定等待超时导致<code>InnoDB</code>仅回滚正在等待锁定且遇到超时的单个语句。（要使整个事务回滚，请使用<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_rollback_on_timeout" target="_blank" rel="noopener"><code>--innodb-rollback-on-timeout</code></a> 选项启动服务器 。）如果使用当前行为，请重试该语句；如果使用，请重试该事务 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_rollback_on_timeout" target="_blank" rel="noopener"><code>--innodb-rollback-on-timeout</code></a>。</p>
<p>死锁和锁等待超时在繁忙的服务器上都是正常的，应用程序必须意识到它们可能发生并通过重试来处理它们。您可以通过在事务期间第一次更改数据和提交之间进行尽可能少的工作来减少它们的可能性，因此将锁保持在最短的时间内，并且行的数量最少。有时，在不同交易之间分配工作可能是实用且有用的。</p>
<p>当由于死锁或锁定等待超时而导致事务回滚时，它将取消事务中语句的影响。但是，如果start-transaction语句为 <a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>START TRANSACTION</code></a>或 <a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>BEGIN</code></a> 语句，则回滚不会取消该语句。进一步的SQL语句成为交易的一部分，直到发生<a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a>， <a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>ROLLBACK</code></a>或某些SQL语句导致隐式提交。</p>
</li>
<li><p>如果未<code>IGNORE</code>在语句中指定选项，则重复键错误会回滚SQL 语句。</p>
</li>
<li><p>一个<code>row too long error</code>回滚SQL语句。</p>
</li>
<li><p>其他错误大多数由MySQL代码层（在<code>InnoDB</code>存储引擎级别之上）检测到，并且它们回滚相应的SQL语句。在单个SQL语句的回滚中不会释放锁。</p>
</li>
</ul>
<p>在隐式回滚期间以及在执行显式 <a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>ROLLBACK</code></a>SQL语句期间，将在相关连接的 列中<a href="https://dev.mysql.com/doc/refman/5.6/en/show-processlist.html" target="_blank" rel="noopener"><code>SHOW PROCESSLIST</code></a> 显示。 <code>Rolling back``State</code></p>
<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>




          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/message-queue/kafka/2-kafka-concept-and-role/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="-CarloZ">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CarloZ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/message-queue/kafka/2-kafka-concept-and-role/" itemprop="url">2、kafka中的概念和角色</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-02T00:00:00+08:00">
                2018-12-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mq/" itemprop="url" rel="index">
                    <span itemprop="name">mq</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mq/kafka/" itemprop="url" rel="index">
                    <span itemprop="name">kafka</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<br>

<h1 id="Kafka-broker-和-集群"><a href="#Kafka-broker-和-集群" class="headerlink" title="Kafka broker 和 集群"></a>Kafka broker 和 集群</h1><p>kafka架构图：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191014170528.png" alt></p>
<ul>
<li>生产者发送消息给kafka服务器；</li>
<li>消费者从kafka服务器读取消息；</li>
<li>kafka服务器依托zookeeper集群进行服务的协调管理；</li>
</ul>
<h3 id="broker-——-kafka服务器的官方名字"><a href="#broker-——-kafka服务器的官方名字" class="headerlink" title="broker —— kafka服务器的官方名字"></a>broker —— kafka服务器的官方名字</h3><p>一个独立的kafka服务器被称为broker；broker用来接收来自生产者的消息，为消息设置偏移量，并把消息保存到磁盘；</p>
<p>换句话说，多个kafka实例组成kafka集群；</p>
<p>kafka集群、broker、主题及分区、生产者、消费者 关系示意图：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191014172924.png" alt></p>
<p><u><strong>broker中央控制器</strong></u>：kafka集群中由多个broker，在kafka启动时，只有一个会被选举为broker中央控制器（controller leader）；</p>
<p><u><strong>broker中央控制器选举过程</strong></u>：当broker启动的时候，都会创建KafkaController对象，但集群中只能由一个leader对外服务，这些每个节点上的KafkaController会在指定的zookeeper路径下创建临时节点，只有第一个成功创建的节点的KafkaController才可以称为leader，其余的都是follower。当leader故障后，所有的follower都会收到通知，再次竞争在该路径下创建节点从而选举新的leader；</p>
<p><u><strong>中央控制器的工作</strong></u>：</p>
<ul>
<li>管理整个集群中的分区；</li>
<li>监控副本的状态；</li>
</ul>
<p>这些工作如：</p>
<ul>
<li>leader副本故障后，由中央控制器 <u>负责为该partition重新选举新的leader副本</u>；</li>
<li>当检测到同步列表发生变化后，由中央控制器 <u>通知集群中所有leader更新其元数据缓存信息</u>；</li>
<li>当增加某个topic分区的时候也会由中央控制器管理 <u>分区的重新分配工作</u>；</li>
</ul>
<br>



<h1 id="Kafka-主题-和-分区"><a href="#Kafka-主题-和-分区" class="headerlink" title="Kafka 主题 和 分区"></a>Kafka 主题 和 分区</h1><p>消息、主题（topic）、分区（partition）、副本（replica）</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191015103727.png" alt></p>
<br>

<h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>kafka的消息个是经过3次版本变迁，分别被称为 V0，V1，V2；</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191015111223.png" alt></p>
<p>3个主要字段的含义：</p>
<ul>
<li>Key：消息键，对消息做 partition 时使用，即决定消息被保存在某个 topic 下那个 partition；</li>
<li>Value：消息体，保存实际的消息数据；</li>
<li>Timestamp：消息发送时间戳，用于流式处理 及 其他依赖时间的处理语义。如果不指定则取当前时间；</li>
<li>属性：一共1Byte，目前只用了最低的3bit来做压缩类型的存储；</li>
<li>CRC32校验码</li>
</ul>
<p>Kafka消息设计的好处：</p>
<p>1、使用 紧凑的二进制数组 Bytebuffer 而不是独立的对象，因此我们至少能够访问多一倍的可用内存；</p>
<p>2、而且不在堆上分配内存，避免了GC的糟糕性能；</p>
<p>3、大量使用页缓存，当broker进程崩溃时，堆内存上的数据也一并消失，但页缓存的数据依然存在；下次broker重启后可以继续提供服务，不用单独在热缓存；</p>
<br>

<h3 id="主题（topic）和-分区（partition）"><a href="#主题（topic）和-分区（partition）" class="headerlink" title="主题（topic）和 分区（partition）"></a>主题（topic）和 分区（partition）</h3><p><u><strong>topic</strong></u> ：只是一个逻辑概念，代表了一类消息。通常 topic 用来区分实际业务；</p>
<p><u><strong>partition</strong></u>：每个topic都由若干个 partition 组成；</p>
<ul>
<li>partition 是<u><strong>不可修改的有序消息序列</strong></u>，也可以说是有序的消息日志；</li>
<li>每个partition 都有自己专属的 partition号，通常是从0开始的；</li>
<li>用户堆 partition 唯一能做的操作就是 在 <u><strong>消息序列的尾部 追加写入消息</strong></u>；</li>
<li>partition 上的每条消息都会被分配一个唯一的序列号，该序列号被称为<u><strong>位移（offset）</strong></u>；</li>
</ul>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191015120222.png" alt></p>
<p>partition 实际上并没有太多的业务含义，<u><strong>partition的引入 只是为了提升系统的吞吐量</strong></u>；可以根据集群的实际配置设置具体的partition数，实现整体性能最大化；</p>
<br>

<h3 id="位移（offset）"><a href="#位移（offset）" class="headerlink" title="位移（offset）"></a>位移（offset）</h3><p>topic partition 下的每条消息都被分配一个位移值；kafka 消费端也有 位移（offset）的概念；</p>
<p>要注意区分这两offset 的不同含义：</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191015120512.png" alt></p>
<p>由此我们可以断言， 一条消息就是一个三元组&lt;topic，partition，offset&gt;</p>
<br>

<h3 id="副本（replica）"><a href="#副本（replica）" class="headerlink" title="副本（replica）"></a>副本（replica）</h3><p>分布式系统为了实现高可靠性，目前主要实现方式还是 <u><strong>冗余机制</strong></u>；即备份多份日志；这些备份日志在 kafka 中被称为 <u><strong>副本（replica）</strong></u>；</p>
<p>副本存在的唯一目的：防止数据丢失；</p>
<p>副本分两类：领导者副本（leader replica） 和 追随者副本（follower replica）；</p>
<p>follower replica 不能给客户端提供服务，只是被动的 向 leader replica 获取数据；</p>
<p>一旦 leader replica 所在的 broker 宕机，kafka 会从 剩余的replica中选举出新的 leader 继续提供服务；</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191015144451.png" alt></p>
<br>

<h3 id="ISR（in-sync-replica）"><a href="#ISR（in-sync-replica）" class="headerlink" title="ISR（in-sync replica）"></a>ISR（in-sync replica）</h3><p>ISR 全称 in-sync replica，翻译过来就是 <u><strong>与 leader replica 保持同步的 replica集合</strong></u>；</p>
<p>注意：不是所有的 replica 都能与 leader replica 保持同步；</p>
<p>kafka 为 partition 动态维护一个 replica 集合 —— 该集合中所有的replica保存的消息日志都与leader replica保持同步状态；正常情况下，所有的 replica 都应该和 leader replica 保持同步状态，但由于各种各样的原因如果滞后到一定程度后，kafka 会把这些 replica 踢出 ISR，如果这些 replica 慢慢的追上了 leader replica，kafka会把他们重新加入 ISR；</p>
<p><u><strong>只有 ISR 集合中的 replica 才能被选举为 leader</strong></u>；</p>
<p>kafka承诺，只要 ISR 中 至少存在一个 replica，那些”已提交“的消息就不会丢失；</p>
<br>

<h1 id="kafka-生产者-和-消费者"><a href="#kafka-生产者-和-消费者" class="headerlink" title="kafka 生产者 和 消费者"></a>kafka 生产者 和 消费者</h1><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191015141743.png" alt></p>
<br>

<h3 id="生产者（producer）"><a href="#生产者（producer）" class="headerlink" title="生产者（producer）"></a>生产者（producer）</h3><p>功能：将 消息 发布到相应的 topic 中；</p>
<p>生产者发送模式：</p>
<ul>
<li>同步方式（synchronized）：调用send方法发送，它会返回一个Future对象，调用future对象就知道消息是否发送成功。（kafka 默认为同步，即producer.type = sync）;</li>
<li>异步方式（asynchronized）：调用send方法并指定一个回调函数，服务器在返回响应时调用该函数；</li>
<li>发送了不管（oneway）：把消息发送给服务器，但并不关心是否正常到达。多数情况下，消息会正常到达，但有时也会丢失一些消息；</li>
</ul>
<br>

<h3 id="消费者（consumer）"><a href="#消费者（consumer）" class="headerlink" title="消费者（consumer）"></a>消费者（consumer）</h3><p>功能：主题 topic 中的数据被 消费者 使用；</p>
<br>



<br>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/distribution/distributed-transaction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="-CarloZ">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CarloZ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/distribution/distributed-transaction/" itemprop="url">分布式事务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-01T00:00:00+08:00">
                2018-12-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/distribution/" itemprop="url" rel="index">
                    <span itemprop="name">distribution</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/message-queue/kafka/1-kafka-outline-design/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="-CarloZ">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CarloZ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/message-queue/kafka/1-kafka-outline-design/" itemprop="url">1、kafka概要设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-01T00:00:00+08:00">
                2018-12-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mq/" itemprop="url" rel="index">
                    <span itemprop="name">mq</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mq/kafka/" itemprop="url" rel="index">
                    <span itemprop="name">kafka</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<br>


<h1 id="设计之初的4个问题"><a href="#设计之初的4个问题" class="headerlink" title="设计之初的4个问题"></a>设计之初的4个问题</h1><ul>
<li>吞吐量/延时</li>
<li>消息持久化</li>
<li>负载均衡和故障转移</li>
<li>伸缩性</li>
</ul>
<br>

<h1 id="吞吐量-延时"><a href="#吞吐量-延时" class="headerlink" title="吞吐量/延时"></a>吞吐量/延时</h1><p>吞吐量：某种处理能力的最大值；</p>
<p>延时：发出操作 到 收到响应  之间的时间；</p>
<br>

<h3 id="kafka写入-——-如何做到高吞吐量、低延时"><a href="#kafka写入-——-如何做到高吞吐量、低延时" class="headerlink" title="kafka写入 —— 如何做到高吞吐量、低延时"></a>kafka写入 —— 如何做到高吞吐量、低延时</h3><p>这得益于它对于磁盘的使用方法不同。虽然kafka会持久化所有数据到磁盘，但本质上每次写入操作其实都只是把数据写入到操作系统的也缓存（page cache）中，然后由操作系统决定什么时候把也缓存写回到磁盘上。</p>
<p>这样设计的优势：</p>
<ul>
<li>操作系统的<u><strong>页缓存是在内存中分配</strong></u>的，所以消息写入速度非常快；</li>
<li>kafka不必直接与底层文件系统打交道，所有繁琐的I/O操作 都交给操作系统来处理；</li>
<li>kafka写入操作采用<u><strong>追加写入（append）的方式，避免了磁盘随机写</strong></u>操作；</li>
</ul>
<br>

<h3 id="kafka消费端-——-如何做到高吞吐量、低延时"><a href="#kafka消费端-——-如何做到高吞吐量、低延时" class="headerlink" title="kafka消费端 —— 如何做到高吞吐量、低延时"></a>kafka消费端 —— 如何做到高吞吐量、低延时</h3><p>kafka在读取消息时会首先尝试从OS页缓存中读取，如果命中便把消息经页缓存直接发送到网络的socket上，这个过程利用linux的sendfile系统调用实现，这就是大名鼎鼎的零拷贝（Zero Copy）技术。</p>
<h4 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h4><p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191014152618.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191014152704.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20190919145439.png" alt></p>
<p>1、DMA copy 将 磁盘数据 复制到 kernel buffer 中；</p>
<p>2、向 socket buffer 中追加当前要发送的数据在 kernel buffer 中的位置和偏移量；</p>
<p>3、DMA gather copy 根据 socket buffer 中的位置和偏移量直接将 kernel buffer 中的数据copy到网卡上；</p>
<p>经过上述过程，数据只经过了2次copy就从磁盘传送出去了。（事实上这个Zero copy是针对内核来讲的，数据在内核模式下是Zero－copy的）。</p>
<p>当前许多高性能http server都引入了sendfile机制，如nginx，lighttpd等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java中的零拷贝</span></span><br><span class="line">FileChannel.transferTo(<span class="keyword">long</span> position,<span class="keyword">long</span> count, WriteableByteChannel target);</span><br></pre></td></tr></table></figure>

<p>Java NIO中FileChannel.transferTo(long position, long count, WriteableByteChannel target)方法将当前通道中的数据传送到目标通道target中，在支持Zero-Copy的linux系统中，transferTo()的实现依赖于 sendfile()调用;</p>
<br>

<h3 id="高吞吐量、低延时总结"><a href="#高吞吐量、低延时总结" class="headerlink" title="高吞吐量、低延时总结"></a>高吞吐量、低延时总结</h3><p>1、大量使用操作系统页缓存，内存操作速度快，命中率高；</p>
<p>2、kafka不直接参与物理 I/O 操作，而是交由最擅长此事的操作系统来完成；</p>
<p>3、采用顺序追加写入方式，摒弃了缓慢的磁盘随机读/写操作；</p>
<p>4、使用以sendfile为代表的零拷贝技术加强网络间的数据传输效率；</p>
<br>

<h1 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h1><h3 id="持久化的好处"><a href="#持久化的好处" class="headerlink" title="持久化的好处"></a>持久化的好处</h3><ul>
<li>解耦消息发送和消息消费</li>
<li>实现灵活的消息处理</li>
</ul>
<br>

<h1 id="负载均衡和故障转移"><a href="#负载均衡和故障转移" class="headerlink" title="负载均衡和故障转移"></a>负载均衡和故障转移</h1><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>实现方式：智能化的分区领导者选举（partition leader election）</p>
<br>

<h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>定义：服务器意外终止时，整个集群可以快速检测到该失效（failure），并立即将该服务器上的应用和服务转移到其他服务器上；</p>
<p>实现方式：心跳或会话机制，kafka通过会话机制来实现。每台kafka服务器把自己注册到zk上，一旦出现故障，与zk的会话不能保持而超时失效。此时，kafka集群会选举出另一台服务器来完全替代这太服务器继续提供服务；</p>
<br>

<h1 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h1><p>伸缩性，即scalability。表示向分布式系统中增加额外的计算资源（CPU、内存、存储、带宽）时吞吐量提升的能力；</p>
<p>阻碍线性扩容的因素：状态的保存。</p>
<ul>
<li>如果服务器自己保存自己的状态信息，则必须处理一致性问题；</li>
<li>如果服务器时无状态的，状态的保存和管理交给zookeeper这类服务来做，则大大降低维护复杂度。只需要简单的启动新节点进行自动负载均衡就能扩容集群节点；</li>
</ul>
<br>






          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/message-queue/kafka/kafka-manager-install/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="-CarloZ">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CarloZ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/message-queue/kafka/kafka-manager-install/" itemprop="url">kafka管理器kafka-manager部署安装</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-30T00:00:00+08:00">
                2018-11-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mq/" itemprop="url" rel="index">
                    <span itemprop="name">mq</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mq/kafka/" itemprop="url" rel="index">
                    <span itemprop="name">kafka</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<br>

<h1 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h1><p> <a href="https://github.com/yahoo/kafka-manager/releases" target="_blank" rel="noopener">https://github.com/yahoo/kafka-manager/releases</a> </p>
<br>

<h1 id="下载安装启动"><a href="#下载安装启动" class="headerlink" title="下载安装启动"></a>下载安装启动</h1><p>wget <a href="https://github.com/yahoo/kafka-manager/archive/2.0.0.2.tar.gz" target="_blank" rel="noopener">https://github.com/yahoo/kafka-manager/archive/2.0.0.2.tar.gz</a></p>
<p> mv 2.0.0.2.tar.gz kafka-manager.tar.gz</p>
<p>tar -zxf kafka-manager.tar.gz</p>
<p>mv kafka-manager-2.0.0.2/ kafka-manager</p>
<p>vi kafka-manager/conf/application.conf</p>
<blockquote>
<p>kafka-manager.zkhosts=”127.0.0.1:2181”</p>
</blockquote>
<p>安装sbt：</p>
<p>curl <a href="https://bintray.com/sbt/rpm/rpm" target="_blank" rel="noopener">https://bintray.com/sbt/rpm/rpm</a> &gt; bintray-sbt-rpm.repo</p>
<p>sudo mv bintray-sbt-rpm.repo /etc/yum.repos.d/</p>
<p>sudo yum install sbt -y</p>
<p> vi ~/.sbt/repositories </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[repositories]</span><br><span class="line">local</span><br><span class="line">aliyun: http://maven.aliyun.com/nexus/content/groups/public/</span><br><span class="line">typesafe: http://repo.typesafe.com/typesafe/ivy-releases/, [organization]/[module]/(scala_[scalaVersion]/)(sbt_[sbtVersion]/)[revision]/[type]s/[artifact](-[classifier]).[ext], bootOnly</span><br><span class="line">sonatype-oss-releases</span><br><span class="line">maven-central</span><br><span class="line">sonatype-oss-snapshots</span><br></pre></td></tr></table></figure>

<p>sbt -version<br>[info] [launcher] getting org.scala-sbt sbt 1.3.3  (this may take some time)…</p>
<p>编译：</p>
<p>cd kafka-manager/</p>
<p>./sbt clean dist</p>
<p>mkdir -p bin</p>
<p>cp /data/sourcecode/kafka-manager/target/universal/kafka-manager-2.0.0.2.zip  /data</p>
<p>unzip kafka-manager-2.0.0.2.zip </p>
<p>cd /data/kafka-manager-2.0.0.2/bin</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191025135515.png" alt></p>
<p>启动：</p>
<p>nohub /data/kafka-manager-2.0.0.2/bin/kafka-manager -Dhttp.port=9090 &amp;</p>
<p>/data/kafka-manager-2.0.0.2/bin/kafka-manager -Dhttp.port=9090</p>
<p>开放端口：</p>
<p>[root@localhost ~]# firewall-cmd –query-port 9090/tcp<br>[root@localhost ~]# firewall-cmd –permanent –add-port=9090/tcp<br>[root@localhost ~]# firewall-cmd –reload</p>
<p> <a href="http://172.18.1.51:9090/" target="_blank" rel="noopener">http://172.18.1.51:9090/</a> </p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191025140555.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191025140707.png" alt></p>
<br>





<br>





<br>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">-CarloZ</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">186</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">44</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">95</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://gitee.com/carloz" title="repository - https://gitee.com/carloz" target="_blank">repository - https://gitee.com/carloz</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">-CarloZ</span>

  
</div>








  <div class="footer-custom">Hosted by <a target="_blank" href="https://gitee.com/carloz">Gitee Repo</a></div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
