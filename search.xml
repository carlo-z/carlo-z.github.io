<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ELK单节点系统构建]]></title>
    <url>%2Felasticsearch%2FELK%E5%8D%95%E8%8A%82%E7%82%B9%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[安装 jdk（jdk7+）tar -zxf jdk-8u65-linux-x64.tar.gz -C /data/carloz/tools/设置java环境变量vim /etc/profile 1234export JAVA_HOME=/carloz/tools/jdk1.8.0_65export JRE_HOME=$JAVA_HOME/jreexport PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATHexport CLASSPATH=$CLASSPATH:.:/JAVA_HOME/lib:$JAVA_HOME/jre/lib source /etc/profilejava -version 安装 Elasticsearchtar -zxf elasticsearch-7.0.0-linux-x86_64.tar.gz -C /data/carloz/tools/cd elasticsearch-7.0.0/ ./bin/elasticsearch 这是出于系统安全考虑设置的条件。由于ElasticSearch可以接收用户输入的脚本并且执行，为了系统安全考虑。创建elsearch用户组及elsearch用户groupadd elsearchuseradd elsearch -g elsearch -p elasticsearchcd /data/carloz/tools/chown -R elsearch:elsearch elasticsearch-7.0.0/su elsearchcd elasticsearch-7.0.0/./bin/elasticsearch -d 一个警告，操作系统内核版本太低，忽略即可 netstat -nltp | grep 9200 ps aux | grep elastic* curl ‘http://127.0.0.1:9200&#39;如下代表启动成功： 配置Elasticsearchsu elsearchcd /data/carloz/tools/elasticsearch-7.0.0vi config/elasticsearch.ymlgrep -v ^# config/elasticsearch.yml 集群监控curl -XGET ‘http://localhost:9200/_cluster/health?pretty=true&#39; 安装 Logstashsu rootcd /carloz/downloadtar -zxf logstash-7.0.0.tar.gz -C /data/carloz/tools/cd /data/carloz/tools/logstash-7.0.0/ 定义 一个叫 stdin 的数据源，和一个叫stdout的输出目标，无论我们输入什么，都会输出到标准命令行：./bin/logstash -e ‘input { stdin { } } output { stdout {} }’等待启动成功之后，输入 hello logastsh 1、Logstash 输入源2、Logstash 输出目标3、Logstash 过滤器 定义输入源，输出目标： mkdir -p myconfvi myconf/jyweb-nginx.conf 1234567891011input&#123; file&#123; path =&gt; ["/opt/software/nginx/logs/*.log"] &#125;&#125;output&#123; elasticsearch&#123; hosts =&gt; ["localhost:9200"] index =&gt; "jyweb_nginx_log" &#125;&#125; 启动logstash./bin/logstash -f myconf/jyweb-nginx.conf &amp; 安装 Kibanatar -zxf /carloz/download/kibana-7.0.0-linux-x86_64.tar.gz -C /data/carloz/tools/cd /data/carloz/tools/kibana-7.0.0-linux-x86_64 修改配置文件，指向Elasticsearch服务器vi config/kibana.yml 1234server.port: 5601server.host: "0.0.0.0"server.name: "logs-server"elasticsearch.hosts: ["http://localhost:9200"] 启动./bin/kibana 访问：http://10.10.139.42:5601]]></content>
      <categories>
        <category>elastic</category>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rocketmq简介]]></title>
    <url>%2Fmq%2Frocketmq-introduce%2F</url>
    <content type="text"></content>
      <categories>
        <category>mq</category>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>mq</tag>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kafka简介]]></title>
    <url>%2Fmq%2Fkafka-introduce%2F</url>
    <content type="text"></content>
      <categories>
        <category>mq</category>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>mq</tag>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rabbitmq简介]]></title>
    <url>%2Fmq%2Frabbitmq-introduce%2F</url>
    <content type="text"></content>
      <categories>
        <category>mq</category>
        <category>rabbitmq</category>
      </categories>
      <tags>
        <tag>mq</tag>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Valid Parentheses]]></title>
    <url>%2Fleetcode%2Fvalid-parentheses%2F</url>
    <content type="text"><![CDATA[算法分类：Stack url：https://leetcode.com/problems/valid-parentheses/ 题目 12345678910111213141516171819202120. Valid ParenthesesGiven a string containing just the characters '(', ')', '&#123;', '&#125;', '[' and ']', determine if the input string is valid.An input string is valid if:Open brackets must be closed by the same type of brackets.Open brackets must be closed in the correct order.Note that an empty string is also considered valid.Example 1:Input: "()"Output: trueExample 2:Input: "()[]&#123;&#125;"Output: trueExample 3:Input: "(]"Output: false Java解法： 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;String&gt; stack = new Stack&lt;&gt;(); char[] chArr = s.toCharArray(); for (char ch : chArr) &#123; String top = stack.isEmpty() ? null : stack.peek(); String c = String.valueOf(ch); if (null == top) &#123; stack.push(c); &#125; else if (top.equals("&#123;")) &#123; if (c.equals("&#125;")) &#123; stack.pop(); &#125; else &#123; stack.push(c); &#125; &#125; else if (top.equals("[")) &#123; if (c.equals("]")) &#123; stack.pop(); &#125; else &#123; stack.push(c); &#125; &#125; else if (top.equals("(")) &#123; if (c.equals(")")) &#123; stack.pop(); &#125; else &#123; stack.push(c); &#125; &#125; else &#123; stack.push(c); &#125; &#125; if (stack.isEmpty()) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125; 12345678910111213141516171819202122class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); HashMap&lt;Character, Character&gt; map = new HashMap&lt;Character, Character&gt;() &#123;&#123; put('&#125;', '&#123;'); put(']', '['); put(')', '('); &#125;&#125;; char[] chArr = s.toCharArray(); for (char ch : chArr) &#123; Character top = stack.isEmpty() ? null : stack.peek(); if (null == top) &#123; stack.push(ch); &#125; else if (top == map.get(ch)) &#123; stack.pop(); &#125; else &#123; stack.push(ch); &#125; &#125; return stack.isEmpty(); &#125;&#125; Python解法： 12345678910111213141516class Solution(object): def isValid(self, s): """ :type s: str :rtype: bool """ stack = [] map = &#123;u'&#125;':u'&#123;', u']':u'[', u')':u'('&#125; for ch in s: top = u'#' if (len(stack) == 0) else stack[-1] if map.has_key(ch) and top == map[ch]: stack.pop() else: stack.append(ch) return 0 == len(stack)]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unique Binary Search Trees ii]]></title>
    <url>%2Fleetcode%2Funique-binary-search-trees-ii%2F</url>
    <content type="text"><![CDATA[算法：二叉搜索树 url：https://leetcode-cn.com/problems/unique-binary-search-trees-ii/ 题目 1234567891011121314151617181920给定一个整数 n，生成所有由 1 ... n 为节点所组成的二叉搜索树。示例:输入: 3输出:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]解释:以上的输出对应以下 5 种不同结构的二叉搜索树： 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 分析 首先来计数需要构建的二叉树数量。可能的二叉搜素数数量是一个 卡特兰数。 我们跟随上文的逻辑，只是这次是构建具体的树，而不是计数。 算法 我们从序列 1 ..n 中取出数字 i，作为当前树的树根。于是，剩余 i - 1 个元素可用于左子树，n - i 个元素用于右子树。如 前文所述，这样会产生 G(i - 1) 种左子树 和 G(n - i) 种右子树，其中 G 是卡特兰数。 现在，我们对序列 1 … i - 1 重复上述过程，以构建所有的左子树；然后对 i + 1 … n 重复，以构建所有的右子树。 这样，我们就有了树根 i 和可能的左子树、右子树的列表。 最后一步，对两个列表循环，将左子树和右子树连接在根上。 Java解法 123456789101112131415161718192021222324252627282930313233343536public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125;class Solution &#123; public List&lt;TreeNode&gt; generateTrees(int n) &#123; if (n &lt;= 0) &#123; return new LinkedList&lt;TreeNode&gt;(); &#125; return listTrees(1, n); &#125; public LinkedList&lt;TreeNode&gt; listTrees(int start, int end) &#123; LinkedList&lt;TreeNode&gt; rootList = new LinkedList&lt;TreeNode&gt;(); if(start &gt; end) &#123; rootList.add(null); return rootList; &#125; for(int i=start; i&lt;=end; ++i) &#123; LinkedList&lt;TreeNode&gt; leftList = listTrees(start, i-1); LinkedList&lt;TreeNode&gt; rightList = listTrees(i+1, end); for(TreeNode left : leftList) &#123; for(TreeNode right : rightList) &#123; TreeNode cur = new TreeNode(i); cur.left = left; cur.right = right; rootList.add(cur); &#125; &#125; &#125; return rootList; &#125;&#125; Python解法]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Two Ssum]]></title>
    <url>%2Fleetcode%2Ftwo-sum%2F</url>
    <content type="text"><![CDATA[url：https://leetcode.com/problems/two-sum/submissions/ 题目：Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Java 解法：12345678910111213class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException("No two sum solution"); &#125;&#125; Python解法：12345678910111213# https://leetcode.com/problems/two-sum/submissions/class Solution(object): def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ for i in range(len(nums)): x = target-nums[i]; c = nums[0:i].count(x); if c &gt; 0 and nums.index(x) != i: return [nums.index(x), i]]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单链表反转]]></title>
    <url>%2Fleetcode%2Freverse-linked-list%2F</url>
    <content type="text"><![CDATA[算法：单链表反转 题目 123456这其实是一道变形的链表反转题，大致描述如下给定一个单链表的头节点 head,实现一个调整单链表的函数，使得每K个节点之间为一组进行逆序，并且从链表的尾部开始组起，头部剩余节点数量不够一组的不需要逆序。（不能使用队列或者栈作为辅助）例如：链表:1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;null, K = 3。那么 6-&gt;7-&gt;8，3-&gt;4-&gt;5，1-&gt;2各位一组。调整后：1-&gt;2-&gt;5-&gt;4-&gt;3-&gt;8-&gt;7-&gt;6-&gt;null。其中 1，2不调整，因为不够一组。 解析 这道题的难点在于，是从链表的尾部开始组起的，而不是从链表的头部，如果是头部的话，那我们还是比较容易做的，因为你可以遍历链表，每遍历 k 个就拆分为一组来逆序。但是从尾部的话就不一样了，因为是单链表，不能往后遍历组起； 思路1：整体反转，然后从头开始截取 K个节点 ，被后续截图的K个节点 的尾部连接；最后长度不足K的节点再局部反转 作为 队头 思路2：整体反转， Java解法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Node &#123; int val; Node next; public Node(int d) &#123; this.val = d; &#125;&#125;class Solution &#123; public Node reverse(Node node) &#123; Node pre = node; Node cur = node.next; node.next = null; Node tmp; while(cur!=null) &#123; tmp = cur.next; cur.next = pre; pre = cur; cur = tmp; &#125; return pre; &#125; public Node reverseByK(Node node, int k) &#123; Node tmp = node; for (int i=1; i&lt;k &amp;&amp; tmp != null; i++) &#123; tmp = tmp.next; &#125; if (tmp == null) &#123; return node; &#125; Node childList = tmp.next; tmp.next = null; Node retNode = reverse(node); Node newChildNode = reverseByK(childList, k); node.next = newChildNode; return retNode; &#125; public static void main(String[] args) &#123; Node link = null; Node tmp = link; for(int i=1; i&lt;9; ++i) &#123; if(null == tmp) &#123; tmp = new Node(i); link = tmp; &#125; else &#123; tmp.next = new Node(i); tmp = tmp.next; &#125; &#125; Solution solution = new Solution(); link = solution.reverse(solution.reverseByK(solution.reverse(link), 3)); while(link!=null) &#123; System.out.print(link.val + " "); link = link.next; &#125; &#125;&#125; Python解法]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Recover Binary Search Tree]]></title>
    <url>%2Fleetcode%2Frecover-binary-search-tree%2F</url>
    <content type="text"><![CDATA[算法：二叉搜索树， 深度优先搜索 url：https://leetcode.com/problems/recover-binary-search-tree/ 题目 123456789101112131415161718192021222324252627282930313233343599. Recover Binary Search TreeTwo elements of a binary search tree (BST) are swapped by mistake.Recover the tree without changing its structure.Example 1:Input: [1,3,null,null,2] 1 / 3 \ 2Output: [3,1,null,null,2] 3 / 1 \ 2Example 2:Input: [3,1,4,null,null,2] 3 / \1 4 / 2Output: [2,1,4,null,null,3] 2 / \1 4 / 3Follow up:A solution using O(n) space is pretty straight forward.Could you devise a constant space solution? 分析 要求，不改变现有树结构的前提，使数恢复为二叉搜索树； 使用DFS便利二叉树，凡是 不符合规则的节点都标记出来； 中序遍历，遍历结果有序，无序的节点就是 不合格的节点 Java解法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125;class Solution &#123; TreeNode pre; TreeNode first, second; public void recoverTree(TreeNode root) &#123; pre = new TreeNode(Integer.MIN_VALUE); inorder(root); swap(first, second); &#125; public void inorder(TreeNode root) &#123; if(null == root) return; inorder(root.left); if(pre.val &gt;= root.val &amp;&amp; pre.val != Integer.MIN_VALUE) &#123; if(null == first) first = pre; second = root; &#125; pre = root; inorder(root.right); &#125; public void swap(TreeNode node1, TreeNode node2) &#123; int tmp = node1.val; node1.val = node2.val; node2.val = tmp; &#125;&#125;public class MainClass &#123; public static TreeNode stringToTreeNode(String input) &#123; input = input.trim(); input = input.substring(1, input.length() - 1); if (input.length() == 0) &#123; return null; &#125; String[] parts = input.split(","); String item = parts[0]; TreeNode root = new TreeNode(Integer.parseInt(item)); Queue&lt;TreeNode&gt; nodeQueue = new LinkedList&lt;&gt;(); nodeQueue.add(root); int index = 1; while(!nodeQueue.isEmpty()) &#123; TreeNode node = nodeQueue.remove(); if (index == parts.length) &#123; break; &#125; item = parts[index++]; item = item.trim(); if (!item.equals("null")) &#123; int leftNumber = Integer.parseInt(item); node.left = new TreeNode(leftNumber); nodeQueue.add(node.left); &#125; if (index == parts.length) &#123; break; &#125; item = parts[index++]; item = item.trim(); if (!item.equals("null")) &#123; int rightNumber = Integer.parseInt(item); node.right = new TreeNode(rightNumber); nodeQueue.add(node.right); &#125; &#125; return root; &#125; public static String treeNodeToString(TreeNode root) &#123; if (root == null) &#123; return "[]"; &#125; String output = ""; Queue&lt;TreeNode&gt; nodeQueue = new LinkedList&lt;&gt;(); nodeQueue.add(root); while(!nodeQueue.isEmpty()) &#123; TreeNode node = nodeQueue.remove(); if (node == null) &#123; output += "null, "; continue; &#125; output += String.valueOf(node.val) + ", "; nodeQueue.add(node.left); nodeQueue.add(node.right); &#125; return "[" + output.substring(0, output.length() - 2) + "]"; &#125; public static void main(String[] args) throws IOException &#123; BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = in.readLine()) != null) &#123; TreeNode root = stringToTreeNode(line); new Solution().recoverTree(root); String out = treeNodeToString(root); System.out.print(out); &#125; &#125;&#125; Python解法]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>Binary Tree</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Longest Palindromic Substring]]></title>
    <url>%2Fleetcode%2Flongest-palindromic-substring%2F</url>
    <content type="text"><![CDATA[算法：动态规划 URL：https://leetcode-cn.com/problems/longest-palindromic-substring/ 题目 1234567891011给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。示例 1：输入: "babad"输出: "bab"注意: "aba" 也是一个有效答案。示例 2：输入: "cbbd"输出: "bb" 分析 Java解法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.util.Stack;public class Solution &#123; public String longestPalindrome(String s) &#123; String longestS=null, curS=null; for(int i=0; i&lt;s.length(); ++i) &#123; curS = palindrome(s.toCharArray(), i); if (null == curS) continue; if (null == longestS) longestS = curS; else &#123; if (longestS.length() &lt;= curS.length()) longestS = curS; &#125; &#125; return (null == longestS) ? "" : longestS; &#125; public String palindrome(char[] chArr, int index) &#123; Stack&lt;Character&gt; stack1 = new Stack&lt;Character&gt;(); Stack&lt;Character&gt; stack2 = new Stack&lt;Character&gt;(); int len1=0, len2=0; if(index-1&gt;=0 &amp;&amp; chArr[index] == chArr[index-1]) &#123; for(int i=index-1; i&gt;=0; --i) &#123; int delta = index-1-i; if(index+delta&gt;=chArr.length) break; if(chArr[i] == chArr[index+delta]) &#123; stack1.push(chArr[i]); &#125; else &#123; break; &#125; &#125; len1 = stack1.size()*2; &#125; if(index-2&gt;=0 &amp;&amp; chArr[index] == chArr[index-2]) &#123; stack2.push(chArr[index-1]); for(int i=index-2; i&gt;=0; --i) &#123; int delta = index-2-i; if(index+delta&gt;=chArr.length) break; if(chArr[i] == chArr[index+delta]) &#123; stack2.push(chArr[i]); &#125; else &#123; break; &#125; &#125; len2 = stack2.size()*2 - 1; &#125; // System.out.printf("%d, %d %c \n", len1, len2, chArr[index]); if (0==len1 &amp;&amp; 0==len2) return String.valueOf(chArr[index]); if (len1&gt;len2) &#123; char[] res = new char[len1]; for(int i=0; !stack1.isEmpty(); ++i) &#123; char c = stack1.pop().charValue(); res[i] = res[len1-1-i] = c; &#125; return String.copyValueOf(res); &#125; else &#123; char[] res = new char[len2]; for(int i=0; !stack2.isEmpty(); ++i) &#123; char c = stack2.pop().charValue(); res[i] = res[len2-1-i] = c; &#125; return String.copyValueOf(res); &#125; &#125; public static void main(String[] args) &#123; String s = "ba"; String ret = new Solution().longestPalindrome(s); String out = (ret); System.out.print(out); &#125;&#125; 同样解法的代码优化 1234567891011121314151617181920212223242526class Solution &#123; public String longestPalindrome(String s) &#123; if (s == null || s.length() &lt; 1) return ""; int start = 0, end = 0; for (int i = 0; i &lt; s.length(); i++) &#123; int len1 = expandAroundCenter(s, i, i); int len2 = expandAroundCenter(s, i, i + 1); int len = Math.max(len1, len2); if (len &gt; end - start) &#123; start = i - (len - 1) / 2; end = i + len / 2; &#125; &#125; return s.substring(start, end + 1); &#125; private int expandAroundCenter(String s, int left, int right) &#123; int L = left, R = right; while (L &gt;= 0 &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123; L--; R++; &#125; return R - L - 1; &#125;&#125; 还有一种动态规划的解法，需要接着研究 Python解法]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kth Largest Element in an Array]]></title>
    <url>%2Fleetcode%2Fkth-largest-element-in-an-array%2F</url>
    <content type="text"><![CDATA[算法：Heap 堆题目url:https://leetcode.com/problems/kth-largest-element-in-an-array/ 1234567891011121314215. Kth Largest Element in an ArrayFind the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.Example 1:Input: [3,2,1,5,6,4] and k = 2Output: 5Example 2:Input: [3,2,3,1,2,4,5,5,6] and k = 4Output: 4Note: You may assume k is always valid, 1 ≤ k ≤ array's length. 分析用数据结构 Head（堆）来实现 堆：完全二叉树，常常用数组表示 用数组表示一棵树时，如果数组中节点的索引位x，则a、它的父节点的下标是：(x-1)/2；b、它的左子节点的下标为：2x + 1；c、它的右子节点的下标是：2x + 2； 堆的数组实现：https://www.cnblogs.com/g177w/p/8469399.html Java解法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133class Solution &#123; class Node &#123; private int data; public Node(int d) &#123; this.data = d; &#125; public int getValue() &#123; return this.data; &#125; public void setValue(int d) &#123; this.data = d; &#125; &#125; class Head &#123; private Node[] headArray; private int maxSize; private int currentSize; public Head(int maxSize) &#123; this.maxSize = maxSize; currentSize = 0; headArray = new Node[maxSize]; &#125; public boolean isEmpty() &#123; return 0 == currentSize; &#125; public boolean insert(int d) &#123; if (this.currentSize == this.maxSize) &#123; return false; &#125; Node node = new Node(d); headArray[currentSize] = node; trickleUp(currentSize++); return true; &#125; public void trickleUp(int index) &#123; int parentIndex = (index - 1) / 2; Node node = headArray[index]; while (index &gt; 0 &amp;&amp; headArray[parentIndex].getValue() &lt; node.getValue()) &#123; headArray[index] = headArray[parentIndex]; index = parentIndex; parentIndex = (index - 1) / 2; &#125; headArray[index] = node; &#125; public Node remove() &#123; Node root = headArray[0]; headArray[0] = headArray[--currentSize]; trickleDown(0); return root; &#125; public void trickleDown(int index) &#123; int largeChild; Node node = headArray[index]; while (index &lt; currentSize/2) &#123; int leftChild = 2 * index + 1; int rightChild = 2 * index +2; if (rightChild &lt; currentSize &amp;&amp; headArray[leftChild].getValue() &lt; headArray[rightChild].getValue()) &#123; largeChild = rightChild; &#125; else &#123; largeChild = leftChild; &#125; if (node.getValue() &gt;= headArray[largeChild].getValue()) &#123; break; &#125; headArray[index] = headArray[largeChild]; index = largeChild; &#125; headArray[index] = node; &#125; public boolean change(int index, int newValue) &#123; if (index &lt; 0 || index &gt; currentSize) &#123; return false; &#125; int oldValue = headArray[index].getValue(); headArray[index].setValue(newValue); if (oldValue &lt; newValue) &#123; trickleUp(index); &#125; else &#123; trickleDown(index); &#125; return true; &#125; public void displayHead() &#123; System.out.print("headArray:"); for (int i = 0; i &lt; currentSize; i++) &#123; if (headArray[i] != null) System.out.print(headArray[i].getValue()+" "); else System.out.print("--"); &#125; System.out.println(""); int nBlanks = 32; int itemsPerrow = 1; int column = 0; int j = 0; String dots = "........................"; System.out.println(dots + dots); while (currentSize &gt; 0)&#123; if (column == 0) for (int i = 0; i &lt; nBlanks; i++) &#123; System.out.print(" "); &#125; System.out.print(headArray[j].getValue()); if (++ j == currentSize) break; if (++ column == itemsPerrow)&#123; nBlanks /= 2; itemsPerrow *= 2; column = 0; System.out.println(); &#125; else for (int i = 0; i &lt; nBlanks * 2 - 2; i++) System.out.print(' '); &#125; System.out.println("\n"+dots + dots); &#125; &#125; public int findKthLargest(int[] nums, int k) &#123; Head head = new Solution().new Head(nums.length); for (int x : nums) &#123; head.insert(x); &#125; for (int i=0; i&lt;k-1; ++i) &#123; head.remove(); &#125; int ret = head.remove().getValue(); return ret; &#125;&#125; Python解法12]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>Binary Tree</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[h index ii]]></title>
    <url>%2Fleetcode%2Fh-index-ii%2F</url>
    <content type="text"><![CDATA[算法：url：https://leetcode.com/problems/h-index-ii/ 题目1234567891011121314151617181920Given an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.According to the definition of h-index on Wikipedia: "A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each."Example:Input: citations = [0,1,3,5,6]Output: 3 Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, her h-index is 3.Note:If there are several possible values for h, the maximum one is taken as the h-index.Follow up:This is a follow up problem to H-Index, where citations is now guaranteed to be sorted in ascending order.Could you solve it in logarithmic time complexity? 思路分析[0,1,3,5,6] 数组长度 n，存在一个元素 h， 使得 n 中有 h个元素 大于等于h， 其他 （n-h）个元素 &lt; h； 求h？ 数组是有序的 递增数组 遍历 arr，存在 arr[i], 使得 n-i == arr[i] Java解法12345678910class Solution &#123; public int hIndex(int[] citations) &#123; for(int i=citations.length-1; i&gt;=0; --i) &#123; if(citations[i] == citations.length-i) &#123; return citations[i]; &#125; &#125; return 0; &#125;&#125; 1234567891011121314151617181920public int hIndex(int[] citations) &#123; int l = 1, r = citations.length; int ans = 0; while(l &lt;= r)&#123; int m = l + ((r - l)&gt;&gt;1); int p = citations[citations.length - m]; if(m == p)&#123; return m; &#125; if(m &gt; p)&#123; r = m - 1; &#125; else&#123; ans = Math.max(ans, m); l = m + 1; &#125; &#125; return ans; &#125;&#125; Python解法]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary Tree Right Side View]]></title>
    <url>%2Fleetcode%2Fbinary-tree-right-side-view%2F</url>
    <content type="text"><![CDATA[算法：二叉树广度优先遍历 BFS URL：https://leetcode.com/problems/binary-tree-right-side-view/ 题目 1234567891011121314151617181920212223242526Binary Tree Right Side ViewGiven a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.Example:Input: [1,2,3,null,5,null,4]Output: [1, 3, 4]Explanation: 1 &lt;--- / \2 3 &lt;--- \ \ 5 4 &lt;---Input: [1,2,3,null,5,null,4,null,null,8]Output: [1, 3, 4, 8]Explanation: 1 &lt;--- / \ 2 3 &lt;--- \ \ 5 4 &lt;--- / 8 &lt;--- 分析 使用层序遍历（level traversal），即广度优先搜索 —— 借助Queue 难点是 标注每一层，来标注 每层的最后一个节点 当前层节点总数：count1，当前访问到节点数 i 下一层几点总数：count2 Java解法 12345678910111213141516171819202122232425262728293031323334353637383940public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125;class Solution &#123; public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; return BFS(root); &#125; public List&lt;Integer&gt; BFS(TreeNode root) &#123; List&lt;Integer&gt; retList = new ArrayList&lt;Integer&gt;(); if(null == root) return retList; int count1=1, count2=0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.add(root); while(!queue.isEmpty()) &#123; for(int i=0; i&lt;count1; ++i) &#123; TreeNode tn = queue.poll(); if(null != tn) &#123; if (i == count1-1) &#123; retList.add(tn.val); &#125; if(null != tn.left) &#123; queue.add(tn.left); count2++; &#125; if (null != tn.right) &#123; queue.add(tn.right); count2++; &#125; &#125; &#125; count1 = count2; count2 = 0; &#125; return retList; &#125;&#125; 结果 Runtime: 1 ms, faster than 98.22% of Java online submissions for Binary Tree Right Side View. Memory Usage: 36.3 MB, less than 100.00% of Java online submissions for Binary Tree Right Side View. 1次AC，Niubility Python解法 12]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>Binary Tree</tag>
        <tag>广度优先遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary Tree Maximum Path Sum]]></title>
    <url>%2Fleetcode%2Fbinary-tree-maximum-path-sum%2F</url>
    <content type="text"><![CDATA[算法：二叉树 + 动态规划 url：https://leetcode.com/problems/binary-tree-maximum-path-sum/ 题目 12345678910111213141516171819202122232425124. Binary Tree Maximum Path SumGiven a non-empty binary tree, find the maximum path sum.For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.Example 1:Input: [1,2,3] 1 / \ 2 3Output: 6Example 2:Input: [-10,9,20,null,null,15,7] -10 / \ 9 20 / \ 15 7Output: 42 分析： 不要求 最大值的路径，只要求最大值 Java解法 1234567891011121314151617181920public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125;class Solution &#123; int ret = Integer.MIN_VALUE; public int maxPathSum(TreeNode root) &#123; return maxSum(root); &#125; public int maxSum(TreeNode root) &#123; if (null == root) return 0; int l = Math.max(0, maxSum(root.left)); int r = Math.max(0, maxSum(root.right)); int sum = l + r + root.val; ret = Math.max(ret, sum); return Math.max(l, r) + root.val; &#125;&#125;]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>Binary Tree</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Add Two Numbers]]></title>
    <url>%2Fleetcode%2Fadd-two-numbers%2F</url>
    <content type="text"><![CDATA[算法：链表 Linked list url：https://leetcode.com/problems/add-two-numbers/ 题目：Add Two Numbers 1234567You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.Example:Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 分析 百位大数相加 Java解法 方法 定义 链表增加节点 单链表反转 不需要，只是为了练习算法 遍历链表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.test.demo;import java.io.IOException;class ListNode &#123; int val; ListNode next; public ListNode(int x) &#123;this.val = x;&#125;&#125;class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode retNode = null; int carryBit = 0; while(l1 != null || l2!= null) &#123; int d1 = null==l1 ? 0 : l1.val; int d2 = null==l2 ? 0 : l2.val; int d = d1 + d2 + carryBit; retNode = add(retNode, new ListNode(d%10)); carryBit = d/10; l1 = null==l1 ? l1 : l1.next; l2 = null==l2 ? l2 : l2.next; &#125; for (int i = carryBit; i&gt;0; i = i/10) &#123; retNode = add(retNode, new ListNode(i%10)); &#125; return retNode;// return reverse(retNode); &#125; public ListNode add(ListNode headNode, ListNode node) &#123; if (null == headNode) &#123; headNode = node; &#125; else &#123; ListNode index = headNode; while(index.next != null) &#123;index = index.next;&#125; index.next = node; &#125; return headNode; &#125; public ListNode reverse(ListNode headNode) &#123; if(headNode == null) return headNode; ListNode pre = headNode; ListNode cur; ListNode temp; for(cur = headNode.next; cur!=null; ) &#123; temp = cur.next; cur.next = pre; pre = cur; cur = temp; &#125; headNode.next = null; return pre; &#125;&#125;public class MainClass &#123; public static int[] stringToIntegerArray(String input) &#123; input = input.trim(); input = input.substring(1, input.length() - 1); if (input.length() == 0) &#123; return new int[0]; &#125; String[] parts = input.split(","); int[] output = new int[parts.length]; for(int index = 0; index &lt; parts.length; index++) &#123; String part = parts[index].trim(); output[index] = Integer.parseInt(part); &#125; return output; &#125; public static ListNode stringToListNode(String input) &#123; // Generate array from the input int[] nodeValues = stringToIntegerArray(input); // Now convert that list into linked list ListNode dummyRoot = new ListNode(0); ListNode ptr = dummyRoot; for(int item : nodeValues) &#123; ptr.next = new ListNode(item); ptr = ptr.next; &#125; return dummyRoot.next; &#125; public static String listNodeToString(ListNode node) &#123; if (node == null) &#123; return "[]"; &#125; String result = ""; while (node != null) &#123; result += Integer.toString(node.val) + ", "; node = node.next; &#125; return "[" + result.substring(0, result.length() - 2) + "]"; &#125; public static void main(String[] args) throws IOException &#123; ListNode l1 = stringToListNode("[9]"); ListNode l2 = stringToListNode("[1,9,9,9,9,9,9,9,9,9]"); ListNode ret = new Solution().addTwoNumbers(l1, l2); String out = listNodeToString(ret); System.out.print(out); &#125;&#125; Python解法]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>Linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java异步回调demo]]></title>
    <url>%2Fjava%2Fasync-callback-demo%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334import java.util.concurrent.*;interface ICallback &#123; void getResult(int s);&#125;class Calc &#123; public void calc(int i, ICallback callback) throws Exception &#123; FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; int s = i * i; Thread.sleep(5000); System.out.println("do in future task. " + Thread.currentThread().getName()); callback.getResult(s); return s; &#125; &#125;); new Thread(futureTask).start(); &#125;&#125;public class App &#123; public static void main(String[] args) throws Exception &#123; ICallback callback = new ICallback() &#123; @Override public void getResult(int s) &#123; System.out.println(s); &#125; &#125;; new Calc().calc(1000, callback); System.out.println("do in main"); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
        <category>juc</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Callable</tag>
        <tag>Callback</tag>
        <tag>FutureTask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to 0ms AC]]></content>
  </entry>
</search>
