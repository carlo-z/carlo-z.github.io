<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[tcpdump 捕获中文传输数据包，并手动解析]]></title>
    <url>%2Fos%2Fcomputer-network%2Ftcpdump%E6%8D%95%E8%8E%B7%E4%B8%AD%E6%96%87%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E5%8C%85%E5%B9%B6%E6%89%8B%E5%8A%A8%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[开启tcpdump抓包centos7 下 ，只抓有数据的包： tcpdump -i eth0 ‘((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0’ and src 10.10.139.42 and dst 10.10.128.57 and port 21000 -XX ​ 示例（1）输入“中国a”centos7 下 netcat 输入： 抓包结果放在 WireShark中分析 tcpdump抓包： wireshark分析抓到的文件： 可以看到 中文的16进制编码为 d6 d0 b9 fa 61 0a， 查看 控制台的编码： 可知，中文经过GBK编码以后的 16进制表示为： d6 d0 b9 fa 61 0a； GBK的编码规则如下： d6d0 b9fa 610a 按双字节表示转换为：D6D0 B9FA 610A GBK对照表：http://ff.163.com/newflyff/gbk-list/ D6D0 对应的中文为： B9FA 对应的中文为： 610A 对应的中文为： 搜索没有对应的GBK编码 ASCII码对照表：http://ascii.911cha.com/ 0A 为换行符； ​ 示例（2）输入“asdf123”输入： 抓包： 解析：]]></content>
      <tags>
        <tag>tcpdump</tag>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcpdump抓包后，wireshark分析]]></title>
    <url>%2Fos%2Fcomputer-network%2Ftcpdump%E6%8A%93%E5%8C%85%E5%90%8E-wireshark%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[来源：https://segmentfault.com/a/1190000015044878?utm_source=tag-newest 因为最近要解析 TCP 报文中 option 段的一块数据，所以不得不详细了解下 TCP/IP 报文。虽然之前看过，很长时间没这么细致地用过，导致了健忘，借着这个机会，通过 tcpdump 抓包分析，详细捋一遍 TCP/IP 报文。 报文获取如果那样干巴巴地讲这个东西比较晕，而且网上的文章一大堆，没有什么创新。我选择换一个角度来切入 TCP/IP 协议。首先通过 tcpdump 准备报文。【1】我在 192.168.1.22 这台机器的 10000 端口启一个 redis 服务。【2】通过 tcpdump 这个工具来抓取数据包，命令如下： 1tcpdump -w /tmp/logs -i eth0 port 10000 -s0 【3】在 192.168.1.26 这台机器上访问 192.168.1.22:10000 这个 redis 实例，可以用 redis-cli 客户端，也可以用 telnet，发送一个 ping, 得到对端回复 pong。【4】停止抓包，用 tcpdump 读取这个数据包（-x 以16进制形式展示，便于后面分析） 1tcpdump -r /tmp/logs -n -nn -A -x| vim - 其中有一个数据包是这样的，这也是这篇文章要分析的: 123410:54:54.270967 IP 192.168.1.26.61096 &gt; 192.168.1.22.10000: Flags [P.], seq 1041414875:1041414889, ack 658186233, win 115, options [nop,nop,TS val 2377448931 ecr 2741547141], length 140x0000: [4560 0042 7567 0000 3d06 6F3C C0A8 011A 0x0010: C0A8 0116] &#123;eea8 2710 3e12 badb 273b 1ff9 0x0020: 8018 0073 64b0 0000 0101 080a 8db4 fde3 0x0030: a368 b085&#125; 2a31 0d0a 2434 0d0a 7069 6e670x0040: 0d0a 注意：【1】之前在文章常用 shell 中介绍过抓包神器 tcpdump，还不会的小伙伴可以偷瞄一眼。【2】上面报文数据中的 [、]、{ 和 } 是为了方便区分数据，我自己加上的。[]包围的部分为本报文中的 IP 头，{}包围的部分为本报文中的 TCP 头。 报文分析IP 报文整体结构如下，因为抓到的数据包是 redis 服务，因此在传输层为 TCP 协议。 IP 层解析解析数据包之前，先把 IP 协议拿出来，如下： 可以看到，IP 报文头部采用固定长度(20B) + 可变长度构成，下面的 TCP 头部也是这样。然后下面对着抓到的数据包进行分析：【1】0x4 4bit， ip 协议版本0x4 表示 IPv4。【2】0x5 4bit，ip首部长度该字段表示单位是32bits(4字节) ，所以这个 ip 包的头部有 5*4=20B，这就可以推出，该 IP 报文头没有可选字段。4bit 可以表示最大的数为 0xF，因此，IP 头部的最大长度为 15*4=60B。该报文的 IP 头部我已经在报文中标注出来了。【3】0x60 8bit，服务类型 TOS该段数据组成为 3bit 优先权字段(现已被忽略) + 4bit TOS 字段 + 1bit 保留字段(须为0)。4bit TOS 字段分别表示自小时延、最大吞吐量、最高可用性和最小费用。只能置其中 1bit，全为 0 表示一般服务。现在大多数的TCP/IP实现都不支持TOS特性 。可以看到，本报文 TOS 字段为全 0。【4】0x0042 16bit， IP 报文总长度单位字节，换算下来，该数据报的长度为 66 字节，数一下上面的报文，恰好 66B。从占位数来算， IP 数据报最长为 2^16=65535B，但大部分网络的链路层 MTU（最大传输单元）没有这么大，一些上层协议或主机也不会接受这么大的，故超长 IP 数据报在传输时会被分片。【5】0x7567 16bit，标识唯一的标识主机发送的每一个数据报。通常每发送一个报文，它的值+1。当 IP 报文分片时，该标识字段值被复制到所有数据分片的标识字段中，使得这些分片在达到最终目的地时可以依照标识字段的内容重新组成原先的数据。【6】0x0000 3bit 标志 + 13bit 片偏移3bit 标志对应 R、DF、MF。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。13bit 片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以8）【7】0x3d 8bit 生存时间TTLIP 报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为 0 时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。TTL可以防止数据报陷入路由循环。本报文该值为 61。【8】0x06 8bit 协议指出 IP 报文携带的数据使用的是哪种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程。TCP 的协议号为6，UDP 的协议号为17。ICMP 的协议号为1，IGMP 的协议号为2。该 IP 报文携带的数据使用 TCP 协议，得到了验证。【9】0x6F3C 16bit IP 首部校验和由发送端填充。以本报文为例，先说这个值是怎么计算出来的。 123# 将校验和字段 16bit 值抹去变为 `0x0000`，然后将首部 20字节值相加0x4560 + 0x0042 + 0x7567 + 0x0000 + 0x3d06 + 0x0000 + 0xC0A8 + 0x011A + 0xC0A8 +0x0116 = 0x27B95# 将上述结果的进位 2 与低 16bit 相加0x7B95 + 0x2 = 0x7B97# 0x7B97 按位取反~(0x7B97) = 0x8468 【10】0xC0A8011A 32bit 源地址可以通过一下 python 程序将 hex 转换成我们熟悉的点分 IP 表示法 12345&gt;&gt;&gt; import socket&gt;&gt;&gt; import struct&gt;&gt;&gt; int_ip=int("0xC0A8011A",16)&gt;&gt;&gt; socket.inet_ntoa(struct.pack('I',socket.htonl(int_ip)))'192.168.1.26' 本报文中的 src addr 为 192.168.1.26，恰好就是发起请求的 IP。【11】0xC0A80116 32bit 目的地址经过计算为 192.168.1.22，恰好就是启 redis 服务那台机器的 IP。 由于该报文首部长度为 20B，因此没有可变长部分。 传输层解析本报文携带的数据使用的 TCP 协议，因此下面开始分析 TCP 协议。与上面的 IP 报文一样， TCP 报文头也才用采用固定长度(20B) + 可变长度的形式。首先还是看 TCP 协议的格式，从网上找了一张图，如下： 注： TCP 的头部必须是 4字节的倍数,而大多数选项不是4字节倍数,不足的用 NOP 填充。【1】0xeea8 16bit，源端口解析得到 61096，这与 tcpdump 读包显示的是一致的。16bit 决定了端口号的最大值为 65535.【2】0x2710 16bit，目的端口解析得到 10000。【3】0x273b1ff9 32bit，序号解析得到 1041414875，这与上面 tcpdump 显示的 seq 段是一致的。【4】0x273b1ff9 32bit，确认号解析得到 658186233，这与上面 tcpdump 显示的 ack 段是一致的。【5】0x8 4bit，TCP 报文首部长度也叫 offset，其实也就是数据从哪里开始。8 * 4 = 32B,因此该 TCP 报文的可选部分长度为 32 - 20 = 12B，这个资源还是很紧张的！ 同 IP 头部类似，最大长度为 60B。【6】0b000000 6bit, 保留位保留为今后使用，但目前应置为 0。【7】0b011000 6bit，TCP 标志位上图可以看到，从左到右依次是紧急 URG、确认 ACK、推送 PSH、复位 RST、同步 SYN 、终止 FIN。从抓包可以看出，该报文是带了 ack 的，所以 ACK 标志位置为 1。关于标志位的知识这里就不展开了。【8】0x0073 16bit，滑动窗口大小解析得到十进制 115，跟 tcpdump 解析的 win 字段一致。【9】0x64b0 16bit，校验和由发送端填充，接收端对 TCP 报文段执行 CRC 算法，以检验 TCP 报文段在传输过程中是否损坏，如果损坏这丢弃。检验范围包括首部和数据两部分，这也是 TCP 可靠传输的一个重要保障。【10】0x0000 16bit，紧急指针仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数。当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。 下面是 TCP 可选项，其格式如下： 常见的可选项如下图： 【11】0x01NOP 填充，没有 Length 和 Value 字段， 用于将TCP Header的长度补齐至 32bit 的倍数。【12】0x01同上。【13】0x080a可选项类型为时间戳，len为 10B，value 为0x8db4 0xfde3 0xa368 0xb085，加上 0x080a，恰好 10B!启用 Timestamp Option后，该字段包含2 个 32bit 的Timestamp（TSval 和 TSecr）。【14】0x8db4 0xfde3解析后得到 2377448931，恰好与 tcpdump 解析到的 TS 字段的 val一致！【15】0xa368 0xb085解析后得到 2741547141，恰好与 tcpdump 解析到的 TS 字段的 ecr一致！ 数据部分解析上面分析得知，该 IP 报文长度为 66B，IP 头长度为 20B，TCP 头部长度为 32B，因此得到数据的长度为 66 - 20 - 32 = 14B，这与 tcpdump 解析到的 len 字段一致！下面来分析这个具体的数据。这里涉及到 redis 协议，不知道的小伙伴可以查看这篇文档redis 协议说明。在抓包时，用客户端向 redis 服务端发送了一个 ping 命令，转换成 redis 协议如下： 123*1\r\n$4\r\nping\r\n 下面看抓包数据解析，这需要对照 ascii 码表来看，在 linux 下可以用 man 7 ascii 这个命令来获得，或者在这里查看ascii码表。 12340x2a31 -&gt; *10x0d0a -&gt; \r\n0x2434 -&gt; $40x0d0a -&gt; \r\n0x7069 0x6e67 -&gt; ping0x0d0a -&gt; \r\n 既然详细说到 TCP/IP 协议，那补充一下 tcpdump filter 的几点用法。filter可以简单地分为三类：type, dir 和 proto。 type 区分报文的类型，主要由 host（主机）, net（网络，支持 CIDR） 和 port(支持范围，如 portrange 21-23) 组成。dir 区分方向，主要由 src 和 dst 组成。proto 区分协议支持 tcp、udp 、icmp 等。 下面说几个 filter 表达式。proto[x:y] start at offset x into the proto header and read y bytes[x] abbreviation for [x:1]注意：单位是字节，不是位！举几个栗子：【1】打印 80 端口，有数据的 tcp 包 1tcpdump 'tcp port 80 and (((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0)' ip[2:2] 从 ip 报文的第3个字节开始读2个字节，这个恰好就是 ip 包的总长度，单位是字节ip[0]&amp;0xf 取的是 ip 报文第 1 个字节的低 4 位，&lt;&lt; 2（乘以 4），为 ip 头部长度，单位是字节tcp[12]&amp;0xf0 取的是 tcp 报文第 13 个字节的高 4 位，&gt;&gt; 2 其实等价于 &gt;&gt; 4 然后 &lt;&lt; 2，为 tcp 头部长度，单位是字节。所以 ((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) 表示的数据长度。【2】打印 80 端口，长度超过 576 的 ip 包 1tcpdump 'port 80 and ip[2:2] &gt; 576' 【3】打印特定 TCP Flag 的数据包TCP Flags 在 tcpdump 抓取的报文中的体现：[S]：SYN（开始连接）[.]: 没有 Flag[P]: PSH（推送数据）[F]: FIN （结束连接）[R]: RST（重置连接）[S.] SYN-ACK，就是 SYN 报文的应答报文。 12tcpdump 'tcp[13] &amp; 16!=0'# 等价于tcpdump 'tcp[tcpflags] == tcp-ack' 打印出所有的 ACK 包. 12tcpdump 'tcp[13] &amp; 4!=0'# 等价于tcpdump 'tcp[tcpflags] == tcp-rst' 打印出所有的 RST 包，即包含 [R] 标志的包。 更多 tcpdump filter 可以查看 PCAP-FILTER 或者 man tcpdump！ 好了，这个 IP 包的解析就到此为止了，照着 TCP/IP 协议分析了一遍, 发现协议也就那么回事儿，没有想象的那么难，不要害怕协议！ 具体抓包示例 IP协议： tcp协议：]]></content>
      <tags>
        <tag>tcpdump</tag>
        <tag>tcp</tag>
        <tag>wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 模拟 网络延迟、网络丢包、网络中断]]></title>
    <url>%2Fos%2Fcomputer-network%2Flinux%E6%A8%A1%E6%8B%9F%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F-%E7%BD%91%E7%BB%9C%E4%B8%A2%E5%8C%85-%E7%BD%91%E7%BB%9C%E4%B8%AD%E6%96%AD%2F</url>
    <content type="text"><![CDATA[昨天，笔者讲述了如何将CPU和IO撑满，这个其实很好理解，写个CPU密集型的程序让CPU忙个不停就可以撑满CPU；弄个程序一直写就可以让IO也撑满。有兴趣的同学可以看下昨天的这篇文章《看我如何作死 | 将CPU、IO撑满》，不过里面的做法分别是使用openssl speed和linux dd工具来实现这两个功能。 面对CPU和IO时，相信大家都能很快的反应出如何实现，那么面对网络问题时，大家的反应又是如何呢？不会是拔网线吧。。。 在故障注入，或者说故障演练，甚至说混沌工程中，可以设计很多类型的故障，今天要介绍的就是网络故障。 混沌系统是在分布式系统上进行实验的学科，目的是建立对系统抵御生产环境中失控条件的能力以及信心。 在复杂的网络环境下，数据包发送和接收的时间间隔或长或短。在网络状况较差时，调用下游服务时可能要过很久才能收到返回，这时服务的反应如何，直接关系到稳定性与高可用。 我们这里索要模拟的网络故障有三类，分别是：网络延时、网络中断以及网络丢包。 ​ 一、tc工具介绍笔者也不卖关子，本文模拟的网络故障是通过linux的tc工具来实现的。Linux内核网络协议栈从2.2.x开始，就实现了对服务质量的支持模块。具体的代码位于net/sched/目录。在Linux里面，对这个功能模块的称呼是Traffic Control ,简称TC。TC是一个在上层协议处添加Qos功能的工具，原理上看，它实质是专门供用户利用内核Qos调度模块去定制Qos的中间件。 Linux操作系统中的流量控制器TC（Traffic Control）用于Linux内核的流量控制，主要是通过在输出端口处建立一个队列来实现流量控制。 接收包从输入接口（Input Interface）进来后，经过流量限制（Ingress Policing）丢弃不符合规定的数据包，由输入多路分配器（Input De-Multiplexing）进行判断选择：如果接收包的目的是本主机，那么将该包送给上层处理；否则需要进行转发，将接收包交到转发块（Forwarding Block）处理。转发块同时也接收本主机上层（TCP、UDP等）产生的包。转发块通过查看路由表，决定所处理包的下一跳。然后，对包进行排列以便将它们传送到输出接口（Output Interface）。一般我们只能限制网卡发送的数据包，不能限制网卡接收的数据包，所以我们可以通过改变发送次序来控制传输速率。Linux流量控制主要是在输出接口排列时进行处理和实现的。 tc工具的语法还是很复杂的，笔者（微信公众号：朱小厮的博客）试图想要在本文中详细的讲解一下tc的用法，最后还是放弃了，篇幅太长，难以穷尽。所以本文中只是针对前面说的三种故障简单的演示一下tc的用法以及对应故障的实现方式，希望能够能大家有个小小的印象。如果以后遇到类似问题，或者说对这个东西感兴趣，可以再深度的学习一下。 ​ 二、paping工具介绍在正式介绍如何模拟网络故障之前，还要介绍一个工具来查看模拟的效果如何。 通常我们测试数据包能否通过IP协议到达特定主机，都习惯使用Ping命令，工作时发送一个ICMP Echo，等待接受Echo响应，但是Ping使用的是ICMP协议，如果防火墙放通了此协议，依旧能够ping通，但是无法确定通过tcp传送的数据包是否正常到达对端。 而paping可以在Linux平台上测试网络的连通性及网络延时等。它的用法很简单: 1234-p, --port N 指定被测试服务的 TCP 端口（必须）；--nocolor 屏蔽彩色输出；-t, --timeout 指定超时时长，单位为毫秒，默认值为 1000；-c, --count N 指定测试次数。 比如下面的示例（记得先要开启一个以80为端口的服务, 示例中的xxx.xxx.xxx.xxx代表ip地址）: 123456789101112131415hidden@hidden$ ./paping -p 80 -c 5 xxx.xxx.xxx.xxxpaping v1.5.5 - Copyright (c) 2011 Mike LovellConnecting to xxx.xxx.xxx.xxx on TCP 80:Connected to xxx.xxx.xxx.xxx: time=27.47ms protocol=TCP port=80Connected to xxx.xxx.xxx.xxx: time=97.83ms protocol=TCP port=80Connected to xxx.xxx.xxx.xxx: time=37.38ms protocol=TCP port=80Connected to xxx.xxx.xxx.xxx: time=57.62ms protocol=TCP port=80Connected to xxx.xxx.xxx.xxx: time=71.87ms protocol=TCP port=80Connection statistics: Attempted = 5, Connected = 5, Failed = 0 (0.00%)Approximate connection times: Minimum = 27.47ms, Maximum = 97.83ms, Average = 58.43ms 可以看到平均链接时间为58.43ms。 如果你的机器上没有安装paping，那么可以采用如下的方式安装： 123wget https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/paping/paping_1.5.5_x86_linux.tar.gztar -zvxf paping_1.5.5_x86_linux.tar.gz ./paping -p 80 -c 5000 www.baidu.com 如果有以下的错误： ./paping: error while loading shared libraries: libstdc++.so.6: cannot open shared object file: No such file or directory 可以先安装对应的库来解决： 12sudo apt-get install libstdc++6sudo apt-get install lib32stdc++6 ​ 三、模拟网络延时使用tc命令模拟延迟300ms（对应的删除命令为tc qdisc del dev eth0 root netem）： 12 tc qdisc add dev eth0 root netem delay 300ms// 该命令将网卡eth0的传输设置为延迟300ms发送 此时再次执行paping命令: 123456789101112131415hidden@hidden$ ./paping -p 80 -c 5 xxx.xxx.xxx.xxxpaping v1.5.5 - Copyright (c) 2011 Mike LovellConnecting to xxx.xxx.xxx.xxx on TCP 80:Connected to xxx.xxx.xxx.xxx : time=326.11ms protocol=TCP port=80Connected to xxx.xxx.xxx.xxx : time=417.02ms protocol=TCP port=80Connected to xxx.xxx.xxx.xxx : time=326.94ms protocol=TCP port=80Connected to xxx.xxx.xxx.xxx : time=326.19ms protocol=TCP port=80Connected to xxx.xxx.xxx.xxx : time=353.51ms protocol=TCP port=80Connection statistics: Attempted = 5, Connected = 5, Failed = 0 (0.00%)Approximate connection times: Minimum = 326.11ms, Maximum = 417.02ms, Average = 349.95ms 与之前的58.43ms相比相差了291.52ms ≈ 300ms。 更真实的情况下，延迟值不会这么精确，会有一定的波动，我们可以用下面的情况来模拟出带有波动性的延迟值： 12tc qdisc add dev eth0 root netem delay 300ms 50ms//该命令将 eth0 网卡的传输设置为延迟 300ms ± 50ms (250 ~ 350 ms 之间的任意值)发送 ​ 四、模拟网络中断这次使用如下的命令： 12tc qdisc add dev eth0 root netem corrupt 10%//该命令将 eth0 网卡的传输设置为随机产生 10% 的损坏的数据包 此时再次执行paping命令: 1./paping -p 80 -c 100 xxx.xxx.xxx.xxx 注意这里的次数改成了100，为了更能清楚的看到中断的实际效果。 运行这个命令的过程中，会有“Connection timed out”字样报出，类似： 123456789&lt;snip&gt;Connected to xxx.xxx.xxx.xxx: time=26.26ms protocol=TCP port=80Connection timed outConnected to xxx.xxx.xxx.xxx: time=65.10ms protocol=TCP port=80Connection timed outConnected to xxx.xxx.xxx.xxx: time=26.50ms protocol=TCP port=80Connected to xxx.xxx.xxx.xxx: time=25.93ms protocol=TCP port=80Connected to xxx.xxx.xxx.xxx: time=27.71ms protocol=TCP port=80&lt;snip&gt; 最终的统计结果如下： 1234Connection statistics: Attempted = 100, Connected = 90, Failed = 10 (10.00%)Approximate connection times: Minimum = 25.67ms, Maximum = 133.77ms, Average = 51.98ms 结果显而易见，验证了此次故障模拟所对应的效果。 ​ 五、模拟网络丢包使用如下命令： 123tc qdisc add dev eth0 root netem loss 7% 25%//该命令将 eth0 网卡的传输设置为随机丢掉 7% 的数据包, 成功率为 25% //如果不加上后面的25%，那么一丝就是随机丢掉7%的数据包 再次执行paping命令时，也会有Connection timed out报出，最终的统计结果如下： 1234Connection statistics: Attempted = 100, Connected = 99, Failed = 1 (1.00%)Approximate connection times: Minimum = 25.80ms, Maximum = 133.87ms, Average = 60.94ms 7%*25%的值在1%-2%之间，符合测试的结果预期。 tc还可以模拟一些其它的网络故障，比如网络包重复、网络包错序等等，有兴趣的同学可以继续深入了解一下。 ​ 六、引申混沌工程和传统测试之间的区别很多同学在进行一些故障测试的时候，会认为其正在进行混沌实验，其实混沌工程和传统的测试之间是有区别的。 混沌工程和传统测试（故障注入FIT、故障测试）在关注点和工具集上都有很大的重叠。譬如，在Netflix（如果还不知道Netflix是谁，可以先看看这篇《明星公司之Netflix》了解一下）的很多混沌工程实验研究的对象都是基于故障注入来引入的。混沌工程和这些传统测试方法的主要区别在于：混沌工程是发现新信息的实践过程，而故障注入则是对一个特定的条件、变量的验证方法。 当你希望探究复杂系统如何应对异常时，对系统中的服务注入通信故障（如超时、错误等）不失为一种很好的方法。但有时我们希望探究更多其他的非故障类的场景，如流量激增、资源竞争条件、拜占庭故障（例如性能差或有异常的节点发出有错误的响应、异常的行为、对调用者随机性的返回不同的响应，等等）、非计划中的或非正常组合的消息处理等等。因为如果一个面向公众用户的网站突然收到激增的流量，从而产生更多的收入时我们很难称之为故障，但我们仍然需要探究清楚系统在这种情况下的影响。 和故障注入类似，故障测试方法通过对预先设想到的可以破坏系统的点进行测试，但是并没能去探究上述这类更广阔领域里的、不可预知的、但很可能发生的事情。 在传统测试中，我们可以写一个断言（assertion），即我们给定一个特定的条件，产生一个特定的输出。测试一般来说只会产生二元的结果，验证一个结果是真还是假，从而判定测试是否通过。严格意义上来说，这个过程并不能让我们发掘出对于系统未知的、尚不明确的认知，它仅仅是对我们已知的系统属性可能的取值进行测验。而实验可以产生新的认知，而且通常还能开辟出一个更广袤的对复杂系统的认知空间。 混沌工程是一种帮助我们获得更多的关于系统的新认知的实验方法。它和已有的功能测试、集成测试等以测试已知属性的方法有本质上的区别。 ​ 七、后续后面还会有几篇相同主题的文章发出，不出意外，下一篇应该是《怎么让进程假死》，如果有兴趣的话，可以持续关注本公众号（朱小厮的博客）。如果你还有有什么需要进一步了解的可以在下方留言，或者也聊聊你对这一块的认知和想法。]]></content>
      <categories>
        <category>linux</category>
        <category>centos7</category>
      </categories>
      <tags>
        <tag>centos7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ELK单节点系统构建]]></title>
    <url>%2Felasticsearch%2FELK%E5%8D%95%E8%8A%82%E7%82%B9%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[安装 jdk（jdk7+）tar -zxf jdk-8u65-linux-x64.tar.gz -C /data/carloz/tools/设置java环境变量vim /etc/profile 1234export JAVA_HOME=/carloz/tools/jdk1.8.0_65export JRE_HOME=$JAVA_HOME/jreexport PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATHexport CLASSPATH=$CLASSPATH:.:/JAVA_HOME/lib:$JAVA_HOME/jre/lib source /etc/profilejava -version 安装 Elasticsearchtar -zxf elasticsearch-7.0.0-linux-x86_64.tar.gz -C /data/carloz/tools/cd elasticsearch-7.0.0/ ./bin/elasticsearch 这是出于系统安全考虑设置的条件。由于ElasticSearch可以接收用户输入的脚本并且执行，为了系统安全考虑。创建elsearch用户组及elsearch用户groupadd elsearchuseradd elsearch -g elsearch -p elasticsearchcd /data/carloz/tools/chown -R elsearch:elsearch elasticsearch-7.0.0/su elsearchcd elasticsearch-7.0.0/./bin/elasticsearch -d 一个警告，操作系统内核版本太低，忽略即可 netstat -nltp | grep 9200 ps aux | grep elastic* curl ‘http://127.0.0.1:9200&#39;如下代表启动成功： 配置Elasticsearchsu elsearchcd /data/carloz/tools/elasticsearch-7.0.0vi config/elasticsearch.ymlgrep -v ^# config/elasticsearch.yml 集群监控curl -XGET ‘http://localhost:9200/_cluster/health?pretty=true&#39; 安装 Logstashsu rootcd /carloz/downloadtar -zxf logstash-7.0.0.tar.gz -C /data/carloz/tools/cd /data/carloz/tools/logstash-7.0.0/ 定义 一个叫 stdin 的数据源，和一个叫stdout的输出目标，无论我们输入什么，都会输出到标准命令行：./bin/logstash -e ‘input { stdin { } } output { stdout {} }’等待启动成功之后，输入 hello logastsh 1、Logstash 输入源2、Logstash 输出目标3、Logstash 过滤器 定义输入源，输出目标： mkdir -p myconfvi myconf/jyweb-nginx.conf 1234567891011input&#123; file&#123; path =&gt; ["/opt/software/nginx/logs/*.log"] &#125;&#125;output&#123; elasticsearch&#123; hosts =&gt; ["localhost:9200"] index =&gt; "jyweb_nginx_log" &#125;&#125; 启动logstash./bin/logstash -f myconf/jyweb-nginx.conf &amp; 安装 Kibanatar -zxf /carloz/download/kibana-7.0.0-linux-x86_64.tar.gz -C /data/carloz/tools/cd /data/carloz/tools/kibana-7.0.0-linux-x86_64 修改配置文件，指向Elasticsearch服务器vi config/kibana.yml 1234server.port: 5601server.host: "0.0.0.0"server.name: "logs-server"elasticsearch.hosts: ["http://localhost:9200"] 启动./bin/kibana 访问：http://10.10.139.42:5601]]></content>
      <categories>
        <category>elastic</category>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7 路由管理]]></title>
    <url>%2Fos%2Fcomputer-network%2Fcentos7%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[查看路由：[root@nauru-084 ~]# route -n 添加路由：[root@nauru-084 ~]# route add -host 10.10.87.38 gw 172.18.1.89 [root@nauru-084 ~]# route add -host 10.10.13.39 gw 172.18.1.89]]></content>
      <categories>
        <category>linux</category>
        <category>centos7</category>
      </categories>
      <tags>
        <tag>centos7</tag>
        <tag>route</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rocketmq简介]]></title>
    <url>%2Fmq%2Frocketmq-introduce%2F</url>
    <content type="text"></content>
      <categories>
        <category>mq</category>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>mq</tag>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kafka简介]]></title>
    <url>%2Fmq%2Fkafka-introduce%2F</url>
    <content type="text"></content>
      <categories>
        <category>mq</category>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>mq</tag>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rabbitmq简介]]></title>
    <url>%2Fmq%2Frabbitmq-introduce%2F</url>
    <content type="text"></content>
      <categories>
        <category>mq</category>
        <category>rabbitmq</category>
      </categories>
      <tags>
        <tag>mq</tag>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Valid Parentheses]]></title>
    <url>%2Fleetcode%2Fvalid-parentheses%2F</url>
    <content type="text"><![CDATA[算法分类：Stack url：https://leetcode.com/problems/valid-parentheses/ 题目 12345678910111213141516171819202120. Valid ParenthesesGiven a string containing just the characters '(', ')', '&#123;', '&#125;', '[' and ']', determine if the input string is valid.An input string is valid if:Open brackets must be closed by the same type of brackets.Open brackets must be closed in the correct order.Note that an empty string is also considered valid.Example 1:Input: "()"Output: trueExample 2:Input: "()[]&#123;&#125;"Output: trueExample 3:Input: "(]"Output: false Java解法： 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;String&gt; stack = new Stack&lt;&gt;(); char[] chArr = s.toCharArray(); for (char ch : chArr) &#123; String top = stack.isEmpty() ? null : stack.peek(); String c = String.valueOf(ch); if (null == top) &#123; stack.push(c); &#125; else if (top.equals("&#123;")) &#123; if (c.equals("&#125;")) &#123; stack.pop(); &#125; else &#123; stack.push(c); &#125; &#125; else if (top.equals("[")) &#123; if (c.equals("]")) &#123; stack.pop(); &#125; else &#123; stack.push(c); &#125; &#125; else if (top.equals("(")) &#123; if (c.equals(")")) &#123; stack.pop(); &#125; else &#123; stack.push(c); &#125; &#125; else &#123; stack.push(c); &#125; &#125; if (stack.isEmpty()) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125; 12345678910111213141516171819202122class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); HashMap&lt;Character, Character&gt; map = new HashMap&lt;Character, Character&gt;() &#123;&#123; put('&#125;', '&#123;'); put(']', '['); put(')', '('); &#125;&#125;; char[] chArr = s.toCharArray(); for (char ch : chArr) &#123; Character top = stack.isEmpty() ? null : stack.peek(); if (null == top) &#123; stack.push(ch); &#125; else if (top == map.get(ch)) &#123; stack.pop(); &#125; else &#123; stack.push(ch); &#125; &#125; return stack.isEmpty(); &#125;&#125; Python解法： 12345678910111213141516class Solution(object): def isValid(self, s): """ :type s: str :rtype: bool """ stack = [] map = &#123;u'&#125;':u'&#123;', u']':u'[', u')':u'('&#125; for ch in s: top = u'#' if (len(stack) == 0) else stack[-1] if map.has_key(ch) and top == map[ch]: stack.pop() else: stack.append(ch) return 0 == len(stack)]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unique Binary Search Trees ii]]></title>
    <url>%2Fleetcode%2Funique-binary-search-trees-ii%2F</url>
    <content type="text"><![CDATA[算法：二叉搜索树 url：https://leetcode-cn.com/problems/unique-binary-search-trees-ii/ 题目 1234567891011121314151617181920给定一个整数 n，生成所有由 1 ... n 为节点所组成的二叉搜索树。示例:输入: 3输出:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]解释:以上的输出对应以下 5 种不同结构的二叉搜索树： 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 分析 首先来计数需要构建的二叉树数量。可能的二叉搜素数数量是一个 卡特兰数。 我们跟随上文的逻辑，只是这次是构建具体的树，而不是计数。 算法 我们从序列 1 ..n 中取出数字 i，作为当前树的树根。于是，剩余 i - 1 个元素可用于左子树，n - i 个元素用于右子树。如 前文所述，这样会产生 G(i - 1) 种左子树 和 G(n - i) 种右子树，其中 G 是卡特兰数。 现在，我们对序列 1 … i - 1 重复上述过程，以构建所有的左子树；然后对 i + 1 … n 重复，以构建所有的右子树。 这样，我们就有了树根 i 和可能的左子树、右子树的列表。 最后一步，对两个列表循环，将左子树和右子树连接在根上。 Java解法 123456789101112131415161718192021222324252627282930313233343536public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125;class Solution &#123; public List&lt;TreeNode&gt; generateTrees(int n) &#123; if (n &lt;= 0) &#123; return new LinkedList&lt;TreeNode&gt;(); &#125; return listTrees(1, n); &#125; public LinkedList&lt;TreeNode&gt; listTrees(int start, int end) &#123; LinkedList&lt;TreeNode&gt; rootList = new LinkedList&lt;TreeNode&gt;(); if(start &gt; end) &#123; rootList.add(null); return rootList; &#125; for(int i=start; i&lt;=end; ++i) &#123; LinkedList&lt;TreeNode&gt; leftList = listTrees(start, i-1); LinkedList&lt;TreeNode&gt; rightList = listTrees(i+1, end); for(TreeNode left : leftList) &#123; for(TreeNode right : rightList) &#123; TreeNode cur = new TreeNode(i); cur.left = left; cur.right = right; rootList.add(cur); &#125; &#125; &#125; return rootList; &#125;&#125; Python解法]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Two Ssum]]></title>
    <url>%2Fleetcode%2Ftwo-sum%2F</url>
    <content type="text"><![CDATA[url：https://leetcode.com/problems/two-sum/submissions/ 题目：Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Java 解法：12345678910111213class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException("No two sum solution"); &#125;&#125; Python解法：12345678910111213# https://leetcode.com/problems/two-sum/submissions/class Solution(object): def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ for i in range(len(nums)): x = target-nums[i]; c = nums[0:i].count(x); if c &gt; 0 and nums.index(x) != i: return [nums.index(x), i]]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Recover Binary Search Tree]]></title>
    <url>%2Fleetcode%2Frecover-binary-search-tree%2F</url>
    <content type="text"><![CDATA[算法：二叉搜索树， 深度优先搜索 url：https://leetcode.com/problems/recover-binary-search-tree/ 题目 123456789101112131415161718192021222324252627282930313233343599. Recover Binary Search TreeTwo elements of a binary search tree (BST) are swapped by mistake.Recover the tree without changing its structure.Example 1:Input: [1,3,null,null,2] 1 / 3 \ 2Output: [3,1,null,null,2] 3 / 1 \ 2Example 2:Input: [3,1,4,null,null,2] 3 / \1 4 / 2Output: [2,1,4,null,null,3] 2 / \1 4 / 3Follow up:A solution using O(n) space is pretty straight forward.Could you devise a constant space solution? 分析 要求，不改变现有树结构的前提，使数恢复为二叉搜索树； 使用DFS便利二叉树，凡是 不符合规则的节点都标记出来； 中序遍历，遍历结果有序，无序的节点就是 不合格的节点 Java解法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125;class Solution &#123; TreeNode pre; TreeNode first, second; public void recoverTree(TreeNode root) &#123; pre = new TreeNode(Integer.MIN_VALUE); inorder(root); swap(first, second); &#125; public void inorder(TreeNode root) &#123; if(null == root) return; inorder(root.left); if(pre.val &gt;= root.val &amp;&amp; pre.val != Integer.MIN_VALUE) &#123; if(null == first) first = pre; second = root; &#125; pre = root; inorder(root.right); &#125; public void swap(TreeNode node1, TreeNode node2) &#123; int tmp = node1.val; node1.val = node2.val; node2.val = tmp; &#125;&#125;public class MainClass &#123; public static TreeNode stringToTreeNode(String input) &#123; input = input.trim(); input = input.substring(1, input.length() - 1); if (input.length() == 0) &#123; return null; &#125; String[] parts = input.split(","); String item = parts[0]; TreeNode root = new TreeNode(Integer.parseInt(item)); Queue&lt;TreeNode&gt; nodeQueue = new LinkedList&lt;&gt;(); nodeQueue.add(root); int index = 1; while(!nodeQueue.isEmpty()) &#123; TreeNode node = nodeQueue.remove(); if (index == parts.length) &#123; break; &#125; item = parts[index++]; item = item.trim(); if (!item.equals("null")) &#123; int leftNumber = Integer.parseInt(item); node.left = new TreeNode(leftNumber); nodeQueue.add(node.left); &#125; if (index == parts.length) &#123; break; &#125; item = parts[index++]; item = item.trim(); if (!item.equals("null")) &#123; int rightNumber = Integer.parseInt(item); node.right = new TreeNode(rightNumber); nodeQueue.add(node.right); &#125; &#125; return root; &#125; public static String treeNodeToString(TreeNode root) &#123; if (root == null) &#123; return "[]"; &#125; String output = ""; Queue&lt;TreeNode&gt; nodeQueue = new LinkedList&lt;&gt;(); nodeQueue.add(root); while(!nodeQueue.isEmpty()) &#123; TreeNode node = nodeQueue.remove(); if (node == null) &#123; output += "null, "; continue; &#125; output += String.valueOf(node.val) + ", "; nodeQueue.add(node.left); nodeQueue.add(node.right); &#125; return "[" + output.substring(0, output.length() - 2) + "]"; &#125; public static void main(String[] args) throws IOException &#123; BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = in.readLine()) != null) &#123; TreeNode root = stringToTreeNode(line); new Solution().recoverTree(root); String out = treeNodeToString(root); System.out.print(out); &#125; &#125;&#125; Python解法]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>Binary Tree</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单链表反转]]></title>
    <url>%2Fleetcode%2Freverse-linked-list%2F</url>
    <content type="text"><![CDATA[算法：单链表反转 题目 123456这其实是一道变形的链表反转题，大致描述如下给定一个单链表的头节点 head,实现一个调整单链表的函数，使得每K个节点之间为一组进行逆序，并且从链表的尾部开始组起，头部剩余节点数量不够一组的不需要逆序。（不能使用队列或者栈作为辅助）例如：链表:1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;null, K = 3。那么 6-&gt;7-&gt;8，3-&gt;4-&gt;5，1-&gt;2各位一组。调整后：1-&gt;2-&gt;5-&gt;4-&gt;3-&gt;8-&gt;7-&gt;6-&gt;null。其中 1，2不调整，因为不够一组。 解析 这道题的难点在于，是从链表的尾部开始组起的，而不是从链表的头部，如果是头部的话，那我们还是比较容易做的，因为你可以遍历链表，每遍历 k 个就拆分为一组来逆序。但是从尾部的话就不一样了，因为是单链表，不能往后遍历组起； 思路1：整体反转，然后从头开始截取 K个节点 ，被后续截图的K个节点 的尾部连接；最后长度不足K的节点再局部反转 作为 队头 思路2：整体反转， Java解法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Node &#123; int val; Node next; public Node(int d) &#123; this.val = d; &#125;&#125;class Solution &#123; public Node reverse(Node node) &#123; Node pre = node; Node cur = node.next; node.next = null; Node tmp; while(cur!=null) &#123; tmp = cur.next; cur.next = pre; pre = cur; cur = tmp; &#125; return pre; &#125; public Node reverseByK(Node node, int k) &#123; Node tmp = node; for (int i=1; i&lt;k &amp;&amp; tmp != null; i++) &#123; tmp = tmp.next; &#125; if (tmp == null) &#123; return node; &#125; Node childList = tmp.next; tmp.next = null; Node retNode = reverse(node); Node newChildNode = reverseByK(childList, k); node.next = newChildNode; return retNode; &#125; public static void main(String[] args) &#123; Node link = null; Node tmp = link; for(int i=1; i&lt;9; ++i) &#123; if(null == tmp) &#123; tmp = new Node(i); link = tmp; &#125; else &#123; tmp.next = new Node(i); tmp = tmp.next; &#125; &#125; Solution solution = new Solution(); link = solution.reverse(solution.reverseByK(solution.reverse(link), 3)); while(link!=null) &#123; System.out.print(link.val + " "); link = link.next; &#125; &#125;&#125; Python解法]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Longest Palindromic Substring]]></title>
    <url>%2Fleetcode%2Flongest-palindromic-substring%2F</url>
    <content type="text"><![CDATA[算法：动态规划 URL：https://leetcode-cn.com/problems/longest-palindromic-substring/ 题目 1234567891011给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。示例 1：输入: "babad"输出: "bab"注意: "aba" 也是一个有效答案。示例 2：输入: "cbbd"输出: "bb" 分析 Java解法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.util.Stack;public class Solution &#123; public String longestPalindrome(String s) &#123; String longestS=null, curS=null; for(int i=0; i&lt;s.length(); ++i) &#123; curS = palindrome(s.toCharArray(), i); if (null == curS) continue; if (null == longestS) longestS = curS; else &#123; if (longestS.length() &lt;= curS.length()) longestS = curS; &#125; &#125; return (null == longestS) ? "" : longestS; &#125; public String palindrome(char[] chArr, int index) &#123; Stack&lt;Character&gt; stack1 = new Stack&lt;Character&gt;(); Stack&lt;Character&gt; stack2 = new Stack&lt;Character&gt;(); int len1=0, len2=0; if(index-1&gt;=0 &amp;&amp; chArr[index] == chArr[index-1]) &#123; for(int i=index-1; i&gt;=0; --i) &#123; int delta = index-1-i; if(index+delta&gt;=chArr.length) break; if(chArr[i] == chArr[index+delta]) &#123; stack1.push(chArr[i]); &#125; else &#123; break; &#125; &#125; len1 = stack1.size()*2; &#125; if(index-2&gt;=0 &amp;&amp; chArr[index] == chArr[index-2]) &#123; stack2.push(chArr[index-1]); for(int i=index-2; i&gt;=0; --i) &#123; int delta = index-2-i; if(index+delta&gt;=chArr.length) break; if(chArr[i] == chArr[index+delta]) &#123; stack2.push(chArr[i]); &#125; else &#123; break; &#125; &#125; len2 = stack2.size()*2 - 1; &#125; // System.out.printf("%d, %d %c \n", len1, len2, chArr[index]); if (0==len1 &amp;&amp; 0==len2) return String.valueOf(chArr[index]); if (len1&gt;len2) &#123; char[] res = new char[len1]; for(int i=0; !stack1.isEmpty(); ++i) &#123; char c = stack1.pop().charValue(); res[i] = res[len1-1-i] = c; &#125; return String.copyValueOf(res); &#125; else &#123; char[] res = new char[len2]; for(int i=0; !stack2.isEmpty(); ++i) &#123; char c = stack2.pop().charValue(); res[i] = res[len2-1-i] = c; &#125; return String.copyValueOf(res); &#125; &#125; public static void main(String[] args) &#123; String s = "ba"; String ret = new Solution().longestPalindrome(s); String out = (ret); System.out.print(out); &#125;&#125; 同样解法的代码优化 1234567891011121314151617181920212223242526class Solution &#123; public String longestPalindrome(String s) &#123; if (s == null || s.length() &lt; 1) return ""; int start = 0, end = 0; for (int i = 0; i &lt; s.length(); i++) &#123; int len1 = expandAroundCenter(s, i, i); int len2 = expandAroundCenter(s, i, i + 1); int len = Math.max(len1, len2); if (len &gt; end - start) &#123; start = i - (len - 1) / 2; end = i + len / 2; &#125; &#125; return s.substring(start, end + 1); &#125; private int expandAroundCenter(String s, int left, int right) &#123; int L = left, R = right; while (L &gt;= 0 &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123; L--; R++; &#125; return R - L - 1; &#125;&#125; 还有一种动态规划的解法，需要接着研究 Python解法]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kth Largest Element in an Array]]></title>
    <url>%2Fleetcode%2Fkth-largest-element-in-an-array%2F</url>
    <content type="text"><![CDATA[算法：Heap 堆题目url:https://leetcode.com/problems/kth-largest-element-in-an-array/ 1234567891011121314215. Kth Largest Element in an ArrayFind the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.Example 1:Input: [3,2,1,5,6,4] and k = 2Output: 5Example 2:Input: [3,2,3,1,2,4,5,5,6] and k = 4Output: 4Note: You may assume k is always valid, 1 ≤ k ≤ array's length. 分析用数据结构 Head（堆）来实现 堆：完全二叉树，常常用数组表示 用数组表示一棵树时，如果数组中节点的索引位x，则a、它的父节点的下标是：(x-1)/2；b、它的左子节点的下标为：2x + 1；c、它的右子节点的下标是：2x + 2； 堆的数组实现：https://www.cnblogs.com/g177w/p/8469399.html Java解法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133class Solution &#123; class Node &#123; private int data; public Node(int d) &#123; this.data = d; &#125; public int getValue() &#123; return this.data; &#125; public void setValue(int d) &#123; this.data = d; &#125; &#125; class Head &#123; private Node[] headArray; private int maxSize; private int currentSize; public Head(int maxSize) &#123; this.maxSize = maxSize; currentSize = 0; headArray = new Node[maxSize]; &#125; public boolean isEmpty() &#123; return 0 == currentSize; &#125; public boolean insert(int d) &#123; if (this.currentSize == this.maxSize) &#123; return false; &#125; Node node = new Node(d); headArray[currentSize] = node; trickleUp(currentSize++); return true; &#125; public void trickleUp(int index) &#123; int parentIndex = (index - 1) / 2; Node node = headArray[index]; while (index &gt; 0 &amp;&amp; headArray[parentIndex].getValue() &lt; node.getValue()) &#123; headArray[index] = headArray[parentIndex]; index = parentIndex; parentIndex = (index - 1) / 2; &#125; headArray[index] = node; &#125; public Node remove() &#123; Node root = headArray[0]; headArray[0] = headArray[--currentSize]; trickleDown(0); return root; &#125; public void trickleDown(int index) &#123; int largeChild; Node node = headArray[index]; while (index &lt; currentSize/2) &#123; int leftChild = 2 * index + 1; int rightChild = 2 * index +2; if (rightChild &lt; currentSize &amp;&amp; headArray[leftChild].getValue() &lt; headArray[rightChild].getValue()) &#123; largeChild = rightChild; &#125; else &#123; largeChild = leftChild; &#125; if (node.getValue() &gt;= headArray[largeChild].getValue()) &#123; break; &#125; headArray[index] = headArray[largeChild]; index = largeChild; &#125; headArray[index] = node; &#125; public boolean change(int index, int newValue) &#123; if (index &lt; 0 || index &gt; currentSize) &#123; return false; &#125; int oldValue = headArray[index].getValue(); headArray[index].setValue(newValue); if (oldValue &lt; newValue) &#123; trickleUp(index); &#125; else &#123; trickleDown(index); &#125; return true; &#125; public void displayHead() &#123; System.out.print("headArray:"); for (int i = 0; i &lt; currentSize; i++) &#123; if (headArray[i] != null) System.out.print(headArray[i].getValue()+" "); else System.out.print("--"); &#125; System.out.println(""); int nBlanks = 32; int itemsPerrow = 1; int column = 0; int j = 0; String dots = "........................"; System.out.println(dots + dots); while (currentSize &gt; 0)&#123; if (column == 0) for (int i = 0; i &lt; nBlanks; i++) &#123; System.out.print(" "); &#125; System.out.print(headArray[j].getValue()); if (++ j == currentSize) break; if (++ column == itemsPerrow)&#123; nBlanks /= 2; itemsPerrow *= 2; column = 0; System.out.println(); &#125; else for (int i = 0; i &lt; nBlanks * 2 - 2; i++) System.out.print(' '); &#125; System.out.println("\n"+dots + dots); &#125; &#125; public int findKthLargest(int[] nums, int k) &#123; Head head = new Solution().new Head(nums.length); for (int x : nums) &#123; head.insert(x); &#125; for (int i=0; i&lt;k-1; ++i) &#123; head.remove(); &#125; int ret = head.remove().getValue(); return ret; &#125;&#125; Python解法12]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>Binary Tree</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[h index ii]]></title>
    <url>%2Fleetcode%2Fh-index-ii%2F</url>
    <content type="text"><![CDATA[算法：url：https://leetcode.com/problems/h-index-ii/ 题目1234567891011121314151617181920Given an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.According to the definition of h-index on Wikipedia: "A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each."Example:Input: citations = [0,1,3,5,6]Output: 3 Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, her h-index is 3.Note:If there are several possible values for h, the maximum one is taken as the h-index.Follow up:This is a follow up problem to H-Index, where citations is now guaranteed to be sorted in ascending order.Could you solve it in logarithmic time complexity? 思路分析[0,1,3,5,6] 数组长度 n，存在一个元素 h， 使得 n 中有 h个元素 大于等于h， 其他 （n-h）个元素 &lt; h； 求h？ 数组是有序的 递增数组 遍历 arr，存在 arr[i], 使得 n-i == arr[i] Java解法12345678910class Solution &#123; public int hIndex(int[] citations) &#123; for(int i=citations.length-1; i&gt;=0; --i) &#123; if(citations[i] == citations.length-i) &#123; return citations[i]; &#125; &#125; return 0; &#125;&#125; 1234567891011121314151617181920public int hIndex(int[] citations) &#123; int l = 1, r = citations.length; int ans = 0; while(l &lt;= r)&#123; int m = l + ((r - l)&gt;&gt;1); int p = citations[citations.length - m]; if(m == p)&#123; return m; &#125; if(m &gt; p)&#123; r = m - 1; &#125; else&#123; ans = Math.max(ans, m); l = m + 1; &#125; &#125; return ans; &#125;&#125; Python解法]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary Tree Right Side View]]></title>
    <url>%2Fleetcode%2Fbinary-tree-right-side-view%2F</url>
    <content type="text"><![CDATA[算法：二叉树广度优先遍历 BFS URL：https://leetcode.com/problems/binary-tree-right-side-view/ 题目 1234567891011121314151617181920212223242526Binary Tree Right Side ViewGiven a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.Example:Input: [1,2,3,null,5,null,4]Output: [1, 3, 4]Explanation: 1 &lt;--- / \2 3 &lt;--- \ \ 5 4 &lt;---Input: [1,2,3,null,5,null,4,null,null,8]Output: [1, 3, 4, 8]Explanation: 1 &lt;--- / \ 2 3 &lt;--- \ \ 5 4 &lt;--- / 8 &lt;--- 分析 使用层序遍历（level traversal），即广度优先搜索 —— 借助Queue 难点是 标注每一层，来标注 每层的最后一个节点 当前层节点总数：count1，当前访问到节点数 i 下一层几点总数：count2 Java解法 12345678910111213141516171819202122232425262728293031323334353637383940public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125;class Solution &#123; public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; return BFS(root); &#125; public List&lt;Integer&gt; BFS(TreeNode root) &#123; List&lt;Integer&gt; retList = new ArrayList&lt;Integer&gt;(); if(null == root) return retList; int count1=1, count2=0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.add(root); while(!queue.isEmpty()) &#123; for(int i=0; i&lt;count1; ++i) &#123; TreeNode tn = queue.poll(); if(null != tn) &#123; if (i == count1-1) &#123; retList.add(tn.val); &#125; if(null != tn.left) &#123; queue.add(tn.left); count2++; &#125; if (null != tn.right) &#123; queue.add(tn.right); count2++; &#125; &#125; &#125; count1 = count2; count2 = 0; &#125; return retList; &#125;&#125; 结果 Runtime: 1 ms, faster than 98.22% of Java online submissions for Binary Tree Right Side View. Memory Usage: 36.3 MB, less than 100.00% of Java online submissions for Binary Tree Right Side View. 1次AC，Niubility Python解法 12]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>Binary Tree</tag>
        <tag>广度优先遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary Tree Maximum Path Sum]]></title>
    <url>%2Fleetcode%2Fbinary-tree-maximum-path-sum%2F</url>
    <content type="text"><![CDATA[算法：二叉树 + 动态规划 url：https://leetcode.com/problems/binary-tree-maximum-path-sum/ 题目 12345678910111213141516171819202122232425124. Binary Tree Maximum Path SumGiven a non-empty binary tree, find the maximum path sum.For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.Example 1:Input: [1,2,3] 1 / \ 2 3Output: 6Example 2:Input: [-10,9,20,null,null,15,7] -10 / \ 9 20 / \ 15 7Output: 42 分析： 不要求 最大值的路径，只要求最大值 Java解法 1234567891011121314151617181920public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125;class Solution &#123; int ret = Integer.MIN_VALUE; public int maxPathSum(TreeNode root) &#123; return maxSum(root); &#125; public int maxSum(TreeNode root) &#123; if (null == root) return 0; int l = Math.max(0, maxSum(root.left)); int r = Math.max(0, maxSum(root.right)); int sum = l + r + root.val; ret = Math.max(ret, sum); return Math.max(l, r) + root.val; &#125;&#125;]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>Binary Tree</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Add Two Numbers]]></title>
    <url>%2Fleetcode%2Fadd-two-numbers%2F</url>
    <content type="text"><![CDATA[算法：链表 Linked list url：https://leetcode.com/problems/add-two-numbers/ 题目：Add Two Numbers 1234567You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.Example:Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 分析 百位大数相加 Java解法 方法 定义 链表增加节点 单链表反转 不需要，只是为了练习算法 遍历链表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.test.demo;import java.io.IOException;class ListNode &#123; int val; ListNode next; public ListNode(int x) &#123;this.val = x;&#125;&#125;class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode retNode = null; int carryBit = 0; while(l1 != null || l2!= null) &#123; int d1 = null==l1 ? 0 : l1.val; int d2 = null==l2 ? 0 : l2.val; int d = d1 + d2 + carryBit; retNode = add(retNode, new ListNode(d%10)); carryBit = d/10; l1 = null==l1 ? l1 : l1.next; l2 = null==l2 ? l2 : l2.next; &#125; for (int i = carryBit; i&gt;0; i = i/10) &#123; retNode = add(retNode, new ListNode(i%10)); &#125; return retNode;// return reverse(retNode); &#125; public ListNode add(ListNode headNode, ListNode node) &#123; if (null == headNode) &#123; headNode = node; &#125; else &#123; ListNode index = headNode; while(index.next != null) &#123;index = index.next;&#125; index.next = node; &#125; return headNode; &#125; public ListNode reverse(ListNode headNode) &#123; if(headNode == null) return headNode; ListNode pre = headNode; ListNode cur; ListNode temp; for(cur = headNode.next; cur!=null; ) &#123; temp = cur.next; cur.next = pre; pre = cur; cur = temp; &#125; headNode.next = null; return pre; &#125;&#125;public class MainClass &#123; public static int[] stringToIntegerArray(String input) &#123; input = input.trim(); input = input.substring(1, input.length() - 1); if (input.length() == 0) &#123; return new int[0]; &#125; String[] parts = input.split(","); int[] output = new int[parts.length]; for(int index = 0; index &lt; parts.length; index++) &#123; String part = parts[index].trim(); output[index] = Integer.parseInt(part); &#125; return output; &#125; public static ListNode stringToListNode(String input) &#123; // Generate array from the input int[] nodeValues = stringToIntegerArray(input); // Now convert that list into linked list ListNode dummyRoot = new ListNode(0); ListNode ptr = dummyRoot; for(int item : nodeValues) &#123; ptr.next = new ListNode(item); ptr = ptr.next; &#125; return dummyRoot.next; &#125; public static String listNodeToString(ListNode node) &#123; if (node == null) &#123; return "[]"; &#125; String result = ""; while (node != null) &#123; result += Integer.toString(node.val) + ", "; node = node.next; &#125; return "[" + result.substring(0, result.length() - 2) + "]"; &#125; public static void main(String[] args) throws IOException &#123; ListNode l1 = stringToListNode("[9]"); ListNode l2 = stringToListNode("[1,9,9,9,9,9,9,9,9,9]"); ListNode ret = new Solution().addTwoNumbers(l1, l2); String out = listNodeToString(ret); System.out.print(out); &#125;&#125; Python解法]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>Linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java异步回调demo]]></title>
    <url>%2Fjava%2Fasync-callback-demo%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334import java.util.concurrent.*;interface ICallback &#123; void getResult(int s);&#125;class Calc &#123; public void calc(int i, ICallback callback) throws Exception &#123; FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; int s = i * i; Thread.sleep(5000); System.out.println("do in future task. " + Thread.currentThread().getName()); callback.getResult(s); return s; &#125; &#125;); new Thread(futureTask).start(); &#125;&#125;public class App &#123; public static void main(String[] args) throws Exception &#123; ICallback callback = new ICallback() &#123; @Override public void getResult(int s) &#123; System.out.println(s); &#125; &#125;; new Calc().calc(1000, callback); System.out.println("do in main"); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
        <category>juc</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Callable</tag>
        <tag>Callback</tag>
        <tag>FutureTask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to 0ms AC]]></content>
  </entry>
</search>
