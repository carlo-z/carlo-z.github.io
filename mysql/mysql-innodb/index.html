<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  
    
      
    

    
  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=consolas:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="官方文档：https://dev.mysql.com/doc/refman/5.6/en/innodb-storage-engine.html 目录 14.1 InnoDB简介    14.2 InnoDB和ACID模型 14.3 InnoDB多版本 14.4 InnoDB架构 14.5 InnoDB内存结构    14.6 InnoDB磁盘结构    14.7 InnoDB锁定和事务模型">
<meta name="keywords" content="Java Kafka Docker JVM NIO Netty">
<meta property="og:type" content="article">
<meta property="og:title" content="mysql5.6 innodb存储引擎">
<meta property="og:url" content="https://carlo-z.com/mysql/mysql-innodb/index.html">
<meta property="og:site_name" content="Focus-1">
<meta property="og:description" content="官方文档：https://dev.mysql.com/doc/refman/5.6/en/innodb-storage-engine.html 目录 14.1 InnoDB简介    14.2 InnoDB和ACID模型 14.3 InnoDB多版本 14.4 InnoDB架构 14.5 InnoDB内存结构    14.6 InnoDB磁盘结构    14.7 InnoDB锁定和事务模型">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://imagehome.oss-cn-beijing.aliyuncs.com/20191122160128.png">
<meta property="og:image" content="https://imagehome.oss-cn-beijing.aliyuncs.com/20191122161052.png">
<meta property="og:image" content="https://imagehome.oss-cn-beijing.aliyuncs.com/20191203113218.png">
<meta property="og:image" content="https://imagehome.oss-cn-beijing.aliyuncs.com/20191203141337.png">
<meta property="og:image" content="https://dev.mysql.com/doc/refman/5.6/en/images/innodb-change-buffer.png">
<meta property="og:image" content="https://imagehome.oss-cn-beijing.aliyuncs.com/20191203143854.png">
<meta property="og:image" content="https://imagehome.oss-cn-beijing.aliyuncs.com/20191203205602.png">
<meta property="og:image" content="https://imagehome.oss-cn-beijing.aliyuncs.com/20191203205602.png">
<meta property="og:updated_time" content="2019-12-29T13:18:52.457Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mysql5.6 innodb存储引擎">
<meta name="twitter:description" content="官方文档：https://dev.mysql.com/doc/refman/5.6/en/innodb-storage-engine.html 目录 14.1 InnoDB简介    14.2 InnoDB和ACID模型 14.3 InnoDB多版本 14.4 InnoDB架构 14.5 InnoDB内存结构    14.6 InnoDB磁盘结构    14.7 InnoDB锁定和事务模型">
<meta name="twitter:image" content="https://imagehome.oss-cn-beijing.aliyuncs.com/20191122160128.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://carlo-z.com/mysql/mysql-innodb/">





  <title>mysql5.6 innodb存储引擎 | Focus-1</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Focus-1</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://carlo-z.com/mysql/mysql-innodb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Focus-1">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus-1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">mysql5.6 innodb存储引擎</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-03T00:00:00+08:00">
                2018-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>官方文档：<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-storage-engine.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/innodb-storage-engine.html</a></p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><blockquote>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-introduction.html" target="_blank" rel="noopener">14.1 InnoDB简介</a>   </p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/mysql-acid.html" target="_blank" rel="noopener">14.2 InnoDB和ACID模型</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-multi-versioning.html" target="_blank" rel="noopener">14.3 InnoDB多版本</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-architecture.html" target="_blank" rel="noopener">14.4 InnoDB架构</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-in-memory-structures.html" target="_blank" rel="noopener">14.5 InnoDB内存结构</a>   </p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-on-disk-structures.html" target="_blank" rel="noopener">14.6 InnoDB磁盘结构</a>   </p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-locking-transaction-model.html" target="_blank" rel="noopener">14.7 InnoDB锁定和事务模型</a>   </p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-configuration.html" target="_blank" rel="noopener">14.8 InnoDB配置</a>   </p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-compression.html" target="_blank" rel="noopener">14.9 InnoDB表压缩</a>   </p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-file-format.html" target="_blank" rel="noopener">14.10 InnoDB文件格式管理</a>   </p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-row-format.html" target="_blank" rel="noopener">14.11 InnoDB行格式</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-disk-management.html" target="_blank" rel="noopener">14.12 InnoDB磁盘I / O和文件空间管理</a>   </p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-online-ddl.html" target="_blank" rel="noopener">14.13 InnoDB和在线DDL</a>   </p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html" target="_blank" rel="noopener">14.14 InnoDB启动选项和系统变量</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-information-schema.html" target="_blank" rel="noopener">14.15 InnoDB INFORMATION_SCHEMA表</a>   </p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-performance-schema.html" target="_blank" rel="noopener">14.16 InnoDB与MySQL性能架构的集成</a>   </p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-monitors.html" target="_blank" rel="noopener">14.17 InnoDB监视器</a>   </p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-backup-recovery.html" target="_blank" rel="noopener">14.18 InnoDB备份和恢复</a>   </p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-and-mysql-replication.html" target="_blank" rel="noopener">14.19 InnoDB和MySQL复制</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-memcached.html" target="_blank" rel="noopener">14.20 InnoDB memcached插件</a>   </p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-troubleshooting.html" target="_blank" rel="noopener">14.21 InnoDB故障排除</a>   </p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-limits.html" target="_blank" rel="noopener">14.22 InnoDB限制</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-restrictions-limitations.html" target="_blank" rel="noopener">14.23 InnoDB的限制和限制</a></p>
</blockquote>
<h2 id="14-1-InnoDB简介"><a href="#14-1-InnoDB简介" class="headerlink" title="14.1 InnoDB简介"></a>14.1 InnoDB简介</h2><p><code>InnoDB</code>是一种兼顾了高可靠性和高性能的通用存储引擎。在MySQL 5.6中，<code>InnoDB</code>是默认的MySQL存储引擎。除非您配置了其他默认存储引擎，否则发出<a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>不带<code>ENGINE=</code> 子句的语句将创建一个<code>InnoDB</code>表。</p>
<p><code>InnoDB</code> 包括适用于MySQL 5.1的InnoDB插件的所有功能，以及特定于MySQL 5.5及更高版本的新功能。</p>
<h3 id="InnoDB的主要优势"><a href="#InnoDB的主要优势" class="headerlink" title="InnoDB的主要优势"></a>InnoDB的主要优势</h3><ul>
<li>它的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_dml" target="_blank" rel="noopener">DML</a>操作遵循 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_acid" target="_blank" rel="noopener">ACID</a>模型，并 具有具有 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_commit" target="_blank" rel="noopener">提交</a>，<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_rollback" target="_blank" rel="noopener">回滚</a>和 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_crash_recovery" target="_blank" rel="noopener">崩溃恢复</a> 功能的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_transaction" target="_blank" rel="noopener">事务</a>， 以保护用户数据。有关更多信息<a href="https://dev.mysql.com/doc/refman/5.6/en/mysql-acid.html" target="_blank" rel="noopener">，</a>请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/mysql-acid.html" target="_blank" rel="noopener">第14.2节“ InnoDB和ACID模型”</a>。</li>
<li>行级<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_locking" target="_blank" rel="noopener">锁定</a>和Oracle风格的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_consistent_read" target="_blank" rel="noopener">一致读取可</a>提高多用户并发性和性能。有关更多信息<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-locking-transaction-model.html" target="_blank" rel="noopener">，</a>请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-locking-transaction-model.html" target="_blank" rel="noopener">第14.7节“ InnoDB锁定和事务模型”</a>。</li>
<li><code>InnoDB</code>表格将您的数据排列在磁盘上以基于<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_primary_key" target="_blank" rel="noopener">主键</a>优化查询 。每个 <code>InnoDB</code>表都有一个称为<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_clustered_index" target="_blank" rel="noopener">聚集索引</a>的主键索引，该<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_clustered_index" target="_blank" rel="noopener">索引</a> 组织数据以最小化主键查找的I / O。有关更多信息<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-index-types.html" target="_blank" rel="noopener">，</a>请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-index-types.html" target="_blank" rel="noopener">第14.6.2.1节“聚集索引和二级索引”</a>。</li>
<li>维护数据 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_referential_integrity" target="_blank" rel="noopener">完整性</a>， <code>InnoDB</code>支持 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_foreign_key" target="_blank" rel="noopener"><code>FOREIGN KEY</code></a>约束。使用外键检查插入，更新和删除操作，以确保它们不会导致不同表之间的不一致。有关更多信息<a href="https://dev.mysql.com/doc/refman/5.6/en/create-table-foreign-keys.html" target="_blank" rel="noopener">，</a>请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/create-table-foreign-keys.html" target="_blank" rel="noopener">第13.1.17.6节“外键约束”</a>。</li>
</ul>
<p><strong>表14.1 InnoDB存储引擎功能</strong></p>
<table>
<thead>
<tr>
<th>特征</th>
<th>支持</th>
</tr>
</thead>
<tbody><tr>
<td><strong>B树索引</strong></td>
<td>是</td>
</tr>
<tr>
<td><strong>备份/时间点恢复</strong>（在服务器中而不是在存储引擎中实现。）</td>
<td>是</td>
</tr>
<tr>
<td><strong>集群数据库支持</strong></td>
<td>没有</td>
</tr>
<tr>
<td><strong>聚集索引</strong></td>
<td>是</td>
</tr>
<tr>
<td><strong>压缩数据</strong></td>
<td>是</td>
</tr>
<tr>
<td><strong>资料快取</strong></td>
<td>是</td>
</tr>
<tr>
<td><strong>加密数据</strong></td>
<td>是（通过加密功能在服务器中实现；在MySQL 5.7和更高版本中，支持静态数据表空间加密。）</td>
</tr>
<tr>
<td><strong>外键支持</strong></td>
<td>是</td>
</tr>
<tr>
<td><strong>全文搜索索引</strong></td>
<td>是（MySQL 5.6和更高版本提供InnoDB对FULLTEXT索引的支持。）</td>
</tr>
<tr>
<td><strong>地理空间数据类型支持</strong></td>
<td>是</td>
</tr>
<tr>
<td><strong>地理空间索引支持</strong></td>
<td>是（MySQL 5.7和更高版本提供InnoDB对地理空间索引的支持。）</td>
</tr>
<tr>
<td><strong>哈希索引</strong></td>
<td>否（InnoDB在内部将哈希索引用于其自适应哈希索引功能。）</td>
</tr>
<tr>
<td><strong>索引缓存</strong></td>
<td>是</td>
</tr>
<tr>
<td><strong>锁定粒度</strong></td>
<td>行</td>
</tr>
<tr>
<td><strong>MVCC</strong></td>
<td>是</td>
</tr>
<tr>
<td><strong>复制支持</strong>（在服务器中而不是在存储引擎中实现。）</td>
<td>是</td>
</tr>
<tr>
<td><strong>储存限制</strong></td>
<td>64TB</td>
</tr>
<tr>
<td><strong>T树索引</strong></td>
<td>没有</td>
</tr>
<tr>
<td><strong>交易次数</strong></td>
<td>是</td>
</tr>
<tr>
<td><strong>更新数据字典的统计信息</strong></td>
<td>是</td>
</tr>
</tbody></table>
<p>要将其功能<code>InnoDB</code>与MySQL随附的其他存储引擎进行比较，请参阅<a href="https://dev.mysql.com/doc/refman/5.6/en/storage-engines.html" target="_blank" rel="noopener">第15章，</a><a href="https://dev.mysql.com/doc/refman/5.6/en/storage-engines.html" target="_blank" rel="noopener"><em>备用存储引擎中</em></a>的“ <em>存储引擎功能”</em>表 。</p>
<p><strong>Table 15.1 Storage Engines Feature Summary</strong></p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>MyISAM</th>
<th>Memory</th>
<th>InnoDB</th>
<th>Archive</th>
<th>NDB</th>
</tr>
</thead>
<tbody><tr>
<td><strong>B-tree indexes</strong></td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td><strong>Backup/point-in-time recovery</strong> (note 1)</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td><strong>Cluster database support</strong></td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td><strong>Clustered indexes</strong></td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td><strong>Compressed data</strong></td>
<td>Yes (note 2)</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><strong>Data caches</strong></td>
<td>No</td>
<td>N/A</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td><strong>Encrypted data</strong></td>
<td>Yes (note 3)</td>
<td>Yes (note 3)</td>
<td>Yes (note 4)</td>
<td>Yes (note 3)</td>
<td>Yes (note 3)</td>
</tr>
<tr>
<td><strong>Foreign key support</strong></td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>Yes (note 5)</td>
</tr>
<tr>
<td><strong>Full-text search indexes</strong></td>
<td>Yes</td>
<td>No</td>
<td>Yes (note 6)</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td><strong>Geospatial data type support</strong></td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td><strong>Geospatial indexing support</strong></td>
<td>Yes</td>
<td>No</td>
<td>Yes (note 7)</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td><strong>Hash indexes</strong></td>
<td>No</td>
<td>Yes</td>
<td>No (note 8)</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td><strong>Index caches</strong></td>
<td>Yes</td>
<td>N/A</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td><strong>Locking granularity</strong></td>
<td>Table</td>
<td>Table</td>
<td>Row</td>
<td>Row</td>
<td>Row</td>
</tr>
<tr>
<td><strong>MVCC</strong></td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td><strong>Replication support</strong> (note 1)</td>
<td>Yes</td>
<td>Limited (note 9)</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td><strong>Storage limits</strong></td>
<td>256TB</td>
<td>RAM</td>
<td>64TB</td>
<td>None</td>
<td>384EB</td>
</tr>
<tr>
<td><strong>T-tree indexes</strong></td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td><strong>Transactions</strong></td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td><strong>Update statistics for data dictionary</strong></td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody></table>
<br>

<h2 id="14-2-InnoDB和ACID模型"><a href="#14-2-InnoDB和ACID模型" class="headerlink" title="14.2 InnoDB和ACID模型"></a>14.2 InnoDB和ACID模型</h2><p>该<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_acid" target="_blank" rel="noopener">ACID</a>模式是一组数据库设计原则强调的是，对于业务数据和关键任务应用重要的可靠性方面。MySQL包含诸如<code>InnoDB</code>存储引擎严格遵循ACID模型，因此数据不会损坏，结果也不会因软件崩溃和硬件故障等异常情况而失真。当您依赖于ACID的功能时，您无需重新发明一致性检查和崩溃恢复机制。如果您有其他软件保护措施，超可靠的硬件或可以容忍少量数据丢失或不一致的应用程序，则可以调整MySQL设置以牺牲一些ACID可靠性，以获得更高的性能或吞吐量。</p>
<p>以下各节讨论MySQL功能（尤其是<code>InnoDB</code>存储引擎）如何 与ACID模型的类别进行交互：</p>
<ul>
<li><strong>答</strong>：原子性。</li>
<li><strong>C</strong>：一致性。</li>
<li><strong>我</strong>：：隔离。</li>
<li><strong>D</strong>：耐久性。</li>
</ul>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>ACID模型 的<strong>原子性</strong>方面主要涉及<code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_transaction" target="_blank" rel="noopener">事务</a>。相关的MySQL功能包括：</p>
<ul>
<li>自动提交设置。</li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a> 声明。</li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>ROLLBACK</code></a> 声明。</li>
<li><code>INFORMATION_SCHEMA</code> 表中的 操作数据。</li>
</ul>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>ACID模型 的<strong>一致性</strong>方面主要涉及内部<code>InnoDB</code>处理，以防止数据崩溃。相关的MySQL功能包括：</p>
<ul>
<li><code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_doublewrite_buffer" target="_blank" rel="noopener">doublewrite缓冲区</a>。</li>
<li><code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_crash_recovery" target="_blank" rel="noopener">崩溃恢复</a>。</li>
</ul>
<h3 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h3><p>ACID模型 的<strong>隔离</strong>方面主要涉及<code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_transaction" target="_blank" rel="noopener">事务</a>，尤其是适用于每个事务的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_isolation_level" target="_blank" rel="noopener">隔离级别</a>。相关的MySQL功能包括：</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_autocommit" target="_blank" rel="noopener">自动提交</a>设置。</li>
<li><code>SET ISOLATION LEVEL</code> 声明。</li>
<li><code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_locking" target="_blank" rel="noopener">锁定</a> 的底层细节。在性能调整期间，您可以通过<code>INFORMATION_SCHEMA</code>表格查看这些详细信息 。</li>
</ul>
<h3 id="耐用性"><a href="#耐用性" class="headerlink" title="耐用性"></a>耐用性</h3><p>ACID模型 的<strong>持久性</strong>方面涉及与特定硬件配置交互的MySQL软件功能。由于取决于您的CPU，网络和存储设备的功能的可能性很多，因此为具体的准则提供最复杂的方面。（这些准则可能采取购买“ 新硬件 ”的形式 。）相关的MySQL功能包括：</p>
<ul>
<li><code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_doublewrite_buffer" target="_blank" rel="noopener">doublewrite buffer</a>，由<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_doublewrite" target="_blank" rel="noopener"><code>innodb_doublewrite</code></a> 配置选项打开和关闭 。</li>
<li>配置选项 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_flush_log_at_trx_commit" target="_blank" rel="noopener"><code>innodb_flush_log_at_trx_commit</code></a>。</li>
<li>配置选项 <a href="https://dev.mysql.com/doc/refman/5.6/en/replication-options-binary-log.html#sysvar_sync_binlog" target="_blank" rel="noopener"><code>sync_binlog</code></a>。</li>
<li>配置选项 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a>。</li>
<li>存储设备（例如磁盘驱动器，SSD或RAID阵列）中的写缓冲区。</li>
<li>存储设备中由电池支持的缓存。</li>
<li>用来运行MySQL的操作系统，特别是它对<code>fsync()</code>系统调用的支持。</li>
<li>不间断电源（UPS）保护运行MySQL服务器并存储MySQL数据的所有计算机服务器和存储设备的电源。</li>
<li>您的备份策略，例如备份的频率和类型以及备份保留期。</li>
<li>对于分布式或托管数据应用程序，MySQL服务器的硬件所在的数据中心的特定特性，以及数据中心之间的网络连接。</li>
</ul>
<br>

<h2 id="14-3-InnoDB-MVCC"><a href="#14-3-InnoDB-MVCC" class="headerlink" title="14.3 InnoDB MVCC"></a>14.3 InnoDB MVCC</h2><p><code>InnoDB</code>是一个 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_mvcc" target="_blank" rel="noopener">多版本的存储引擎</a>：它保留有关已更改行的旧版本的信息，以支持诸如并发和<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_rollback" target="_blank" rel="noopener">回滚之</a>类的事务功能 。此信息存储在表空间中的数据结构中，该数据结构称为 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_rollback_segment" target="_blank" rel="noopener">回滚段</a>（在Oracle中类似的数据结构之后）。<code>InnoDB</code> 使用回滚段中的信息来执行事务回滚中所需的撤消操作。它还使用该信息来构建行的早期版本，以实现 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_consistent_read" target="_blank" rel="noopener">一致的读取</a>。</p>
<p>在内部，<code>InnoDB</code>向数据库中存储的每一行添加三个字段。6个字节的<code>DB_TRX_ID</code>字段表示插入或更新该行的最后一个事务的事务标识符。同样，删除在内部被视为更新，在该更新中，行中的特殊位被设置为将其标记为已删除。每行还包含一个7字节的 <code>DB_ROLL_PTR</code>字段，称为滚动指针。回滚指针指向写入回滚段的Undo Log记录。如果行已更新，则Undo Log记录将包含在更新行之前重建行内容所必需的信息。一个6字节的<code>DB_ROW_ID</code>字段包含一个行ID，该行ID随着插入新行而单调增加。如果 <code>InnoDB</code>自动生成聚集索引，该索引包含行ID值。否则，该 <code>DB_ROW_ID</code>列不会出现在任何索引中。</p>
<p>回滚段中的Undo Log分为插入和更新Undo Log。插入Undo Log仅在事务回滚时才需要，并且在事务提交后可以立即将其丢弃。更新Undo Log也用于一致的读取中，但是只有在不存在为其<code>InnoDB</code>分配了快照的事务（ 一致的读取可能需要更新Undo Log中的信息来构建数据库的早期版本）后，才可以将其删除行。</p>
<p>定期提交您的事务，包括仅发出一致读取的事务。否则， <code>InnoDB</code>将无法丢弃更新Undo Log中的数据，并且回滚段可能会变得太大而填满表空间。</p>
<p>回滚段中的Undo Log记录的物理大小通常小于相应的插入或更新的行。您可以使用此信息来计算回滚段所需的空间。</p>
<p>在<code>InnoDB</code>多版本方案中，当您使用SQL语句删除行时，并不会立即将其从数据库中物理删除。<code>InnoDB</code>仅在丢弃为删除而编写的更新Undo Log记录时，才物理删除相应的行及其索引记录。此删除操作称为<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_purge" target="_blank" rel="noopener">purge</a>，它非常快，通常花费与执行删除操作的SQL语句相同的时间顺序。</p>
<p>如果您以大约相同的速率在表中以较小的批次插入和删除行，则由于所有“ 死 ”行，清除线程可能开始滞后并且表可能会变得越来越大 ，从而使所有内容都受磁盘约束慢。在这种情况下，请限制新行的操作，并通过调整<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_max_purge_lag" target="_blank" rel="noopener"><code>innodb_max_purge_lag</code></a>系统变量来向清除线程分配更多资源 。有关更多信息<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html" target="_blank" rel="noopener">，</a>请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html" target="_blank" rel="noopener">第14.14节“ InnoDB启动选项和系统变量”</a>。</p>
<h3 id="多版本索引和二级索引"><a href="#多版本索引和二级索引" class="headerlink" title="多版本索引和二级索引"></a>多版本索引和二级索引</h3><p><code>InnoDB</code>多版本并发控制（MVCC）对二级索引的处理方式不同于聚簇索引。聚簇索引中的记录将就地更新，其隐藏的系统列指向<code>Undo Log</code>条目，可以从中重建记录的早期版本。与聚簇索引记录不同，辅助索引记录不包含隐藏的系统列，也不会就地更新。</p>
<p>更新二级索引列时，将对旧的二级索引记录进行删除标记，插入新记录，并最终清除带有删除标记的记录。当二级索引记录被删除标记或二级索引页被较新的事务更新时，<code>InnoDB</code>在聚集索引中查找数据库记录。在聚集索引中，<code>DB_TRX_ID</code>检查记录的记录，如果在启动读取事务后修改了记录，则从<code>Undo Log</code>中检索记录的正确版本。</p>
<p>如果二级索引记录被标记为删除或二级索引页被更新的事务更新， 则不使用<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_covering_index" target="_blank" rel="noopener">覆盖索引</a>技术。而不是从索引结构中返回值，而是<code>InnoDB</code>在聚集索引中查找记录。</p>
<p>但是，如果启用了 <a href="https://dev.mysql.com/doc/refman/5.6/en/index-condition-pushdown-optimization.html" target="_blank" rel="noopener">索引条件下推（ICP）</a>优化，并且<code>WHERE</code>只能使用索引中的字段来评估部分条件，则MySQL服务器仍会将<code>WHERE</code>条件的这一部分下推到存储引擎，并使用指数。如果找不到匹配的记录，则避免聚集索引查找。如果找到了匹配的记录，即使在删除标记的记录中，也要在 <code>InnoDB</code>聚簇索引中查找记录。</p>
<br>

<h2 id="14-4-InnoDB架构"><a href="#14-4-InnoDB架构" class="headerlink" title="14.4 InnoDB架构"></a>14.4 InnoDB架构</h2><p>下图显示了构成<code>InnoDB</code>存储引擎体系结构的内存中和磁盘上的结构。有关每种结构的信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-in-memory-structures.html" target="_blank" rel="noopener">第14.5节“ InnoDB内存结构”</a>和 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-on-disk-structures.html" target="_blank" rel="noopener">第14.6节“ InnoDB磁盘结构”</a>。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191122160128.png" alt></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191122161052.png" alt></p>
<p><strong>图14.1 InnoDB架构</strong></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191203113218.png" alt></p>
<br>

<h2 id="14-5-InnoDB内存结构"><a href="#14-5-InnoDB内存结构" class="headerlink" title="14.5 InnoDB内存结构"></a>14.5 InnoDB内存结构</h2><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-buffer-pool.html" target="_blank" rel="noopener">14.5.1缓冲池</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-change-buffer.html" target="_blank" rel="noopener">14.5.2Change Buffer</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-adaptive-hash.html" target="_blank" rel="noopener">14.5.3自适应哈希索引</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-redo-log-buffer.html" target="_blank" rel="noopener">14.5.4日志缓冲区</a></li>
</ul>
<h3 id="14-5-1-Buffer-Pool"><a href="#14-5-1-Buffer-Pool" class="headerlink" title="14.5.1 Buffer Pool"></a>14.5.1 Buffer Pool</h3><p>Buffer Pool是主内存中的一个区域，在<code>InnoDB</code>访问表和索引数据时会在其中进行 缓存。Buffer Pool允许直接从内存中直接处理经常使用的数据，从而加快了处理速度。在专用服务器上，通常将多达80％的物理内存分配给缓冲池。</p>
<p>为了提高大容量读取操作的效率，Buffer Pool被分为多个<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_page" target="_blank" rel="noopener">页面</a>，这些<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_page" target="_blank" rel="noopener">页面</a>可能包含多个行。为了提高缓存管理的效率，Buffer Pool被实现为页面的链接列表。使用<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_lru" target="_blank" rel="noopener">LRU</a>算法的变体将很少使用的数据从缓存中老化掉 。</p>
<p>知道如何利用缓冲池将经常访问的数据保留在内存中是MySQL优化的重要方面。</p>
<h4 id="缓冲池LRU算法"><a href="#缓冲池LRU算法" class="headerlink" title="缓冲池LRU算法"></a>缓冲池LRU算法</h4><p>使用最近最少使用（LRU）算法的变体，将缓冲池作为列表进行管理。当需要空间以将新页面添加到缓冲池时，将驱逐最近使用最少的页面，并将新页面添加到列表的中间。此中点插入策略将列表视为两个子列表：</p>
<ul>
<li>最前面是最近访问过的新页面（“ 年轻 ”） 的子列表</li>
<li>在末尾，是最近访问的旧页面的子列表</li>
</ul>
<p><strong>图14.2缓冲池列表</strong></p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191203141337.png" alt></p>
<p>该算法将大量页面保留在新的子列表中。旧的子列表包含较少使用的页面。这些页面是<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_eviction" target="_blank" rel="noopener">驱逐的</a>候选对象 。</p>
<p>默认情况下，该算法的运行方式如下：</p>
<ul>
<li>3/8的缓冲池专用于旧的子列表。</li>
<li>列表的中点是新子列表的尾部与旧子列表的头相交的边界。</li>
<li>当<code>InnoDB</code>将页面读入缓冲池时，它首先将其插入中点（旧子列表的头部）。可以读取页面，因为它是用户启动的操作（例如SQL查询）所必需的，或作为的自动执行的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_read_ahead" target="_blank" rel="noopener">预读</a>操作的一部分 <code>InnoDB</code>。</li>
<li>访问旧子列表中的页面 使其变为“ 年轻 ”，将其移至新子列表的头部。如果由于用户启动的操作而需要读取页面，则将立即进行首次访问，并使页面年轻。如果由于预读操作而读取了该页面，则第一次访问不会立即发生，并且在退出该页面之前可能根本不会发生。</li>
<li>随着数据库的运行，通过移至列表的尾部，缓冲池中未被访问的页面将“ 老化 ”。新的和旧的子列表中的页面都会随着其他页面的更新而老化。随着将页面插入中点，旧子列表中的页面也会老化。最终，未使用的页面到达旧子列表的尾部并被逐出。</li>
</ul>
<p>默认情况下，查询读取的页面会立即移入新的子列表，这意味着它们在缓冲池中的停留时间更长。例如，针对<a href="https://dev.mysql.com/doc/refman/5.6/en/mysqldump.html" target="_blank" rel="noopener"><strong>mysqldump</strong></a>操作或<code>SELECT</code>不带<code>WHERE</code>子句的 语句 执行的表扫描可以将大量数据带入缓冲池，并驱逐同等数量的旧数据，即使不再使用新数据也是如此。同样，由预读后台线程加载且仅访问一次的页面将移到新列表的开头。这些情况可能会将常用页面推送到旧的子列表，在此它们会被逐出。有关优化此行为的信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-performance-midpoint_insertion.html" target="_blank" rel="noopener">第14.8.3.2节“使缓冲池扫描具有抵抗力”</a>和 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-performance-read_ahead.html" target="_blank" rel="noopener">第14.8.3.3节“配置InnoDB缓冲池预取（预读）”</a>。</p>
<p><code>InnoDB</code>标准监视器输出在<code>BUFFER POOL AND MEMORY</code>有关缓冲池LRU算法操作的部分中包含几个字段。有关详细信息，请参阅<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-buffer-pool.html#innodb-buffer-pool-monitoring" target="_blank" rel="noopener">使用InnoDB Standard Monitor监视缓冲池</a>。</p>
<h4 id="缓冲池配置"><a href="#缓冲池配置" class="headerlink" title="缓冲池配置"></a>缓冲池配置</h4><blockquote>
<p>那么innodb-buffer-pool-size的大小应该设置为什么呢？下面我们就开始谈到这个。</p>
<p><strong>独立服务器</strong></p>
<p>在一个独立的只使用InnoDB引擎的MySQL服务器中，根据经验，推荐设置innodb-buffer-pool-size为服务器总可用内存的80%。<br>为什么不是90%或者100%呢？因为其它的东西也需要内存：</p>
<ul>
<li>每个查询至少需要几K的内存(有时候是几M)</li>
<li>有各种其它内部的MySQL结构和缓存</li>
<li>InnoDB有一些结构是不用缓冲池的内存的(字典缓存，文件系统，锁系统和页哈希表等)</li>
<li>也有一些MySQL文件是在OS缓存里的(binary日志，relay日志,innodb事务日志等)</li>
<li>此处，你也必须为操作系统留出些内存</li>
</ul>
<p><strong>共享服务器</strong></p>
<p>如果你的MySQL服务器与其它应用共享资源，那么上面80%的经验就不那么适用了。<br>在这样的环境下，设置一个对的数字有点难度。<br>首先让我们来统计一下InnoDB表的实际占用大小。执行如下查询：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT engine,</span><br><span class="line">&gt;   count(*) as TABLES,</span><br><span class="line">&gt;   concat(round(sum(table_rows)/1000000,2),'M') rows,</span><br><span class="line">&gt;   concat(round(sum(data_length)/(1024*1024*1024),2),'G') DATA,</span><br><span class="line">&gt;   concat(round(sum(index_length)/(1024*1024*1024),2),'G') idx,</span><br><span class="line">&gt;   concat(round(sum(data_length+index_length)/(1024*1024*1024),2),'G') total_size,</span><br><span class="line">&gt;   round(sum(index_length)/sum(data_length),2) idxfrac</span><br><span class="line">&gt; FROM information_schema.TABLES</span><br><span class="line">&gt; WHERE table_schema not in ('mysql', 'performance_schema', 'information_schema')</span><br><span class="line">&gt; GROUP BY engine</span><br><span class="line">&gt; ORDER BY sum(data_length+index_length) DESC LIMIT 10;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>这会给出一个参考，让你知道如果你想缓存整个数据集应该为InnoDB缓冲池设置多少内存合适。<br>不过大多数情况你不需要那样做，你只需要缓存你经常使用的数据集。<br>设置好之后，我们来看看如何检查InnoDB缓冲池大小是否设置足够。<br>在终端中，执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> $ mysqladmin ext -ri1 | grep Innodb_buffer_pool_reads</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> | Innodb_buffer_pool_reads                 | 1832098003     |</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> | Innodb_buffer_pool_reads                 | 595            |</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> | Innodb_buffer_pool_reads                 | 915            |</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> | Innodb_buffer_pool_reads                 | 734            |</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> | Innodb_buffer_pool_reads                 | 622            |</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> | Innodb_buffer_pool_reads                 | 710            |</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> | Innodb_buffer_pool_reads                 | 664            |</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> | Innodb_buffer_pool_reads                 | 987            |</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> | Innodb_buffer_pool_reads                 | 1287           |</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> | Innodb_buffer_pool_reads                 | 967            |</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> | Innodb_buffer_pool_reads                 | 1181           |</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> | Innodb_buffer_pool_reads                 | 949            |</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>你所看到的是从硬盘读取数据到缓冲池的次数(每秒)。上面的数据已经相当高了(幸运的是，这个服务器的IO设备能处理每秒4000的IO操作)，如果这个是OLTP系统，我建议提高innodb缓冲池的大小和如果必要增加服务器内存。</p>
<p><strong>更改InnoDB缓冲池</strong></p>
<p>最后，介绍如何更改innodb-buffer-pool-size。<br>如果你运行的是MySQL 5.7，那么非常幸运，你可以在线更改这个变量，只需要以root身份执行如下查询：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; mysql&gt; SET GLOBAL innodb_buffer_pool_size=size_in_bytes;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>这还没完，你仍然需要更改my.cnf文件，不过至少你不需要重启服务器让它生效。从mysql的错误日志中我们可以看到它生效的过程：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> [Note] InnoDB: Resizing buffer pool from 134217728 to 21474836480. (unit=134217728)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> [Note] InnoDB: disabled adaptive <span class="built_in">hash</span> index.</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> [Note] InnoDB: buffer pool 0 : 159 chunks (1302369 blocks) were added.</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> [Note] InnoDB: buffer pool 0 : <span class="built_in">hash</span> tables were resized.</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> [Note] InnoDB: Resized <span class="built_in">hash</span> tables at lock_sys, adaptive <span class="built_in">hash</span> index, dictionary.</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> [Note] InnoDB: Completed to resize buffer pool from 134217728 to 21474836480.</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> [Note] InnoDB: Re-enabled adaptive <span class="built_in">hash</span> index.</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>在更早的mysql版本就需要重启了，所以：</p>
<ol>
<li>在my.cnf中设置一个innodb_buffer_pool_size合适的值</li>
<li>重启mysql服务器</li>
</ol>
</blockquote>
<p>您可以配置缓冲池的各个方面以提高性能。</p>
<ul>
<li>理想情况下，您可以将Buffer Pool的大小设置为与实际一样大的值，从而为服务器上的其他进程留出足够的内存以运行而不会进行过多的分页。缓冲池越大，就越<code>InnoDB</code>像内存数据库一样，从磁盘读取一次数据，然后在后续读取期间从内存访问数据。使用<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_buffer_pool_size" target="_blank" rel="noopener"><code>innodb_buffer_pool_size</code></a> 配置选项配置缓冲池大小 。</li>
<li>在具有足够内存的64位系统上，可以将缓冲池分成多个部分，以最大程度地减少并发操作之间的内存结构争用。有关详细信息，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-multiple-buffer-pools.html" target="_blank" rel="noopener">第14.8.3.1节“配置多个缓冲池实例”</a>。</li>
<li>您可以将频繁访问的数据保留在内存中，而不必考虑操作突然导致的活动高峰，这些操作会将大量不经常访问的数据带入缓冲池。有关详细信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-performance-midpoint_insertion.html" target="_blank" rel="noopener">第14.8.3.2节“使缓冲池扫描具有抵抗力”</a>。</li>
<li>您可以控制何时以及如何执行预读请求，以异步方式将页面预取到缓冲池中，从而预期很快将需要这些页面。有关详细信息，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-performance-read_ahead.html" target="_blank" rel="noopener">第14.8.3.3节“配置InnoDB缓冲池预取（预读）”</a>。</li>
<li>您可以控制何时进行后台冲洗，以及是否根据工作负荷动态调整冲洗速率。有关详细信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-buffer-pool-flushing.html" target="_blank" rel="noopener">第14.8.3.4节“配置缓冲池刷新”</a>。</li>
<li>您可以配置如何<code>InnoDB</code>保留当前缓冲池状态，以免在服务器重新启动后进行冗长的预热。有关详细信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-preload-buffer-pool.html" target="_blank" rel="noopener">第14.8.3.5节“保存和恢复缓冲池状态”</a>。</li>
</ul>
<h4 id="使用InnoDB标准监视器监视缓冲池"><a href="#使用InnoDB标准监视器监视缓冲池" class="headerlink" title="使用InnoDB标准监视器监视缓冲池"></a>使用InnoDB标准监视器监视缓冲池</h4><p><code>InnoDB</code>可以使用访问的标准监视器输出， <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-standard-monitor.html" target="_blank" rel="noopener"><code>SHOW ENGINE INNODB STATUS</code></a>提供有关缓冲池操作的度量。缓冲池度量标准位于<code>BUFFER POOL AND MEMORY</code>“ <code>InnoDB</code>标准监视器”输出中的部分，其 外观类似于以下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total memory allocated 2197815296; in additional pool allocated 0</span><br><span class="line">Dictionary memory allocated 155455</span><br><span class="line">Buffer pool size   131071</span><br><span class="line">Free buffers       92158</span><br><span class="line">Database pages     38770</span><br><span class="line">Old database pages 14271</span><br><span class="line">Modified db pages  619</span><br><span class="line">Pending reads 0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 4, not young 0</span><br><span class="line">0.00 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 322, created 38448, written 42083</span><br><span class="line">0.00 reads/s, 222.30 creates/s, 159.47 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead</span><br><span class="line">0.00/s</span><br><span class="line">LRU len: 38770, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br></pre></td></tr></table></figure>

<p>下表描述了<code>InnoDB</code>标准监视器报告的缓冲池度量 标准。</p>
<blockquote>
<p>注意</p>
<p><code>InnoDB</code> 标准监视器输出中 提供的每秒平均值基于自<code>InnoDB</code>上次打印标准监视器输出以来经过的时间 。</p>
</blockquote>
<p><strong>表14.2 InnoDB缓冲池指标</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>分配的总内存</td>
<td>为缓冲池分配的总内存（以字节为单位）。</td>
</tr>
<tr>
<td>分配了额外的池</td>
<td>为附加池分配的总内存（以字节为单位）。</td>
</tr>
<tr>
<td>分配的字典内存</td>
<td>为<code>InnoDB</code>数据字典分配的总内存，以字节为单位。</td>
</tr>
<tr>
<td>缓冲池大小</td>
<td>分配给缓冲池的页面总大小（以页为单位）。</td>
</tr>
<tr>
<td>可用缓冲区</td>
<td>缓冲池空闲列表的页面总大小。</td>
</tr>
<tr>
<td>数据库页面</td>
<td>缓冲池LRU列表的页面总大小。</td>
</tr>
<tr>
<td>旧数据库页面</td>
<td>缓冲池旧LRU子列表的页面总大小。</td>
</tr>
<tr>
<td>修改的数据库页面</td>
<td>缓冲池中当前修改的页面数。</td>
</tr>
<tr>
<td>待读</td>
<td>等待读入缓冲池的缓冲池页面数。</td>
</tr>
<tr>
<td>待写LRU</td>
<td>从LRU列表的底部开始写入的缓冲池中的旧脏页数。</td>
</tr>
<tr>
<td>等待写入刷新列表</td>
<td>检查点期间要刷新的缓冲池页面数。</td>
</tr>
<tr>
<td>待写单页</td>
<td>缓冲池中暂挂的独立页面写入数。</td>
</tr>
<tr>
<td>使页面年轻化</td>
<td>缓冲池LRU列表中变年轻的页面总数（已移至“ new ”页面的子列表的开头）。</td>
</tr>
<tr>
<td>页面不年轻</td>
<td>缓冲池LRU列表中未设置为年轻的页面总数（保留在“ old ”子列表中但未设置为年轻的页面）。</td>
</tr>
<tr>
<td>青少年</td>
<td>每秒平均访问缓冲池LRU列表中的旧页面所导致的页面年轻。有关更多信息，请参见此表后面的注释。</td>
</tr>
<tr>
<td>非年轻</td>
<td>每秒平均访问缓冲池LRU列表中的旧页面导致的页面不年轻。有关更多信息，请参见此表后面的注释。</td>
</tr>
<tr>
<td>阅读页面</td>
<td>从缓冲池读取的页面总数。</td>
</tr>
<tr>
<td>创建页面</td>
<td>在缓冲池中创建的页面总数。</td>
</tr>
<tr>
<td>写的页面</td>
<td>从缓冲池写入的页面总数。</td>
</tr>
<tr>
<td>读/秒</td>
<td>每秒平均每秒读取的缓冲池页面数。</td>
</tr>
<tr>
<td>创建/秒</td>
<td>每秒平均创建的缓冲池页面的每秒数量。</td>
</tr>
<tr>
<td>写/秒</td>
<td>每秒平均缓冲池页面写入数。</td>
</tr>
<tr>
<td>缓冲池命中率</td>
<td>从缓冲池内存与磁盘存储读取的页面的缓冲池页面命中率。</td>
</tr>
<tr>
<td>年青率</td>
<td>页面访问的平均命中率使页面更年轻。有关更多信息，请参见此表后面的注释。</td>
</tr>
<tr>
<td>不（成年率）</td>
<td>页面访问未使页面变年轻的平均命中率。有关更多信息，请参见此表后面的注释。</td>
</tr>
<tr>
<td>预读页面</td>
<td>预读操作的每秒平均数。</td>
</tr>
<tr>
<td>被逐出的页面无权访问</td>
<td>每秒从缓冲池访问而未访问的页面的平均值。</td>
</tr>
<tr>
<td>随机预读</td>
<td>随机预读操作的每秒平均数。</td>
</tr>
<tr>
<td>伦</td>
<td>缓冲池LRU列表的页面总大小。</td>
</tr>
<tr>
<td>unzip_LRU len</td>
<td>缓冲池unzip_LRU列表的页面总大小。</td>
</tr>
<tr>
<td>I / O总和</td>
<td>最近50秒内访问的缓冲池LRU列表页面的总数。</td>
</tr>
<tr>
<td>I / O电流</td>
<td>已访问的缓冲池LRU列表页面的总数。</td>
</tr>
<tr>
<td>I / O解压缩总和</td>
<td>已访问的缓冲池unzip_LRU列表页面的总数。</td>
</tr>
<tr>
<td>I / O解压缩</td>
<td>已访问的缓冲池unzip_LRU列表页面的总数。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>注意事项</strong>：</p>
<ul>
<li>该<code>youngs/s</code>指标仅适用于旧页面。它基于对页面的访问次数，而不是页面数。可以对给定页面进行多次访问，所有访问都计入在内。如果<code>youngs/s</code>在不进行大扫描时看到非常低的 值，则可能需要减少延迟时间或增加用于旧子列表的缓冲池的百分比。增加百分比会使旧的子列表变大，因此该子列表中的页面需要更长的时间才能移到尾部，这增加了再次访问这些页面并使它们变年轻的可能性。</li>
<li>该<code>non-youngs/s</code>指标仅适用于旧页面。它基于对页面的访问次数，而不是页面数。可以对给定页面进行多次访问，所有访问都计入在内。如果<code>non-youngs/s</code>执行大型表扫描时看不到较高的值（较高的<code>youngs/s</code> 值），请增加延迟值。</li>
<li>该<code>young-making</code>比率说明了对所有缓冲池页面的访问，而不仅仅是访问了旧子列表中的页面。该<code>young-making</code>速率和 <code>not</code>速率通常不会加总到整个缓冲池的命中率。旧子列表中的页面命中会导致页面移动到新子列表，但是新子列表中的页面命中只会导致页面与列表的头部保持一定距离时才移动到列表的头部。</li>
<li><code>not (young-making rate)</code>是由于<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_old_blocks_time" target="_blank" rel="noopener"><code>innodb_old_blocks_time</code></a>未满足所定义的延迟，或者由于新子列表中的页面点击未导致页面移动到头部而导致页面访问未使页面变年轻的平均点击率 。此速率说明了对所有缓冲池页面的访问，而不仅仅是访问旧子列表中的页面。</li>
</ul>
<p>缓冲池<a href="https://dev.mysql.com/doc/refman/5.6/en/server-status-variables.html" target="_blank" rel="noopener">服务器状态变量</a>和 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-buffer-pool-stats-table.html" target="_blank" rel="noopener"><code>INNODB_BUFFER_POOL_STATS</code></a>表提供了许多与<code>InnoDB</code>标准监视器输出中相同的缓冲池度量 标准。有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-information-schema-buffer-pool-tables.html#innodb-information-schema-buffer-pool-stats-example" target="_blank" rel="noopener">示例14.10，“查询INNODB_BUFFER_POOL_STATS表”</a>。</p>
<br>



<h3 id="14-5-2-Change-Buffer"><a href="#14-5-2-Change-Buffer" class="headerlink" title="14.5.2 Change Buffer"></a>14.5.2 Change Buffer</h3><p>Change Buffer是一种特殊的数据结构，当<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_secondary_index" target="_blank" rel="noopener">二级索引</a>页不在<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_buffer_pool" target="_blank" rel="noopener">缓冲池(Buffer Pool)中</a>时，它们 会缓存这些更改 。当页面通过其他读取操作加载到缓冲池中时，可能由<a href="https://dev.mysql.com/doc/refman/5.6/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>， <a href="https://dev.mysql.com/doc/refman/5.6/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>或 <a href="https://dev.mysql.com/doc/refman/5.6/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>操作（DML）导致的缓冲更改 将在以后合并。</p>
<p><strong>图14.3Change Buffer</strong></p>
<p><img src="https://dev.mysql.com/doc/refman/5.6/en/images/innodb-change-buffer.png" alt></p>
<p>与<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_clustered_index" target="_blank" rel="noopener">聚簇索引</a>不同，二级索引通常是非唯一的，并且二级索引中的插入以相对随机的顺序发生。同样，删除和更新可能会影响索引树中不相邻的二级索引页。当稍后通过其他操作将受影响的页读入缓冲池时，合并缓存的更改将避免从磁盘将辅助索引页读入缓冲池所需的大量随机访问I / O。</p>
<p>在系统大部分处于空闲状态或缓慢关闭期间运行的清除操作会定期将更新的索引页写入磁盘。与将每个值立即写入磁盘相比，清除操作可以更有效地为一系列索引值写入磁盘块。</p>
<p>当有许多受影响的行和许多辅助索引要更新时，Change Buffer合并可能需要几个小时。在此期间，磁盘I / O会增加，这可能会导致磁盘绑定查询的速度大大降低。提交事务之后，甚至在服务器关闭并重新启动之后，Change Buffer合并也可能继续发生（ 有关更多信息<a href="https://dev.mysql.com/doc/refman/5.6/en/forcing-innodb-recovery.html" target="_blank" rel="noopener">，</a>请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/forcing-innodb-recovery.html" target="_blank" rel="noopener">第14.21.2节“强制InnoDB恢复”</a>）。</p>
<p>在内存中，Change Buffer占用了缓冲池的一部分。在磁盘上，Change Buffer是系统表空间的一部分，当数据库服务器关闭时，索引更改将存储在其中。</p>
<p>Change Buffer中缓存的数据类型由 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_change_buffering" target="_blank" rel="noopener"><code>innodb_change_buffering</code></a>变量控制。有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-change-buffer.html#innodb-change-buffer-configuration" target="_blank" rel="noopener">配置变更缓冲</a>。您还可以配置最大Change Buffer大小。有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-change-buffer.html#innodb-change-buffer-maximum-size" target="_blank" rel="noopener">配置Change Buffer最大大小</a>。</p>
<p>如果索引包含降序索引列或主键包含降序索引列，则辅助索引不支持更改缓冲。</p>
<p>有关Change Buffer的常见问题的答案，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/faqs-innodb-change-buffer.html" target="_blank" rel="noopener">第A.16节“ MySQL 5.6 FAQ：InnoDBChange Buffer”</a>。</p>
<h4 id="配置Change-Buffer"><a href="#配置Change-Buffer" class="headerlink" title="配置Change Buffer"></a>配置Change Buffer</h4><p>在表上执行，和 操作时<a href="https://dev.mysql.com/doc/refman/5.6/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>， 索引列的值（尤其是辅助键的值）通常处于未排序的顺序，需要大量的I / O才能使辅助索引保持最新状态。当相关<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_page" target="_blank" rel="noopener">页面</a>不在 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_buffer_pool" target="_blank" rel="noopener">缓冲池中时</a>，<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_change_buffer" target="_blank" rel="noopener">Change Buffer</a>将 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_change_buffer" target="_blank" rel="noopener">更改</a>缓存到辅助索引条目 ，从而避免了不立即从磁盘读取页面而避免了昂贵的I / O操作。当页面加载到缓冲池中时，缓冲的更改将合并，更新的页面随后将刷新到磁盘。的<a href="https://dev.mysql.com/doc/refman/5.6/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a><a href="https://dev.mysql.com/doc/refman/5.6/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a><code>InnoDB</code>当服务器接近空闲时以及在<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_slow_shutdown" target="_blank" rel="noopener">缓慢关闭</a>期间，主线程会合并缓冲的更改 。</p>
<p>由于Change Buffer功能可以减少磁盘读写操作，因此它对于受I / O约束的工作负载（例如，具有大量DML操作的应用程序，例如批量插入）最有价值。</p>
<p>但是，Change Buffer占用了缓冲池的一部分，从而减少了可用于缓存数据页的内存。如果工作集几乎适合缓冲池，或者您的表具有相对较少的二级索引，则禁用更改缓冲可能很有用。如果工作数据集完全适合缓冲池，则更改缓冲不会带来额外的开销，因为它仅适用于不在缓冲池中的页面。</p>
<p>您可以<code>InnoDB</code> 使用<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_change_buffering" target="_blank" rel="noopener"><code>innodb_change_buffering</code></a> 配置参数来控制执行更改缓冲 的程度。您可以为插入，删除操作（最初将索引记录标记为删除）和清除操作（物理删除索引记录）启用或禁用缓冲。更新操作是插入和删除的组合。默认 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_change_buffering" target="_blank" rel="noopener"><code>innodb_change_buffering</code></a>值为 <code>all</code>。</p>
<p>允许的<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_change_buffering" target="_blank" rel="noopener"><code>innodb_change_buffering</code></a> 值包括：</p>
<ul>
<li><p><strong><code>all</code></strong></p>
<p>默认值：缓冲区插入，删除标记操作和清除。</p>
</li>
<li><p><strong><code>none</code></strong></p>
<p>不要缓冲任何操作。</p>
</li>
<li><p><strong><code>inserts</code></strong></p>
<p>缓冲区插入操作。</p>
</li>
<li><p><strong><code>deletes</code></strong></p>
<p>缓冲区删除标记操作。</p>
</li>
<li><p><strong><code>changes</code></strong></p>
<p>缓冲插入和删除标记操作。</p>
</li>
<li><p><strong><code>purges</code></strong></p>
<p>缓冲在后台发生的物理删除操作。</p>
</li>
</ul>
<p>您可以<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_change_buffering" target="_blank" rel="noopener"><code>innodb_change_buffering</code></a>在MySQL选项文件（<code>my.cnf</code>或 <code>my.ini</code>）中设置 参数，或使用<a href="https://dev.mysql.com/doc/refman/5.6/en/set-variable.html" target="_blank" rel="noopener"><code>SET GLOBAL</code></a> 语句动态更改参数，该 语句需要足够的权限来设置全局系统变量。请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/system-variable-privileges.html" target="_blank" rel="noopener">第5.1.8.1节“系统变量特权”</a>。更改设置会影响新操作的缓冲。现有缓冲条目的合并不受影响。</p>
<h4 id="配置Change-Buffer最大大小"><a href="#配置Change-Buffer最大大小" class="headerlink" title="配置Change Buffer最大大小"></a>配置Change Buffer最大大小</h4><p>该<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_change_buffer_max_size" target="_blank" rel="noopener"><code>innodb_change_buffer_max_size</code></a> 变量允许将<strong><u>Change Buffer的最大大小配置为Buffer Pool总大小的百分比</u></strong>。默认情况下， <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_change_buffer_max_size" target="_blank" rel="noopener"><code>innodb_change_buffer_max_size</code></a>设置为25。最大设置为50。</p>
<p>考虑<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_change_buffer_max_size" target="_blank" rel="noopener"><code>innodb_change_buffer_max_size</code></a>在具有大量插入，更新和删除活动的MySQL服务器上进行增加 ，其中Change Buffer合并不能跟上新的Change Buffer条目，从而导致Change Buffer达到其最大大小限制。</p>
<p>考虑<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_change_buffer_max_size" target="_blank" rel="noopener"><code>innodb_change_buffer_max_size</code></a>在使用静态数据进行报告的MySQL服务器上减少 存储空间，或者Change Buffer消耗的缓冲池共享的内存空间过多，从而导致页面比预期的更快地退出缓冲池。</p>
<p>使用代表性的工作负载测试不同的设置，以确定最佳配置。该 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_change_buffer_max_size" target="_blank" rel="noopener"><code>innodb_change_buffer_max_size</code></a> 设置是动态的，允许在不重新启动服务器的情况下修改设置。</p>
<h4 id="监视Change-Buffer"><a href="#监视Change-Buffer" class="headerlink" title="监视Change Buffer"></a>监视Change Buffer</h4><p>以下选项可用于Change Buffer监视：</p>
<ul>
<li><p><code>InnoDB</code>标准监视器输出包括Change Buffer状态信息。要查看监视器数据，请发出该<code>SHOW ENGINE INNODB STATUS</code>语句。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW ENGINE INNODB STATUS\G</span><br></pre></td></tr></table></figure>

<p>Change Buffer状态信息位于<code>INSERT BUFFER AND ADAPTIVE HASH INDEX</code> 标题下， 并显示类似以下内容：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> BUFFER <span class="keyword">AND</span> ADAPTIVE <span class="keyword">HASH</span> <span class="keyword">INDEX</span></span><br><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line">Ibuf: <span class="keyword">size</span> <span class="number">1</span>, free <span class="keyword">list</span> <span class="keyword">len</span> <span class="number">0</span>, seg <span class="keyword">size</span> <span class="number">2</span>, <span class="number">0</span> merges</span><br><span class="line">merged <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br><span class="line">discarded <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">4425293</span>, used cells <span class="number">32</span>, node <span class="keyword">heap</span> has <span class="number">1</span> buffer(s)</span><br><span class="line"><span class="number">13577.57</span> <span class="keyword">hash</span> searches/s, <span class="number">202.47</span> non-<span class="keyword">hash</span> searches/s</span><br></pre></td></tr></table></figure>

<p>有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-standard-monitor.html" target="_blank" rel="noopener">第14.17.3节“ InnoDB标准监视器和锁定监视器输出”</a>。</p>
</li>
<li><p>该 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-metrics-table.html" target="_blank" rel="noopener"><code>INFORMATION_SCHEMA.INNODB_METRICS</code></a> 表提供了在<code>InnoDB</code>标准监视器输出中找到的大多数数据点 以及其他数据点。要查看Change Buffer度量标准以及每个度量标准的描述，请发出以下查询：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT NAME, COMMENT FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME LIKE '%ibuf%'\G</span><br></pre></td></tr></table></figure>

<p>有关<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-metrics-table.html" target="_blank" rel="noopener"><code>INNODB_METRICS</code></a>表用法的信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-information-schema-metrics-table.html" target="_blank" rel="noopener">第14.15.6节“ InnoDB INFORMATION_SCHEMA指标表”</a>。</p>
</li>
<li><p>该 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-buffer-page-table.html" target="_blank" rel="noopener"><code>INFORMATION_SCHEMA.INNODB_BUFFER_PAGE</code></a> 表提供有关缓冲池中每个页面的元数据，包括Change Buffer索引和Change Buffer位图页面。Change Buffer页面由标识 <code>PAGE_TYPE</code>。<code>IBUF_INDEX</code>是Change Buffer索引页面<code>IBUF_BITMAP</code>的页面类型，并且 是Change Buffer位图页面的页面类型。</p>
<p>警告</p>
<p>查询该<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-buffer-page-table.html" target="_blank" rel="noopener"><code>INNODB_BUFFER_PAGE</code></a> 表可能会带来很大的性能开销。为避免影响性能，请重现要在测试实例上调查的问题，然后在测试实例上运行查询。</p>
<p>例如，您可以查询该 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-buffer-page-table.html" target="_blank" rel="noopener"><code>INNODB_BUFFER_PAGE</code></a>表以确定缓冲池页面总数中所包含的<code>IBUF_INDEX</code>和 的大概数量 <code>IBUF_BITMAP</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT (SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE</span><br><span class="line">       WHERE PAGE_TYPE LIKE 'IBUF%') AS change_buffer_pages, </span><br><span class="line">       (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_BUFFER_PAGE) <span class="keyword">AS</span> total_pages,</span><br><span class="line">       (<span class="keyword">SELECT</span> ((change_buffer_pages/total_pages)*<span class="number">100</span>)) </span><br><span class="line">       <span class="keyword">AS</span> change_buffer_page_percentage;</span><br><span class="line">+<span class="comment">---------------------+-------------+-------------------------------+</span></span><br><span class="line">| change_buffer_pages | total_pages | change_buffer_page_percentage |</span><br><span class="line">+<span class="comment">---------------------+-------------+-------------------------------+</span></span><br><span class="line">|                  25 |        8192 |                        0.3052 |</span><br><span class="line">+<span class="comment">---------------------+-------------+-------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>有关该<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-buffer-page-table.html" target="_blank" rel="noopener"><code>INNODB_BUFFER_PAGE</code></a>表提供的其他数据的信息 ，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-buffer-page-table.html" target="_blank" rel="noopener">第21.30.1节“ INFORMATION_SCHEMA INNODB_BUFFER_PAGE表”</a>。有关相关用法信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-information-schema-buffer-pool-tables.html" target="_blank" rel="noopener">第14.15.5节“ InnoDB INFORMATION_SCHEMA缓冲池表”</a>。</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.6/en/performance-schema.html" target="_blank" rel="noopener">Performance Schema</a> 提供了Change Buffer互斥锁等待工具，以进行高级性能监视。要查看Change Buffer检测，请发出以下查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM performance_schema.setup_instruments</span><br><span class="line">       WHERE NAME LIKE '%wait/synch/mutex/innodb/ibuf%';</span><br><span class="line">+<span class="comment">-------------------------------------------------------+---------+-------+</span></span><br><span class="line">| NAME                                                  | ENABLED | TIMED |</span><br><span class="line">+<span class="comment">-------------------------------------------------------+---------+-------+</span></span><br><span class="line">| wait/synch/mutex/innodb/ibuf_bitmap_mutex             | YES     | YES   |</span><br><span class="line">| wait/synch/mutex/innodb/ibuf_mutex                    | YES     | YES   |</span><br><span class="line">| wait/synch/mutex/innodb/ibuf_pessimistic_insert_mutex | YES     | YES   |</span><br><span class="line">+<span class="comment">-------------------------------------------------------+---------+-------+</span></span><br></pre></td></tr></table></figure>

<p>有关监视<code>InnoDB</code> 互斥锁等待的信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/monitor-innodb-mutex-waits-performance-schema.html" target="_blank" rel="noopener">第14.16.1节“使用性能模式监视InnoDB Mutex等待”</a>。</p>
</li>
</ul>
<br>

<h3 id="14-5-3自适应哈希索引"><a href="#14-5-3自适应哈希索引" class="headerlink" title="14.5.3自适应哈希索引"></a>14.5.3自适应哈希索引</h3><p>自适应哈希索引（innodb-adaptive-hash）功能可以<code>InnoDB</code> 在不牺牲事务功能或可靠性的情况下，在工作负载和缓冲池有足够内存的适当组合的系统上，更像是内存数据库。自适应哈希索引功能由<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_adaptive_hash_index" target="_blank" rel="noopener"><code>innodb_adaptive_hash_index</code></a> 变量启用 ，或在服务器启动时由禁用 <code>--skip-innodb-adaptive-hash-index</code>。</p>
<p>根据观察到的搜索模式，使用索引关键字的前缀构建哈希索引。该前缀可以是任何长度，并且可能是哈希树索引中仅B树中的某些值出现。哈希索引是根据对经常访问的索引页面的需求而建立的。</p>
<p>如果表几乎完全适合主内存，则散列索引可以通过启用直接查找任何元素的方式来加速查询，从而将索引值转换为某种指针。<code>InnoDB</code> 具有监视索引搜索的机制。如果 <code>InnoDB</code>发现查询可以从构建哈希索引中受益，它会自动这样做。</p>
<p>在某些工作负载下，哈希索引查找的速度大大超过了监视索引查找和维护哈希索引结构的额外工作。在繁重的工作负载（例如多个并发连接）下，访问自适应哈希索引有时可能会成为争用的源。与 <code>LIKE</code>运算符和<code>%</code> 通配符也往往不会受益。对于无法从自适应哈希索引功能中受益的工作负载，将其关闭可减少不必要的性能开销。由于很难预先预测自适应哈希索引功能是否适合特定的系统和工作负载，因此请考虑启用和禁用该功能的基准测试。与早期版本相比，MySQL 5.6中的体系结构更改使其更适合禁用自适应哈希索引功能。</p>
<p>您可以在输出<code>SEMAPHORES</code>部分中 监视自适应哈希索引的使用和争用 <a href="https://dev.mysql.com/doc/refman/5.6/en/show-engine.html" target="_blank" rel="noopener"><code>SHOW ENGINE INNODB STATUS</code></a>。如果在中创建的RW锁上有许多线程正在等待<code>btr0sea.c</code>，则禁用自适应哈希索引功能可能很有用。</p>
<p>有关哈希索引的性能特征的信息，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/index-btree-hash.html" target="_blank" rel="noopener">第8.3.8节“ B树和哈希索引的比较”</a>。</p>
<br>

<h3 id="14-5-4-Log-Buffer"><a href="#14-5-4-Log-Buffer" class="headerlink" title="14.5.4 Log Buffer"></a>14.5.4 Log Buffer</h3><p>日志缓冲区是存储区域，用于保存要写入磁盘上的日志文件的数据。日志缓冲区大小由<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_log_buffer_size" target="_blank" rel="noopener"><code>innodb_log_buffer_size</code></a>变量定义 。默认大小为16MB。日志缓冲区的内容会定期刷新到磁盘。较大的日志缓冲区使大型事务可以运行，而无需在事务提交之前将Redo Log数据写入磁盘。因此，如果您有更新，插入或删除许多行的事务，则增加日志缓冲区的大小可以节省磁盘I / O。</p>
<p>该 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_flush_log_at_trx_commit" target="_blank" rel="noopener"><code>innodb_flush_log_at_trx_commit</code></a> 变量控制如何将日志缓冲区的内容写入并刷新到磁盘。该 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_flush_log_at_timeout" target="_blank" rel="noopener"><code>innodb_flush_log_at_timeout</code></a> 变量控制日志刷新频率。</p>
<br>

<h2 id="14-6-InnoDB磁盘结构"><a href="#14-6-InnoDB磁盘结构" class="headerlink" title="14.6 InnoDB磁盘结构"></a>14.6 InnoDB磁盘结构</h2><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-tables.html" target="_blank" rel="noopener">14.6.1表格</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-indexes.html" target="_blank" rel="noopener">14.6.2索引</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-tablespace.html" target="_blank" rel="noopener">14.6.3表空间</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-data-dictionary.html" target="_blank" rel="noopener">14.6.4 InnoDB数据字典</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-doublewrite-buffer.html" target="_blank" rel="noopener">14.6.5Doublewrite Buffer</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-redo-log.html" target="_blank" rel="noopener">14.6.6Redo Log</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-undo-logs.html" target="_blank" rel="noopener">14.6.7Undo Log</a></li>
</ul>
<p>本节介绍<code>InnoDB</code>磁盘上的结构和相关主题。</p>
<br>

<h3 id="14-6-1-Tables"><a href="#14-6-1-Tables" class="headerlink" title="14.6.1 Tables"></a>14.6.1 Tables</h3><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/using-innodb-tables.html" target="_blank" rel="noopener">14.6.1.1创建InnoDB表</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-create-table-external.html" target="_blank" rel="noopener">14.6.1.2在外部创建表</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-table-import.html" target="_blank" rel="noopener">14.6.1.3导入InnoDB表</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-migration.html" target="_blank" rel="noopener">14.6.1.4移动或复制InnoDB表</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/converting-tables-to-innodb.html" target="_blank" rel="noopener">14.6.1.5将表从MyISAM转换为InnoDB</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-auto-increment-handling.html" target="_blank" rel="noopener">14.6.1.6 InnoDB中的AUTO_INCREMENT处理</a></li>
</ul>
<h4 id="14-6-1-1创建InnoDB表"><a href="#14-6-1-1创建InnoDB表" class="headerlink" title="14.6.1.1创建InnoDB表"></a>14.6.1.1创建InnoDB表</h4><p>要创建<code>InnoDB</code>表，请使用以下 <a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (a <span class="built_in">INT</span>, b <span class="built_in">CHAR</span> (<span class="number">20</span>), PRIMARY <span class="keyword">KEY</span> (a)) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>

<p>如果将<code>ENGINE=InnoDB</code> 子句<code>InnoDB</code>定义为默认存储引擎（默认情况下为默认引擎），则无需指定该子句。要检查默认存储引擎，请发出以下语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT @@default_storage_engine;</span><br><span class="line">+<span class="comment">--------------------------+</span></span><br><span class="line">| @@default_storage_engine |</span><br><span class="line">+<span class="comment">--------------------------+</span></span><br><span class="line">| InnoDB                   |</span><br><span class="line">+<span class="comment">--------------------------+</span></span><br></pre></td></tr></table></figure>

<p><code>ENGINE=InnoDB</code>如果计划使用<a href="https://dev.mysql.com/doc/refman/5.6/en/mysqldump.html" target="_blank" rel="noopener"><strong>mysqldump</strong></a>或复制<a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>在没有默认存储引擎的服务器上重播该语句， 则 可能仍使用子句<code>InnoDB</code>。</p>
<p>一个<code>InnoDB</code>表及其索引可以在创建<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_system_tablespace" target="_blank" rel="noopener">系统表空间</a>或在一个 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_file_per_table" target="_blank" rel="noopener">文件每个表的</a> 表空间。当 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a>启用，这是默认像MySQL 5.6.6的，一 <code>InnoDB</code>台是隐含在一个单独的文件，每个表的表空间中创建。相反，如果 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a>禁用此选项，则会<code>InnoDB</code>在<code>InnoDB</code>系统表空间中隐式创建表。</p>
<p>创建<code>InnoDB</code>表时，MySQL 在MySQL数据目录下的数据库目录中创建一个<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_frm_file" target="_blank" rel="noopener">.frm文件</a>。有关<code>.frm</code>文件的更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/using-innodb-tables.html#innodb-frm-file" target="_blank" rel="noopener">InnoDB表和.frm文件</a>。对于在每个表文件表空间中创建的表，默认情况下，MySQL还在数据库目录中创建一个 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_ibd_file" target="_blank" rel="noopener">.ibd</a>表空间文件。在 <code>InnoDB</code>系统表空间中创建的表在现有<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_ibd_file" target="_blank" rel="noopener">ibdata文件中</a>创建，该<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_ibd_file" target="_blank" rel="noopener">文件</a>位于MySQL数据目录中。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191203143854.png" alt></p>
<p>在内部，<code>InnoDB</code>将每个表的条目添加到<code>InnoDB</code>数据字典中。该条目包括数据库名称。例如，如果<code>t1</code>在<code>test</code> 数据库中创建了table ，则数据库名称的数据字典条目为 <code>&#39;test/t1&#39;</code>。这意味着您可以<code>t1</code>在不同的数据库中创建一个具有相同名称（）的表，并且该表名不会在内部冲突<code>InnoDB</code>。</p>
<h5 id="InnoDB表和-frm文件"><a href="#InnoDB表和-frm文件" class="headerlink" title="InnoDB表和.frm文件"></a>InnoDB表和.frm文件</h5><p>MySQL将表的数据字典信息<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_frm_file" target="_blank" rel="noopener">存储</a>在数据库目录中的 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_frm_file" target="_blank" rel="noopener">.frm文件</a>中。与其他MySQL存储引擎不同， <code>InnoDB</code>它还在系统表空间内的自身内部数据字典中编码有关表的信息。MySQL删除表或数据库时，将删除一个或多个<code>.frm</code>文件以及<code>InnoDB</code>数据字典中的相应条目。您不能<code>InnoDB</code>仅通过移动<code>.frm</code> 文件来在数据库之间移动表。有关移动<code>InnoDB</code> 表的信息，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-migration.html" target="_blank" rel="noopener">第14.6.1.4节“移动或复制InnoDB表”</a>。</p>
<h5 id="InnoDB表和行格式"><a href="#InnoDB表和行格式" class="headerlink" title="InnoDB表和行格式"></a>InnoDB表和行格式</h5><p>默认的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_row_format" target="_blank" rel="noopener">行格式</a>的的<code>InnoDB</code>表 <code>Compact</code>。尽管此行格式适合基本实验，但请考虑使用 <code>Dynamic</code> or <code>Compressed</code> 格式来利用<code>InnoDB</code> 诸如表压缩和长列值的有效页外存储等功能。使用这些行格式要求将<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a>其启用（MySQL 5.6.6中的默认值），并将其 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_format" target="_blank" rel="noopener"><code>innodb_file_format</code></a>设置为 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_barracuda" target="_blank" rel="noopener">Barracuda</a>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> innodb_file_per_table=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> innodb_file_format=barracuda;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t3 (a <span class="built_in">INT</span>, b <span class="built_in">CHAR</span> (<span class="number">20</span>), PRIMARY <span class="keyword">KEY</span> (a)) ROW_FORMAT=DYNAMIC;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t4 (a <span class="built_in">INT</span>, b <span class="built_in">CHAR</span> (<span class="number">20</span>), PRIMARY <span class="keyword">KEY</span> (a)) ROW_FORMAT=COMPRESSED;</span><br></pre></td></tr></table></figure>

<p>有关<code>InnoDB</code>行格式的更多信息，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-row-format.html" target="_blank" rel="noopener">第14.11节“ InnoDB行格式”</a>。有关如何确定<code>InnoDB</code>表的行格式以及行格式的物理特性的信息<code>InnoDB</code> ，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-row-format.html" target="_blank" rel="noopener">第14.11节“ InnoDB行格式”</a>。</p>
<h5 id="InnoDB表和主键"><a href="#InnoDB表和主键" class="headerlink" title="InnoDB表和主键"></a>InnoDB表和主键</h5><p>始终为表定义一个<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_primary_key" target="_blank" rel="noopener">主键</a><code>InnoDB</code>，并指定一个或多个满足以下条件的列：</p>
<ul>
<li>被最重要的查询引用。</li>
<li>永远不会空白。</li>
<li>永远不要有重复的值。</li>
<li>一旦插入，就很少更改值。</li>
</ul>
<p>例如，在包含有关人员的信息的表中，您不会在其上创建主键，<code>(firstname, lastname)</code>因为一个以上的人员可以具有相同的名称，某些人员的姓氏为空白，有时人们会更改其名称。有这么多的约束，通常没有明显的列集可以用作主键，因此您需要创建一个新的具有数字ID的列，以用作全部或部分主键。您可以声明一个 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_auto_increment" target="_blank" rel="noopener">自动增量</a>列，以便在插入行时自动填写升序值：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The value of ID can act like a pointer between related items in different tables.</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t5 (<span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT, b <span class="built_in">CHAR</span> (<span class="number">20</span>), PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment"># The primary key can consist of more than one column. Any autoinc column must come first.</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t6 (<span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT, a <span class="built_in">INT</span>, b <span class="built_in">CHAR</span> (<span class="number">20</span>), PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>,a));</span><br></pre></td></tr></table></figure>

<p>尽管在没有定义主键的情况下表可以正常工作，但是主键涉及性能的许多方面，并且对于任何大型或经常使用的表都是至关重要的设计方面。建议您始终在<a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a> 语句中指定主键。如果创建表，加载数据，然后稍后运行 <a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>以添加主键，则该操作比创建表时定义主键要慢得多。</p>
<h5 id="查看InnoDB表属性"><a href="#查看InnoDB表属性" class="headerlink" title="查看InnoDB表属性"></a>查看InnoDB表属性</h5><p>要查看<code>InnoDB</code>表的属性，请发出一条<a href="https://dev.mysql.com/doc/refman/5.6/en/show-table-status.html" target="_blank" rel="noopener"><code>SHOW TABLE STATUS</code></a> 语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW TABLE STATUS FROM test LIKE 't%' \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           Name: t1</span><br><span class="line">         Engine: InnoDB</span><br><span class="line">        Version: 10</span><br><span class="line">     Row_format: Compact</span><br><span class="line">           Rows: 0</span><br><span class="line"> Avg_row_length: 0</span><br><span class="line">    Data_length: 16384</span><br><span class="line">Max_data_length: 0</span><br><span class="line">   Index_length: 0</span><br><span class="line">      Data_free: 0</span><br><span class="line"> Auto_increment: NULL</span><br><span class="line">    Create_time: 2015-03-16 16:26:52</span><br><span class="line">    Update_time: NULL</span><br><span class="line">     Check_time: NULL</span><br><span class="line">      Collation: latin1_swedish_ci</span><br><span class="line">       <span class="keyword">Checksum</span>: <span class="literal">NULL</span></span><br><span class="line"> Create_options:</span><br><span class="line">        <span class="keyword">Comment</span>:</span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>有关<a href="https://dev.mysql.com/doc/refman/5.6/en/show-table-status.html" target="_blank" rel="noopener"><code>SHOW TABLE STATUS</code></a>输出的信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/show-table-status.html" target="_blank" rel="noopener">第13.7.5.37节“ SHOW TABLE STATUS语句”</a>。</p>
<p><code>InnoDB</code>还可以使用<code>InnoDB</code>Information Schema系统表查询表属性：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_TABLES WHERE NAME='test/t1' \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">     TABLE_ID: 42</span><br><span class="line">         NAME: test/t1</span><br><span class="line">         FLAG: 1</span><br><span class="line">       N_COLS: 5</span><br><span class="line">        SPACE: 24</span><br><span class="line">  FILE_FORMAT: Antelope</span><br><span class="line">   ROW_FORMAT: Compact</span><br><span class="line">ZIP_PAGE_SIZE: 0</span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure>

<p>有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-information-schema-system-tables.html" target="_blank" rel="noopener">第14.15.3节“ InnoDB INFORMATION_SCHEMA系统表”</a>。</p>
<br>

<h4 id="14-6-1-5将表从MyISAM转换为InnoDB"><a href="#14-6-1-5将表从MyISAM转换为InnoDB" class="headerlink" title="14.6.1.5将表从MyISAM转换为InnoDB"></a>14.6.1.5将表从MyISAM转换为InnoDB</h4><p>如果您具有<a href="https://dev.mysql.com/doc/refman/5.6/en/myisam-storage-engine.html" target="_blank" rel="noopener"><code>MyISAM</code></a>要转换<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-storage-engine.html" target="_blank" rel="noopener"><code>InnoDB</code></a>为更好的可靠性和可伸缩性的表，请在转换之前查看以下准则和提示。</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/converting-tables-to-innodb.html#innodb-convert-memory-usage" target="_blank" rel="noopener">调整MyISAM和InnoDB的内存使用量</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/converting-tables-to-innodb.html#innodb-convert-transactions" target="_blank" rel="noopener">处理太长或太短的交易</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/converting-tables-to-innodb.html#innodb-convert-deadlock" target="_blank" rel="noopener">处理死锁</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/converting-tables-to-innodb.html#innodb-convert-plan-storage" target="_blank" rel="noopener">规划存储布局</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/converting-tables-to-innodb.html#innodb-convert-convert" target="_blank" rel="noopener">转换现有表</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/converting-tables-to-innodb.html#innodb-convert-clone" target="_blank" rel="noopener">克隆表的结构</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/converting-tables-to-innodb.html#innodb-convert-transfer" target="_blank" rel="noopener">传输现有数据</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/converting-tables-to-innodb.html#innodb-convert-storage-requirements" target="_blank" rel="noopener">储存要求</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/converting-tables-to-innodb.html#innodb-convert-primary-key" target="_blank" rel="noopener">为每个表定义一个主键</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/converting-tables-to-innodb.html#innodb-convert-application-performance" target="_blank" rel="noopener">应用程序性能注意事项</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/converting-tables-to-innodb.html#innodb-convert-understand-files" target="_blank" rel="noopener">了解与InnoDB表关联的文件</a></li>
</ul>
<h5 id="调整MyISAM和InnoDB的内存使用量"><a href="#调整MyISAM和InnoDB的内存使用量" class="headerlink" title="调整MyISAM和InnoDB的内存使用量"></a>调整MyISAM和InnoDB的内存使用量</h5><p>从<code>MyISAM</code>表过渡时，降低<a href="https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_key_buffer_size" target="_blank" rel="noopener"><code>key_buffer_size</code></a>配置选项的值 以释放缓存结果不再需要的内存。增加<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_buffer_pool_size" target="_blank" rel="noopener"><code>innodb_buffer_pool_size</code></a> 配置选项的值，该 选项执行与为<code>InnoDB</code>表分配缓存内存类似的作用。该 <code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_buffer_pool" target="_blank" rel="noopener">缓冲池</a>可以缓存表数据和索引数据，加快了查询，查找并保持查询结果在内存中进行再利用。有关缓冲池大小配置的指导，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/memory-use.html" target="_blank" rel="noopener">第8.12.4.1节“ MySQL如何使用内存”</a>。</p>
<p>在繁忙的服务器上，在关闭查询缓存的情况下运行基准测试。该<code>InnoDB</code>缓冲池提供类似的好处，所以查询缓存可能会不必要地占用内存。有关查询缓存的信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/query-cache.html" target="_blank" rel="noopener">第8.10.3节“ MySQL查询缓存”</a>。</p>
<h5 id="处理太长或太短的交易"><a href="#处理太长或太短的交易" class="headerlink" title="处理太长或太短的交易"></a>处理太长或太短的交易</h5><p>因为<code>MyISAM</code>表不支持 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_transaction" target="_blank" rel="noopener">事务</a>，所以您可能没有过多注意 <a href="https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_autocommit" target="_blank" rel="noopener"><code>autocommit</code></a>配置选项和<a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a>and <a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>ROLLBACK</code></a> 语句。这些关键字对于允许多个会话同时读取和写入<code>InnoDB</code>表很重要，从而在写繁重的工作负载中提供了可伸缩性的实质好处。</p>
<p>当事务打开时，系统会保留数据快照，如在事务开始时看到的那样，如果系统在杂散事务保持运行的同时插入，更新和删除数百万行，则可能导致大量开销。因此，请注意避免事务运行时间过长：</p>
<ul>
<li>如果您正在使用<a href="https://dev.mysql.com/doc/refman/5.6/en/mysql.html" target="_blank" rel="noopener"><strong>mysql</strong></a>会话进行交互式实验，请务必 <a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a>在完成时（完成更改）或 <a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>ROLLBACK</code></a>（撤消更改）。关闭交互式会话，而不要长时间打开它们，以免意外使事务长时间打开。</li>
<li>确保您的应用程序中的任何错误处理程序也未 <a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>ROLLBACK</code></a> 完成更改或<a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a> 已完成更改。</li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>ROLLBACK</code></a>这是一个相对昂贵的操作，因为 <a href="https://dev.mysql.com/doc/refman/5.6/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>， <a href="https://dev.mysql.com/doc/refman/5.6/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.6/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>操作会写入到<code>InnoDB</code>之前的表中 <a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a>，并期望大多数更改都能成功提交，并且很少进行回滚。试验大量数据时，请避免对大量行进行更改，然后回滚这些更改。</li>
<li>当使用一系列<a href="https://dev.mysql.com/doc/refman/5.6/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>语句加载大量数据时 ，请定期 <a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a>执行结果以避免事务持续数小时。在数据仓库的典型加载操作中，如果出现问题，请截断表（使用<a href="https://dev.mysql.com/doc/refman/5.6/en/truncate-table.html" target="_blank" rel="noopener"><code>TRUNCATE TABLE</code></a>），然后从头开始，而不是执行操作 <a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>ROLLBACK</code></a>。</li>
</ul>
<p>前面的技巧可以节省在过长的事务中可能浪费的内存和磁盘空间。当事务短于应有的时间时，问题就在于过多的I / O。对于每个 <a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a>，MySQL确保将每个更改安全地记录到磁盘上，其中涉及一些I / O。</p>
<ul>
<li>对于<code>InnoDB</code>表格的大多数操作，应使用设置 <a href="https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_autocommit" target="_blank" rel="noopener"><code>autocommit=0</code></a>。从效率的角度看，这样就避免了在发出大量连续的不必要的I / O <a href="https://dev.mysql.com/doc/refman/5.6/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>， <a href="https://dev.mysql.com/doc/refman/5.6/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>或 <a href="https://dev.mysql.com/doc/refman/5.6/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>语句。从安全角度来看，<a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>ROLLBACK</code></a> 如果您在<a href="https://dev.mysql.com/doc/refman/5.6/en/mysql.html" target="_blank" rel="noopener"><strong>mysql</strong></a>命令行或应用程序中的异常处理程序中出错，则允许您发布 语句以恢复丢失或乱码的数据。</li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_autocommit" target="_blank" rel="noopener"><code>autocommit=1</code></a>适用于<code>InnoDB</code>表 的时间是运行一系列查询以生成报告或分析统计信息时。在这种情况下，不会存在与<a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a>或 相关的I / O损失<a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>ROLLBACK</code></a>，并且<code>InnoDB</code>可以 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-performance-ro-txn.html" target="_blank" rel="noopener">自动优化只读工作负载</a>。</li>
<li>如果进行了一系列相关更改，请一次完成所有更改，最后一次 <a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a>完成。例如，如果您将相关的信息插入到多个表中，请<a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a> 在进行所有更改后执行一次。或者，如果您运行许多连续的 <a href="https://dev.mysql.com/doc/refman/5.6/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>语句，则<a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a>在加载所有数据之后执行一次 ；如果您要执行数百万条 <a href="https://dev.mysql.com/doc/refman/5.6/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>语句，则可能通过发出<a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a>每万或十万条记录来拆分庞大的事务 ，因此事务不会增长得太大。</li>
<li>请记住，即使是一条<a href="https://dev.mysql.com/doc/refman/5.6/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a> 语句也会打开一个事务，因此在交互式<a href="https://dev.mysql.com/doc/refman/5.6/en/mysql.html" target="_blank" rel="noopener"><strong>mysql</strong></a> 会话中运行某些报表或调试查询后，请发出a <a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a> 或关闭<a href="https://dev.mysql.com/doc/refman/5.6/en/mysql.html" target="_blank" rel="noopener"><strong>mysql</strong></a>会话。</li>
</ul>
<h5 id="处理死锁"><a href="#处理死锁" class="headerlink" title="处理死锁"></a>处理死锁</h5><p>您可能会在MySQL错误日志中看到警告消息，该警告消息涉及 “ 死锁 ”或的输出 <a href="https://dev.mysql.com/doc/refman/5.6/en/show-engine.html" target="_blank" rel="noopener"><code>SHOW ENGINE INNODB STATUS</code></a>。尽管名称听起来很吓人，但是 对于表来说，<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_deadlock" target="_blank" rel="noopener">死锁</a>并不是一个严重的问题<code>InnoDB</code>，并且通常不需要采取任何纠正措施。当两个事务开始修改多个表时，以不同的顺序访问表时，它们可以达到每个事务都在等待另一个的状态，而任何一个都不能继续进行。MySQL立即检测到这种情况并取消（<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_rollback" target="_blank" rel="noopener">回滚</a>）“ 较小 ”的事务，从而允许其他事务继续进行。</p>
<p>您的应用程序确实需要错误处理逻辑来重新启动像这样被强制取消的事务。当您重新发出与以前相同的SQL语句时，原始的计时问题不再适用。另一笔交易已经完成，您可以继续进行，或者另一笔交易仍在进行中，您的交易会等到完成为止。</p>
<p>如果不断发生死锁警告，则可以检查应用程序代码以一致的方式对SQL操作进行重新排序，或缩短事务。您可以在<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_print_all_deadlocks" target="_blank" rel="noopener"><code>innodb_print_all_deadlocks</code></a>启用该选项的情况下进行测试， 以查看MySQL错误日志中的所有死锁警告，而不仅仅是<a href="https://dev.mysql.com/doc/refman/5.6/en/show-engine.html" target="_blank" rel="noopener"><code>SHOW ENGINE INNODB STATUS</code></a>输出中的最后一个警告 。</p>
<p>有关更多信息，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-deadlocks.html" target="_blank" rel="noopener">第14.7.5节“ InnoDB中的死锁”</a>。</p>
<h5 id="规划存储布局"><a href="#规划存储布局" class="headerlink" title="规划存储布局"></a>规划存储布局</h5><p>为了从<code>InnoDB</code>表中获得最佳性能，您可以调整许多与存储布局相关的参数。</p>
<p>当您将<code>MyISAM</code>是大的，经常访问的，并保持至关重要的数据表，调查和考虑<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a>， <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_format" target="_blank" rel="noopener"><code>innodb_file_format</code></a>以及 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_page_size" target="_blank" rel="noopener"><code>innodb_page_size</code></a>配置选项，以及 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-row-format.html" target="_blank" rel="noopener"><code>ROW_FORMAT</code> 和<code>KEY_BLOCK_SIZE</code>条款</a>中的 <a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>说法。</p>
<p>在初始实验期间，最重要的设置是 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a>。启用此设置后，这是MySQL 5.6.6中的默认设置，新 <code>InnoDB</code>表将在<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_file_per_table" target="_blank" rel="noopener">每表文件表</a> 空间中隐式创建 。与<code>InnoDB</code>系统表空间相比，每表文件表空间允许在表被截断或删除时由操作系统回收磁盘空间。每表文件表空间还支持 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_barracuda" target="_blank" rel="noopener">梭子鱼</a>文件格式和相关功能，例如表压缩，长变长列的有效页外存储和大索引前缀。有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-file-per-table-tablespaces.html" target="_blank" rel="noopener">第14.6.3.2节“每表文件表空间”</a>。</p>
<h5 id="转换现有表"><a href="#转换现有表" class="headerlink" title="转换现有表"></a>转换现有表</h5><p>要将非<code>InnoDB</code>表转换为使用，请 <code>InnoDB</code>使用<a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>

<p>警告</p>
<p>不要<em>不</em>转换在MySQL系统表 <code>mysql</code>从数据库<code>MyISAM</code> 到<code>InnoDB</code>表。这是不受支持的操作。如果这样做，MySQL将不会重新启动，直到您从备份中还原旧的系统表或通过重新初始化数据目录来重新生成它们（请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/data-directory-initialization.html" target="_blank" rel="noopener">第2.10.1节“初始化数据目录”</a>）。</p>
<h5 id="克隆表的结构"><a href="#克隆表的结构" class="headerlink" title="克隆表的结构"></a>克隆表的结构</h5><p>您可以制作一个<code>InnoDB</code>表，该表是MyISAM表的克隆，而不是<a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>用来执行转换，以便在切换之前并排测试新旧表。</p>
<p>创建<code>InnoDB</code>具有相同的列和索引定义的空表。使用看到完整的 语句来使用。将子句更改为 。 <code>SHOW CREATE TABLE *</code>table_name<code>*\G</code><a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a><code>ENGINE``ENGINE=INNODB</code></p>
<h5 id="传输现有数据"><a href="#传输现有数据" class="headerlink" title="传输现有数据"></a>传输现有数据</h5><p>要将大量数据传输到<code>InnoDB</code>上一节中创建的空 表中，请使用插入行。 <code>INSERT INTO *</code>innodb_table<code>* SELECT * FROM *</code>myisam_table<code>* ORDER BY *</code>primary_key_columns<code>*</code></p>
<p>您还可以<code>InnoDB</code> 在插入数据后为表创建索引。从历史上看，创建新的二级索引对于InnoDB而言是一项缓慢的操作，但是现在您可以在索引创建步骤中以相对较少的开销加载数据之后创建索引。</p>
<p>如果您<code>UNIQUE</code>对辅助键有限制，则可以通过在导入操作期间暂时关闭唯一性检查来加快表的导入：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> unique_checks=<span class="number">0</span>;... import operation ...</span><br><span class="line"><span class="keyword">SET</span> unique_checks=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>对于大表，这可以节省磁盘I / O，因为 <code>InnoDB</code>可以使用其 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_change_buffer" target="_blank" rel="noopener">Change Buffer</a>将辅助索引记录批量写入。确保数据不包含重复的密钥。 <a href="https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_unique_checks" target="_blank" rel="noopener"><code>unique_checks</code></a>允许但不要求存储引擎忽略重复的密钥。</p>
<p>为了更好地控制插入过程，您可以分段插入大表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> newtable <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> oldtable</span><br><span class="line">   <span class="keyword">WHERE</span> yourkey &gt; something <span class="keyword">AND</span> yourkey &lt;= somethingelse;</span><br></pre></td></tr></table></figure>

<p>插入所有记录后，您可以重命名表。</p>
<p>在大表转换期间，增加<code>InnoDB</code>缓冲池的大小 以减少磁盘I / O，最多可占物理内存的80％。您还可以增加<code>InnoDB</code>日志文件的大小。</p>
<h5 id="储存要求"><a href="#储存要求" class="headerlink" title="储存要求"></a>储存要求</h5><p>如果打算<code>InnoDB</code>在转换过程中为表中的数据制作几个临时副本， 建议您在每个表文件表空间中创建表，以便在删除表时可以回收磁盘空间。当 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a> 配置选项启用（默认），新创建的 <code>InnoDB</code>表在文件的每个表的表空间隐式创建。</p>
<p>无论您是<code>MyISAM</code>直接转换表还是创建克隆<code>InnoDB</code>表，请确保在此过程中有足够的磁盘空间来容纳旧表和新表。 <strong><code>InnoDB</code>表比<code>MyISAM</code>表需要更多的磁盘空间。</strong> 如果<a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>操作空间不足，则会启动回滚，如果它是磁盘绑定的，则可能要花费数小时。对于插入，<code>InnoDB</code>使用插入缓冲区将二级索引记录合并到批索引中。这样可以节省大量的磁盘I / O。对于回滚，不使用这种机制，回滚所花费的时间可能比插入时间长30倍。</p>
<p>对于失控的回滚，如果数据库中没有有价值的数据，建议您终止数据库进程，而不要等待数百万的磁盘I / O操作完成。有关完整过程，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/forcing-innodb-recovery.html" target="_blank" rel="noopener">第14.21.2节“强制InnoDB恢复”</a>。</p>
<h5 id="为每个表定义一个主键"><a href="#为每个表定义一个主键" class="headerlink" title="为每个表定义一个主键"></a>为每个表定义一个主键</h5><p>该<code>PRIMARY KEY</code>子句是影响MySQL查询性能以及表和索引空间使用的关键因素。主键唯一地标识表中的一行。表中的每一行都必须具有主键值，并且任何两行都不能具有相同的主键值。</p>
<p>这些是主键的指南，后面有更详细的说明。</p>
<ul>
<li><code>PRIMARY KEY</code>为每个表 声明一个。通常，它是<code>WHERE</code>查找单行时在子句中引用的最重要的列。</li>
<li><code>PRIMARY KEY</code>在原始<a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a> 语句中 声明该子句，而不是稍后通过一条<a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>语句添加它 。</li>
<li>仔细选择列及其数据类型。数字列优先于字符列或字符串列。</li>
<li>如果没有其他稳定，唯一，非空的数字列要使用，请考虑使用自动递增列。</li>
<li>如果不确定主键列的值是否可以更改，则自动增量列也是一个不错的选择。更改主键列的值是一项昂贵的操作，可能涉及重新排列表内和每个二级索引内的数据。</li>
</ul>
<p>考虑将<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_primary_key" target="_blank" rel="noopener">主键</a>添加到尚无<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_primary_key" target="_blank" rel="noopener">主键</a>的任何表中。根据表的最大投影尺寸使用最小的实用数字类型。这可以使每行稍微紧凑一些，从而可以为大型表节省大量空间。如果表具有任何<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_secondary_index" target="_blank" rel="noopener">二级索引</a>，则节省的空间将成倍增加 ，因为在每个二级索引条目中都会重复主键值。除了减小磁盘上的数据大小之外，小的主键还使更多数据适合 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_buffer_pool" target="_blank" rel="noopener">缓冲池</a>，从而加快了各种操作并提高了并发性。</p>
<p>如果表在某个较长的列（例如）上已经具有主键<code>VARCHAR</code>，请考虑添加一个新的无符号 <code>AUTO_INCREMENT</code>列，并将主键切换到该列，即使查询中未引用该列。这种设计更改可以在二级索引中节省大量空间。您可以将以前的主键列指定为<code>UNIQUE NOT NULL</code>强制执行与<code>PRIMARY KEY</code>子句相同的约束，即防止所有这些列之间出现重复或空值。</p>
<p>如果将相关信息分布在多个表中，则通常每个表的主键使用同一列。例如，人员数据库可能有几个表，每个表都有员工编号的主键。一个销售数据库可能有一些带有客户编号主键的表，而另一些带有订单编号主键的表。因为使用主键的查找非常快，所以您可以为此类表构造有效的联接查询。</p>
<p>如果您<code>PRIMARY KEY</code>完全忽略该子句，MySQL会为您创建一个不可见的子句。它是一个6字节的值，可能比您需要的时间更长，因此浪费了空间。因为它是隐藏的，所以您不能在查询中引用它。</p>
<h5 id="应用程序性能注意事项"><a href="#应用程序性能注意事项" class="headerlink" title="应用程序性能注意事项"></a>应用程序性能注意事项</h5><p>与<code>InnoDB</code>等效<code>MyISAM</code>表相比，的可靠性和可伸缩性功能 需要更多的磁盘存储。您可能会略微更改列和索引的定义，以提高空间利用率，减少处理结果集时的I / O和内存消耗，以及更好地利用索引查找来实现更好的查询优化计划。</p>
<p>如果确实为主键设置了数字ID列，请使用该值与任何其他表中的相关值进行交叉引用，尤其是对于<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_join" target="_blank" rel="noopener">联接</a>查询。例如，与其接受一个国家名称作为输入并进行查询来搜索相同的名称，不如进行一次查找以确定国家ID，然后进行其他查询（或单个联接查询）以在多个表中查找相关信息。与其将客户或商品目录号存储为一串数字（可能会用完几个字节），不如将其转换为数字ID以进行存储和查询。4字节无符号 <a href="https://dev.mysql.com/doc/refman/5.6/en/integer-types.html" target="_blank" rel="noopener"><code>INT</code></a>列可以索引超过40亿个项目（美国的含义是十亿：十亿）。有关不同整数类型的范围，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/integer-types.html" target="_blank" rel="noopener">第11.2.1节“整数类型（精确值）-INTEGER，INT，SMALLINT，TINYINT，MEDIUMINT，BIGINT”</a>。</p>
<h5 id="了解与InnoDB表关联的文件"><a href="#了解与InnoDB表关联的文件" class="headerlink" title="了解与InnoDB表关联的文件"></a>了解与InnoDB表关联的文件</h5><p><code>InnoDB</code>文件比文件需要更多的照顾和计划<code>MyISAM</code>。</p>
<ul>
<li>您不得删除代表<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_system_tablespace" target="_blank" rel="noopener">系统表空间</a>的 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_ibdata_file" target="_blank" rel="noopener">ibdata文件</a>。 <code>InnoDB</code></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-migration.html" target="_blank" rel="noopener">第14.6.1.4节“移动或复制InnoDB表”</a><code>InnoDB</code>中介绍了 将表移动或复制到其他服务器的方法 。</li>
</ul>
<br>

<h3 id="14-6-2-Index"><a href="#14-6-2-Index" class="headerlink" title="14.6.2 Index"></a>14.6.2 Index</h3><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-index-types.html" target="_blank" rel="noopener">14.6.2.1聚集索引和二级索引</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-physical-structure.html" target="_blank" rel="noopener">14.6.2.2 InnoDB索引的物理结构</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-fulltext-index.html" target="_blank" rel="noopener">14.6.2.3 InnoDB全文索引</a></li>
</ul>
<p>本节涵盖与<code>InnoDB</code> 索引有关的主题。</p>
<h4 id="14-6-2-1聚集索引和二级索引"><a href="#14-6-2-1聚集索引和二级索引" class="headerlink" title="14.6.2.1聚集索引和二级索引"></a>14.6.2.1聚集索引和二级索引</h4><p>每个<code>InnoDB</code>表都有一个特殊的索引，称为<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_clustered_index" target="_blank" rel="noopener">聚簇索引</a> ，用于存储行数据。通常，聚簇索引与<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_primary_key" target="_blank" rel="noopener">主键</a>同义 。为了从查询，插入和其他数据库操作中获得最佳性能，您必须了解如何<code>InnoDB</code>使用聚簇索引为每个表优化最常见的查找和DML操作。</p>
<ul>
<li>在<code>PRIMARY KEY</code>表上定义a 时，<code>InnoDB</code>将其用作聚簇索引。为您创建的每个表定义一个主键。如果没有逻辑唯一且非空的列或列集，请添加一个新的 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_auto_increment" target="_blank" rel="noopener">自动递增</a> 列，其值将自动填充。</li>
<li>如果您没有<code>PRIMARY KEY</code>为表定义，MySQL会<code>UNIQUE</code>在所有键列所在的位置找到第一个索引，<code>NOT NULL</code>并将 <code>InnoDB</code>其用作聚集索引。</li>
<li>如果表没有索引<code>PRIMARY KEY</code>或没有合适的 <code>UNIQUE</code>索引，则在<code>InnoDB</code> 内部生成一个隐藏的聚集索引<code>GEN_CLUST_INDEX</code>，该索引在包含行ID值的合成列上命名 。这些行由<code>InnoDB</code>分配给该表中各行的ID排序 。行ID是一个6字节的字段，随着插入新行而单调增加。因此，按行ID排序的行实际上在插入顺序上。</li>
</ul>
<h5 id="聚集索引如何加快查询"><a href="#聚集索引如何加快查询" class="headerlink" title="聚集索引如何加快查询"></a>聚集索引如何加快查询</h5><p>通过聚集索引访问行是快速的，因为索引搜索直接导致包含所有行数据的页面。如果表很大，则与使用不同于索引记录的页面存储行数据的存储组织相比，聚集索引体系结构通常可以节省磁盘I / O操作。</p>
<h5 id="二级索引如何与聚簇索引相关"><a href="#二级索引如何与聚簇索引相关" class="headerlink" title="二级索引如何与聚簇索引相关"></a>二级索引如何与聚簇索引相关</h5><p>除聚集索引之外的所有索引都称为 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_secondary_index" target="_blank" rel="noopener">辅助索引</a>。在中<code>InnoDB</code>，辅助索引中的每个记录都包含该行的主键列以及为辅助索引指定的列。 <code>InnoDB</code>使用此主键值在聚集索引中搜索行。</p>
<p><code>如果主键较长，则辅助索引将使用更多空间，因此具有短的主键是有利的。</code></p>
<p>有关利用<code>InnoDB</code> 聚簇索引和二级索引的准则，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/optimization-indexes.html" target="_blank" rel="noopener">第8.3节“优化和索引”</a>。</p>
<h4 id="14-6-2-2-InnoDB索引的物理结构"><a href="#14-6-2-2-InnoDB索引的物理结构" class="headerlink" title="14.6.2.2 InnoDB索引的物理结构"></a>14.6.2.2 InnoDB索引的物理结构</h4><p>所有<code>InnoDB</code>索引都是 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_b_tree" target="_blank" rel="noopener">B树</a>，索引记录存储在树的叶子页中。索引页的默认大小为16KB。</p>
<p>将新记录插入<code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_clustered_index" target="_blank" rel="noopener">聚集索引时</a>，请 <code>InnoDB</code>尝试使页面的1/16空闲，以备将来插入和更新索引记录。如果按顺序插入索引记录（升序或降序），则所得到的索引页大约为15/16。如果以随机顺序插入记录，则页面将充满1/2到15/16。如果索引页面的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_fill_factor" target="_blank" rel="noopener">填充因子</a>下降到1/2以下，请 <code>InnoDB</code>尝试收缩索引树以释放页面。</p>
<p>您可以通过 在初始化MySQL实例之前设置配置选项来定义MySQL实例中 所有表空间的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_page_size" target="_blank" rel="noopener">页面大小</a>。定义实例的页面大小后，如果不重新初始化实例就无法更改它。支持的大小为16KB，8KB和4KB。 <code>InnoDB</code><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_page_size" target="_blank" rel="noopener"><code>innodb_page_size</code></a></p>
<p>使用特定<code>InnoDB</code>页面大小的MySQL实例不能使用来自使用不同页面大小的实例的数据文件或日志文件。</p>
<h4 id="14-6-2-3-InnoDB全文索引"><a href="#14-6-2-3-InnoDB全文索引" class="headerlink" title="14.6.2.3 InnoDB全文索引"></a>14.6.2.3 InnoDB全文索引</h4><p><code>FULLTEXT</code>索引是在基于文本的列（<a href="https://dev.mysql.com/doc/refman/5.6/en/char.html" target="_blank" rel="noopener"><code>CHAR</code></a>， <a href="https://dev.mysql.com/doc/refman/5.6/en/char.html" target="_blank" rel="noopener"><code>VARCHAR</code></a>或<a href="https://dev.mysql.com/doc/refman/5.6/en/blob.html" target="_blank" rel="noopener"><code>TEXT</code></a>列）上创建的， 以帮助加快对这些列中包含的数据的查询和DML操作，而忽略定义为停用词的任何单词。</p>
<p>甲<code>FULLTEXT</code>指数被定义为一个的一部分 <a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>说明或使用添加到现有的表<a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a> 或<a href="https://dev.mysql.com/doc/refman/5.6/en/create-index.html" target="_blank" rel="noopener"><code>CREATE INDEX</code></a>。</p>
<p>使用<a href="https://dev.mysql.com/doc/refman/5.6/en/fulltext-search.html#function_match" target="_blank" rel="noopener"><code>MATCH() ... AGAINST</code></a>语法执行全文搜索。有关用法信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/fulltext-search.html" target="_blank" rel="noopener">第12.9节“全文搜索功能”</a>。</p>
<p><code>InnoDB</code> <code>FULLTEXT</code> 本节中的以下主题描述了索引：</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-fulltext-index.html#innodb-fulltext-index-design" target="_blank" rel="noopener">InnoDB全文索引设计</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-fulltext-index.html#innodb-fulltext-index-tables" target="_blank" rel="noopener">InnoDB全文索引表</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-fulltext-index.html#innodb-fulltext-index-cache" target="_blank" rel="noopener">InnoDB全文索引缓存</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-fulltext-index.html#innodb-fulltext-index-docid" target="_blank" rel="noopener">InnoDB全文索引文档ID和FTS_DOC_ID列</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-fulltext-index.html#innodb-fulltext-index-deletion" target="_blank" rel="noopener">InnoDB全文索引删除处理</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-fulltext-index.html#innodb-fulltext-index-transaction" target="_blank" rel="noopener">InnoDB全文索引事务处理</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-fulltext-index.html#innodb-fulltext-index-monitoring" target="_blank" rel="noopener">监控InnoDB全文索引</a></li>
</ul>
<h5 id="InnoDB全文索引设计"><a href="#InnoDB全文索引设计" class="headerlink" title="InnoDB全文索引设计"></a>InnoDB全文索引设计</h5><p><code>InnoDB</code> <code>FULLTEXT</code>索引具有倒排索引设计。倒排索引存储一个单词列表，对于每个单词，存储该单词出现的文档列表。为了支持邻近搜索，每个单词的位置信息也作为字节偏移量存储。</p>
<h5 id="InnoDB全文索引表"><a href="#InnoDB全文索引表" class="headerlink" title="InnoDB全文索引表"></a>InnoDB全文索引表</h5><p>创建<code>InnoDB</code> <code>FULLTEXT</code>索引时，将创建一组索引表，如以下示例所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE opening_lines (</span><br><span class="line">       id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,</span><br><span class="line">       opening_line TEXT(500),</span><br><span class="line">       author VARCHAR(200),</span><br><span class="line">       title VARCHAR(200),</span><br><span class="line">       FULLTEXT idx (opening_line)</span><br><span class="line">       ) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT table_id, name, space from INFORMATION_SCHEMA.INNODB_SYS_TABLES</span><br><span class="line">       WHERE name LIKE 'test/%';</span><br><span class="line">+<span class="comment">----------+----------------------------------------------------+-------+</span></span><br><span class="line">| table_id | name                                               | space |</span><br><span class="line">+<span class="comment">----------+----------------------------------------------------+-------+</span></span><br><span class="line">|      333 | test/FTS_0000000000000147_00000000000001c9_INDEX_1 |   289 |</span><br><span class="line">|      334 | test/FTS_0000000000000147_00000000000001c9_INDEX_2 |   290 |</span><br><span class="line">|      335 | test/FTS_0000000000000147_00000000000001c9_INDEX_3 |   291 |</span><br><span class="line">|      336 | test/FTS_0000000000000147_00000000000001c9_INDEX_4 |   292 |</span><br><span class="line">|      337 | test/FTS_0000000000000147_00000000000001c9_INDEX_5 |   293 |</span><br><span class="line">|      338 | test/FTS_0000000000000147_00000000000001c9_INDEX_6 |   294 |</span><br><span class="line">|      330 | test/FTS_0000000000000147_BEING_DELETED            |   286 |</span><br><span class="line">|      331 | test/FTS_0000000000000147_BEING_DELETED_CACHE      |   287 |</span><br><span class="line">|      332 | test/FTS_0000000000000147_CONFIG                   |   288 |</span><br><span class="line">|      328 | test/FTS_0000000000000147_DELETED                  |   284 |</span><br><span class="line">|      329 | test/FTS_0000000000000147_DELETED_CACHE            |   285 |</span><br><span class="line">|      327 | test/opening_lines                                 |   283 |</span><br><span class="line">+<span class="comment">----------+----------------------------------------------------+-------+</span></span><br></pre></td></tr></table></figure>

<p>前六个表代表倒排索引，并称为辅助索引表。对传入文档进行标记时，各个单词（也称为 “ 标记 ”）与位置信息和关联的文档ID（<code>DOC_ID</code>）一起插入索引表中。根据单词的第一个字符的字符集排序权重，单词在六个索引表中得到完全排序和分区。</p>
<p>倒排索引分为六个辅助索引表，以支持并行索引创建。默认情况下，两个线程对索引表中的单词和相关数据进行标记，排序和插入。线程数可以使用该<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_ft_sort_pll_degree" target="_blank" rel="noopener"><code>innodb_ft_sort_pll_degree</code></a> 选项配置 。<code>FULLTEXT</code>在大型表上创建索引时，请考虑增加线程数 。</p>
<p>辅助索引表名称以前缀 <code>FTS_</code>和后缀 <code>INDEX_*</code>。每个索引表通过索引表名称中与<code>table_id</code>索引表的匹配的十六进制值与索引表相关联。例如，<code>table_id</code>所述的 <code>test/opening_lines</code>表是 <code>327</code>，为此，十六进制值是0x147。如前面的示例所示，十六进制值“ 147 ”出现在与该<code>test/opening_lines</code>表关联的索引表的名称中。</p>
<p>表示的十六进制值<code>index_id</code>的的 <code>FULLTEXT</code>索引也出现在辅助索引表名。例如，在辅助表名称中 <code>test/FTS_0000000000000147_00000000000001c9_INDEX_1</code>，十六进制值<code>1c9</code>的十进制值为457。可以通过查询 表中的该值（457）来识别<code>opening_lines</code>表（<code>idx</code>） 上定义的索引<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-sys-indexes-table.html" target="_blank" rel="noopener"><code>INFORMATION_SCHEMA.INNODB_SYS_INDEXES</code></a>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT index_id, name, table_id, space from INFORMATION_SCHEMA.INNODB_SYS_INDEXES</span><br><span class="line">       WHERE index_id=457;</span><br><span class="line">+<span class="comment">----------+------+----------+-------+</span></span><br><span class="line">| index_id | name | table_id | space |</span><br><span class="line">+<span class="comment">----------+------+----------+-------+</span></span><br><span class="line">|      457 | idx  |      327 |   283 |</span><br><span class="line">+<span class="comment">----------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>

<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a>启用 索引表后，索引表将存储在其自己的表空间中 。如果 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a>禁用此选项，则索引表存储在 <code>InnoDB</code>系统表空间（空间0）中。</p>
<p>注意</p>
<p>由于MySQL 5.6.5中引入的错误，启用索引表后会在<code>InnoDB</code>系统表空间（空间0） 中创建索引表<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a>。该错误已在MySQL 5.6.20和MySQL 5.7.5（Bug＃18635485）中修复。</p>
<p>上一示例中显示的其他索引表称为通用索引表，用于删除处理和存储<code>FULLTEXT</code>索引的内部状态 。与为每个全文索引创建的倒排索引表不同，这组表是在特定表上创建的所有全文索引所共有的。</p>
<p>即使删除了全文索引，也会保留公用辅助表。删除全文索引时，将 <code>FTS_DOC_ID</code>保留为该索引创建的<code>FTS_DOC_ID</code> 列，因为删除该列将需要重建表。需要通用的腋窝表来管理该<code>FTS_DOC_ID</code> 柱。</p>
<ul>
<li><p><code>FTS_*_DELETED</code> 和 <code>FTS_*_DELETED_CACHE</code></p>
<p>包含已删除但其数据尚未从全文索引中删除的文档的文档ID（DOC_ID）。该<code>FTS_*_DELETED_CACHE</code>是内存版本的<code>FTS_*_DELETED</code> 表。</p>
</li>
<li><p><code>FTS_*_BEING_DELETED</code> 和 <code>FTS_*_BEING_DELETED_CACHE</code></p>
<p>包含已删除文档的文档ID（DOC_ID），这些文档的数据当前正在从全文索引中删除。该<code>FTS_*_BEING_DELETED_CACHE</code>表是该 表的内存版本 <code>FTS_*_BEING_DELETED</code>。</p>
</li>
<li><p><code>FTS_*_CONFIG</code></p>
<p>存储有关<code>FULLTEXT</code>索引内部状态的信息 。最重要的是，它存储<code>FTS_SYNCED_DOC_ID</code>，用于标识已解析并刷新到磁盘的文档。在崩溃恢复的情况下， <code>FTS_SYNCED_DOC_ID</code>将使用值来标识尚未刷新到磁盘的文档，以便可以重新解析文档并将其添加回 <code>FULLTEXT</code>索引缓存中。要查看此表中的数据，请查询该 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-ft-config-table.html" target="_blank" rel="noopener"><code>INFORMATION_SCHEMA.INNODB_FT_CONFIG</code></a> 表。</p>
</li>
</ul>
<h5 id="InnoDB全文索引缓存"><a href="#InnoDB全文索引缓存" class="headerlink" title="InnoDB全文索引缓存"></a>InnoDB全文索引缓存</h5><p>插入文档后，将对其进行标记化，并将各个单词和关联的数据插入 <code>FULLTEXT</code>索引。即使对于小型文档，此过程也可能导致在辅助索引表中进行大量小的插入，从而使对这些表的并发访问成为争用点。为避免此问题，请 <code>InnoDB</code>使用<code>FULLTEXT</code> 索引缓存来临时缓存最近插入的行的索引表插入。此内存中的高速缓存结构将保留插入，直到高速缓存已满，然后将其批量刷新到磁盘（至辅助索引表）。您可以查询该 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-ft-index-cache-table.html" target="_blank" rel="noopener"><code>INFORMATION_SCHEMA.INNODB_FT_INDEX_CACHE</code></a> 表以查看最近插入的行的标记化数据。</p>
<p>缓存和批处理刷新行为避免了对辅助索引表的频繁更新，这可能导致在繁忙的插入和更新期间并发访问问题。批处理技术还避免了同一单词的多次插入，并最大程度地减少了重复输入。代替单独刷新每个单词，对同一单词的插入进行合并并作为单个条目刷新到磁盘，从而提高了插入效率，同时保持了尽可能小的辅助索引表。</p>
<p>该<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_ft_cache_size" target="_blank" rel="noopener"><code>innodb_ft_cache_size</code></a> 变量用于配置全文索引缓存大小（基于每个表），这会影响刷新全文索引缓存的频率。您还可以使用该<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_ft_total_cache_size" target="_blank" rel="noopener"><code>innodb_ft_total_cache_size</code></a> 选项为给定实例中的所有表定义全局全文索引高速缓存大小限制 。</p>
<p>全文索引缓存存储与辅助索引表相同的信息。但是，全文索引缓存仅缓存最近插入的行的标记化数据。查询时，已刷新到磁盘（全文辅助表）的数据不会带回到全文索引缓存中。直接查询辅助索引表中的数据，并将辅助索引表中的结果与全文索引缓存中的结果合并，然后再返回。</p>
<h5 id="InnoDB全文索引文档ID和FTS-DOC-ID列"><a href="#InnoDB全文索引文档ID和FTS-DOC-ID列" class="headerlink" title="InnoDB全文索引文档ID和FTS_DOC_ID列"></a>InnoDB全文索引文档ID和FTS_DOC_ID列</h5><p><code>InnoDB</code>使用称为文档ID（<code>DOC_ID</code>）的唯一文档标识符将全文索引中的单词映射到单词出现的文档记录。映射需要<code>FTS_DOC_ID</code> 在索引表上有一列。如果<code>FTS_DOC_ID</code> 未定义列，则在创建全文索引时<code>InnoDB</code>自动添加一个隐藏的<code>FTS_DOC_ID</code>列。下面的示例演示了此行为。</p>
<p>下表定义不包括 <code>FTS_DOC_ID</code>列：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE opening_lines (</span><br><span class="line">       id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,</span><br><span class="line">       opening_line TEXT(500),</span><br><span class="line">       author VARCHAR(200),</span><br><span class="line">       title VARCHAR(200)</span><br><span class="line">       ) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure>

<p>当使用<code>CREATE FULLTEXT INDEX</code>语法在表上创建全文索引时，将 返回警告，报告<code>InnoDB</code>正在重建表以添加<code>FTS_DOC_ID</code> 列。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE FULLTEXT INDEX idx ON opening_lines(opening_line);</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.19 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 1</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW WARNINGS;</span><br><span class="line">+<span class="comment">---------+------+--------------------------------------------------+</span></span><br><span class="line">| Level   | Code | Message                                          |</span><br><span class="line">+<span class="comment">---------+------+--------------------------------------------------+</span></span><br><span class="line">| Warning |  124 | InnoDB rebuilding table to add column FTS_DOC_ID |</span><br><span class="line">+<span class="comment">---------+------+--------------------------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>当用于<a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>向没有<code>FTS_DOC_ID</code>列的表中添加全文索引时，将 返回相同的警告 。如果您一次创建全文索引<a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>并且未指定<code>FTS_DOC_ID</code>列，则 <code>InnoDB</code>添加隐藏 <code>FTS_DOC_ID</code>列，而不会发出警告。</p>
<p>与<code>FTS_DOC_ID</code>在<a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>已经加载了数据的表上创建全文索引相比，在时间上定义列 要便宜得多。如果<code>FTS_DOC_ID</code> 在加载数据之前在表上定义了列，则不必重建表及其索引即可添加新列。如果您不关心<code>CREATE FULLTEXT INDEX</code>性能，请忽略该<code>FTS_DOC_ID</code>列来 <code>InnoDB</code>为您创建性能 。 <code>InnoDB</code>创建隐藏的 <code>FTS_DOC_ID</code>列以及<code>FTS_DOC_ID_INDEX</code>该<code>FTS_DOC_ID</code>列上的唯一索引（） 。如果要创建自己的<code>FTS_DOC_ID</code>列，则必须将该列定义为<code>BIGINT UNSIGNED NOT NULL</code>并命名为 <code>FTS_DOC_ID</code> （全部大写），如以下示例所示：</p>
<p>注意</p>
<p>该<code>FTS_DOC_ID</code>列不必定义为<code>AUTO_INCREMENT</code>列，但 <code>AUTO_INCREMENT</code>可以使加载数据更加容易。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE opening_lines (</span><br><span class="line">       FTS_DOC_ID BIGINT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,</span><br><span class="line">       opening_line TEXT(500),</span><br><span class="line">       author VARCHAR(200),</span><br><span class="line">       title VARCHAR(200)</span><br><span class="line">       ) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure>

<p>如果选择自己定义<code>FTS_DOC_ID</code>列，则您有责任管理该列，以免出现空值或重复值。<code>FTS_DOC_ID</code>值不能重复使用，这意味着<code>FTS_DOC_ID</code> 值必须不断增加。</p>
<p>（可选）您可以<code>FTS_DOC_ID_INDEX</code>在<code>FTS_DOC_ID</code>列上创建所需的唯一 （全部大写） 。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE UNIQUE INDEX FTS_DOC_ID_INDEX on opening_lines(FTS_DOC_ID);</span><br></pre></td></tr></table></figure>

<p>如果您未创建<code>FTS_DOC_ID_INDEX</code>， <code>InnoDB</code>则会自动创建。</p>
<p>在MySQL 5.6.31之前，最大使用<code>FTS_DOC_ID</code>值与新 <code>FTS_DOC_ID</code>值之间的允许间隙 为10000。在MySQL 5.6.31及更高版本中，允许间隙为65535。</p>
<p>为避免重建表，<code>FTS_DOC_ID</code> 删除全文索引时将保留该列。</p>
<h5 id="InnoDB全文索引删除处理"><a href="#InnoDB全文索引删除处理" class="headerlink" title="InnoDB全文索引删除处理"></a>InnoDB全文索引删除处理</h5><p>删除具有全文索引列的记录可能会导致辅助索引表中的许多小删除，从而使对这些表的并发访问成为争用点。为避免此问题，每当从索引表中删除<code>DOC_ID</code>记录时，已删除文档的Document ID（）就会记录在特殊<code>FTS_*_DELETED</code>表中，并且索引记录仍保留在全文索引中。返回查询结果之前，<code>FTS_*_DELETED</code>表格用于过滤删除的文档ID。这种设计的好处是删除既快速又便宜。缺点是删除记录后不会立即减小索引的大小。要删除已删除记录的全文索引条目，请<code>OPTIMIZE TABLE</code>在带有索引的表上 运行<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_optimize_fulltext_only" target="_blank" rel="noopener"><code>innodb_optimize_fulltext_only=ON</code></a> 以重建全文索引。有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/fulltext-fine-tuning.html#fulltext-optimize" target="_blank" rel="noopener">优化InnoDB全文索引</a>。</p>
<h5 id="InnoDB全文索引事务处理"><a href="#InnoDB全文索引事务处理" class="headerlink" title="InnoDB全文索引事务处理"></a>InnoDB全文索引事务处理</h5><p><code>InnoDB</code> <code>FULLTEXT</code>索引由于具有缓存和批处理行为，因此具有特殊的事务处理特性。具体来说，<code>FULLTEXT</code>索引的更新和插入是在事务提交时处理的，这意味着 <code>FULLTEXT</code>搜索只能看到提交的数据。下面的示例演示了此行为。该 <code>FULLTEXT</code>搜索只返回插入的行被提交之后的结果。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE opening_lines (</span><br><span class="line">       id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,</span><br><span class="line">       opening_line TEXT(500),</span><br><span class="line">       author VARCHAR(200),</span><br><span class="line">       title VARCHAR(200),</span><br><span class="line">       FULLTEXT idx (opening_line)</span><br><span class="line">       ) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">mysql&gt; BEGIN;</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO opening_lines(opening_line,author,title) VALUES</span><br><span class="line">       ('<span class="keyword">Call</span> me Ishmael.<span class="string">','</span>Herman Melville<span class="string">','</span>Moby-Dick<span class="string">'),</span></span><br><span class="line"><span class="string">       ('</span>A screaming comes across the sky.<span class="string">','</span>Thomas Pynchon<span class="string">','</span>Gravity\<span class="string">'s Rainbow'</span>),</span><br><span class="line">       (<span class="string">'I am an invisible man.'</span>,<span class="string">'Ralph Ellison'</span>,<span class="string">'Invisible Man'</span>),</span><br><span class="line">       (<span class="string">'Where now? Who now? When now?'</span>,<span class="string">'Samuel Beckett'</span>,<span class="string">'The Unnamable'</span>),</span><br><span class="line">       (<span class="string">'It was love at first sight.'</span>,<span class="string">'Joseph Heller'</span>,<span class="string">'Catch-22'</span>),</span><br><span class="line">       (<span class="string">'All this happened, more or less.'</span>,<span class="string">'Kurt Vonnegut'</span>,<span class="string">'Slaughterhouse-Five'</span>),</span><br><span class="line">       (<span class="string">'Mrs. Dalloway said she would buy the flowers herself.'</span>,<span class="string">'Virginia Woolf'</span>,<span class="string">'Mrs. Dalloway'</span>),</span><br><span class="line">       (<span class="string">'It was a pleasure to burn.'</span>,<span class="string">'Ray Bradbury'</span>,<span class="string">'Fahrenheit 451'</span>);</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT COUNT(*) FROM opening_lines WHERE MATCH(opening_line) AGAINST('Ishmael');</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| COUNT(*) |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">|        0 |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; COMMIT;</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT COUNT(*) FROM opening_lines WHERE MATCH(opening_line) AGAINST('Ishmael');</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| COUNT(*) |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">|        1 |</span><br><span class="line">+<span class="comment">----------+</span></span><br></pre></td></tr></table></figure>

<h5 id="监控InnoDB全文索引"><a href="#监控InnoDB全文索引" class="headerlink" title="监控InnoDB全文索引"></a>监控InnoDB全文索引</h5><p>您可以<code>InnoDB</code> <code>FULLTEXT</code>通过查询下<code>INFORMATION_SCHEMA</code> 表来监视和检查索引的特殊文本处理方面：</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-ft-config-table.html" target="_blank" rel="noopener"><code>INNODB_FT_CONFIG</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-ft-index-table-table.html" target="_blank" rel="noopener"><code>INNODB_FT_INDEX_TABLE</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-ft-index-cache-table.html" target="_blank" rel="noopener"><code>INNODB_FT_INDEX_CACHE</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-ft-default-stopword-table.html" target="_blank" rel="noopener"><code>INNODB_FT_DEFAULT_STOPWORD</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-ft-deleted-table.html" target="_blank" rel="noopener"><code>INNODB_FT_DELETED</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-ft-being-deleted-table.html" target="_blank" rel="noopener"><code>INNODB_FT_BEING_DELETED</code></a></li>
</ul>
<p>您还可以<code>FULLTEXT</code>通过查询<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-sys-indexes-table.html" target="_blank" rel="noopener"><code>INNODB_SYS_INDEXES</code></a>和 查看索引和表的 基本信息 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-sys-tables-table.html" target="_blank" rel="noopener"><code>INNODB_SYS_TABLES</code></a>。</p>
<p>有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-information-schema-fulltext_index-tables.html" target="_blank" rel="noopener">第14.15.4节“ InnoDB INFORMATION_SCHEMA FULLTEXT索引表”</a>。</p>
<br>

<h3 id="14-6-3-Tablespace"><a href="#14-6-3-Tablespace" class="headerlink" title="14.6.3 Tablespace"></a>14.6.3 Tablespace</h3><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-system-tablespace.html" target="_blank" rel="noopener">14.6.3.1系统表空间</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-file-per-table-tablespaces.html" target="_blank" rel="noopener">14.6.3.2每表文件表空间</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-undo-tablespaces.html" target="_blank" rel="noopener">14.6.3.3撤消表空间</a></li>
</ul>
<p>本节涵盖与<code>InnoDB</code> 表空间有关的主题。</p>
<h4 id="14-6-3-1系统表空间"><a href="#14-6-3-1系统表空间" class="headerlink" title="14.6.3.1系统表空间"></a>14.6.3.1系统表空间</h4><p>系统表空间是<code>InnoDB</code>数据字典，Doublewrite Buffer，Change Buffer和 Undo Log的存储区 。如果在系统表空间中创建表，而不是在每个表文件中创建表，则它也可能包含表和索引数据。</p>
<p>系统表空间可以具有一个或多个数据文件。默认情况下，<code>ibdata1</code>在数据目录中创建一个名为的系统表空间数据文件 。系统表空间数据文件的大小和数量由<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_data_file_path" target="_blank" rel="noopener"><code>innodb_data_file_path</code></a>启动选项定义。有关配置信息，请参阅《 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-init-startup-configuration.html#innodb-startup-data-file-configuration" target="_blank" rel="noopener">系统表空间数据文件配置》</a>。</p>
<p>本节中以下主题下提供了有关系统表空间的其他信息：</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-system-tablespace.html#innodb-resize-system-tablespace" target="_blank" rel="noopener">调整系统表空间的大小</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-system-tablespace.html#innodb-raw-devices" target="_blank" rel="noopener">对系统表空间使用原始磁盘分区</a></li>
</ul>
<h5 id="调整系统表空间的大小"><a href="#调整系统表空间的大小" class="headerlink" title="调整系统表空间的大小"></a>调整系统表空间的大小</h5><p>本节介绍如何增加或减少系统表空间的大小。</p>
<h6 id="增加系统表空间的大小"><a href="#增加系统表空间的大小" class="headerlink" title="增加系统表空间的大小"></a>增加系统表空间的大小</h6><p>增加系统表空间大小的最简单方法是将其配置为自动扩展。为此，请<code>autoextend</code>为设置中的最后一个数据文件指定 属性<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_data_file_path" target="_blank" rel="noopener"><code>innodb_data_file_path</code></a> ，然后重新启动服务器。例如：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">innodb_data_file_path</span>=ibdata1:<span class="number">10</span>MB:autoextend</span><br></pre></td></tr></table></figure>

<p>当<code>autoextend</code>指定的属性，则数据文件自动大小由8MB增量因为需要空间增加。所述 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_autoextend_increment" target="_blank" rel="noopener"><code>innodb_autoextend_increment</code></a> 可变控制增量大小。</p>
<p>您还可以通过添加另一个数据文件来增加系统表空间的大小。为此：</p>
<ol>
<li>停止MySQL服务器。</li>
<li>如果<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_data_file_path" target="_blank" rel="noopener"><code>innodb_data_file_path</code></a> 使用<code>autoextend</code> 属性定义了设置中的最后一个数据文件，则将 其删除，然后修改size属性以反映当前数据文件的大小。要确定要指定的适当数据文件大小，请检查文件系统中的文件大小，并将该值四舍五入为最接近的MB值，其中MB等于1024 x 1024。</li>
<li>将新的数据文件追加到 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_data_file_path" target="_blank" rel="noopener"><code>innodb_data_file_path</code></a> 设置中，可以选择指定 <code>autoextend</code>属性。该 <code>autoextend</code>属性只能在最后一个数据文件中指定 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_data_file_path" target="_blank" rel="noopener"><code>innodb_data_file_path</code></a> 的设置。</li>
<li>启动MySQL服务器。</li>
</ol>
<p>例如，此表空间具有一个自动扩展数据文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innodb_data_home_dir =</span><br><span class="line">innodb_data_file_path = /ibdata/ibdata1:10M:autoextend</span><br></pre></td></tr></table></figure>

<p>假设数据文件随着时间增长到988MB。这是<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_data_file_path" target="_blank" rel="noopener"><code>innodb_data_file_path</code></a> 修改大小属性以反映当前数据文件大小之后，并指定新的50MB自动扩展数据文件之后的设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innodb_data_home_dir =</span><br><span class="line">innodb_data_file_path = /ibdata/ibdata1:988M;/disk2/ibdata2:50M:autoextend</span><br></pre></td></tr></table></figure>

<p>添加新数据文件时，请勿指定现有文件名。<code>InnoDB</code>启动服务器时，将创建并初始化新的数据文件。</p>
<p>注意：</p>
<blockquote>
<p> 您不能通过更改其大小属性来增加现有系统表空间数据文件的大小。例如，在启动服务器时，将<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_data_file_path" target="_blank" rel="noopener"><code>innodb_data_file_path</code></a>设置从更改 <code>ibdata1:10M:autoextend</code>为 <code>ibdata1:12M:autoextend</code>会产生以下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; [ERROR] [MY-012263] [InnoDB] The Auto-extending innodb_system </span><br><span class="line">&gt; data file &apos;./ibdata1&apos; is of a different size 640 pages (rounded down to MB) than </span><br><span class="line">&gt; specified in the .cnf file: initial 768 pages, max 0 (relevant if non-zero) pages!</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>该错误表明现有数据文件大小（以<code>InnoDB</code>页表示）与配置文件中指定的大小不同。如果遇到此错误，请恢复先前的 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_data_file_path" target="_blank" rel="noopener"><code>innodb_data_file_path</code></a> 设置，然后参考系统表空间调整大小说明。</p>
<p><code>InnoDB</code>页面大小由<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_page_size" target="_blank" rel="noopener"><code>innodb_page_size</code></a>变量定义 。默认值为16384字节。</p>
</blockquote>
<h6 id="减少InnoDB系统表空间的大小"><a href="#减少InnoDB系统表空间的大小" class="headerlink" title="减少InnoDB系统表空间的大小"></a>减少InnoDB系统表空间的大小</h6><p>您不能从系统表空间中删除数据文件。要减小系统表空间大小，请使用以下过程：</p>
<ol>
<li><p>使用<a href="https://dev.mysql.com/doc/refman/5.6/en/mysqldump.html" target="_blank" rel="noopener"><strong>mysqldump</strong></a>转储所有 <code>InnoDB</code>表，包括 模式中的<code>InnoDB</code>表 <code>mysql</code>。使用以下查询标识 模式中的<code>InnoDB</code>表 <code>mysql</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT TABLE_NAME from INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA='mysql' and ENGINE='InnoDB';</span><br><span class="line">+<span class="comment">----------------------+</span></span><br><span class="line">| table_name           |</span><br><span class="line">+<span class="comment">----------------------+</span></span><br><span class="line">| innodb_index_stats   |</span><br><span class="line">| innodb_table_stats   |</span><br><span class="line">| slave_master_info    |</span><br><span class="line">| slave_relay_log_info |</span><br><span class="line">| slave_worker_info    |</span><br><span class="line">+<span class="comment">----------------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止服务器。</p>
</li>
<li><p>删除所有现有的表空间文件（<code>*.ibd</code>），包括 <code>ibdata</code>和<code>ib_log</code> 文件。不要忘记删除 架构<code>*.ibd</code> 中表的文件<code>mysql</code>。</p>
</li>
<li><p>删除表的所有<code>.frm</code>文件 <code>InnoDB</code>。</p>
</li>
<li><p>为新系统表空间配置数据文件。请参阅 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-init-startup-configuration.html#innodb-startup-data-file-configuration" target="_blank" rel="noopener">系统表空间数据文件配置</a>。</p>
</li>
<li><p>重新启动服务器。</p>
</li>
<li><p>导入转储文件。</p>
</li>
</ol>
<p>注意</p>
<p>如果您的数据库仅使用<code>InnoDB</code> 引擎，则转储<strong>所有</strong>数据库，停止服务器，删除所有数据库和<code>InnoDB</code>日志文件，重新启动服务器以及导入转储文件可能更简单 。</p>
<h5 id="对系统表空间使用原始磁盘分区"><a href="#对系统表空间使用原始磁盘分区" class="headerlink" title="对系统表空间使用原始磁盘分区"></a>对系统表空间使用原始磁盘分区</h5><p>您可以将原始磁盘分区用作<code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_system_tablespace" target="_blank" rel="noopener">系统表空间</a>中的数据文件 。此技术可在Windows以及某些Linux和Unix系统上启用无缓冲I / O，而不会增加文件系统开销。在有和没有原始分区的情况下执行测试，以验证此更改是否确实提高了系统性能。</p>
<p>使用原始磁盘分区时，请确保运行MySQL服务器的用户ID具有该分区的读写特权。例如，如果您以<code>mysql</code>用户身份运行服务器 ，则分区必须可由读取和写入<code>mysql</code>。如果使用该<a href="https://dev.mysql.com/doc/refman/5.6/en/server-options.html#option_mysqld_memlock" target="_blank" rel="noopener"><code>--memlock</code></a>选项运行服务器，则该服务器必须以身份运行<code>root</code>，因此该分区必须可由读取和写入<code>root</code>。</p>
<p>下述步骤涉及选项文件的修改。有关更多信息，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/option-files.html" target="_blank" rel="noopener">第4.2.2.2节“使用选项文件”</a>。</p>
<h6 id="在Linux和Unix系统上分配原始磁盘分区"><a href="#在Linux和Unix系统上分配原始磁盘分区" class="headerlink" title="在Linux和Unix系统上分配原始磁盘分区"></a>在Linux和Unix系统上分配原始磁盘分区</h6><ol>
<li><p>When you create a new data file, specify the keyword <code>newraw</code> immediately after the data file size for the <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_data_file_path" target="_blank" rel="noopener"><code>innodb_data_file_path</code></a> option. The partition must be at least as large as the size that you specify. Note that 1MB in <code>InnoDB</code> is 1024 × 1024 bytes, whereas 1MB in disk specifications usually means 1,000,000 bytes.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_data_home_dir=</span><br><span class="line">innodb_data_file_path=/dev/hdd1:3Gnewraw;/dev/hdd2:2Gnewraw</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新启动服务器。<code>InnoDB</code>注意 <code>newraw</code>关键字并初始化新分区。但是，请不要创建或更改任何 <code>InnoDB</code>表。否则，当您下次重新启动服务器时，将<code>InnoDB</code> 重新初始化分区，并且所做的更改将丢失。（为安全起见，<code>InnoDB</code>当<code>newraw</code>指定任何分区时，防止用户修改数据 。）</p>
</li>
<li><p>后<code>InnoDB</code>已初始化新的分区，停止服务器，更改<code>newraw</code> 数据文件规范<code>raw</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_data_home_dir=</span><br><span class="line">innodb_data_file_path=/dev/hdd1:3Graw;/dev/hdd2:2Graw</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新启动服务器。<code>InnoDB</code>现在允许进行更改。</p>
</li>
</ol>
<h6 id="在Windows上分配原始磁盘分区"><a href="#在Windows上分配原始磁盘分区" class="headerlink" title="在Windows上分配原始磁盘分区"></a>在Windows上分配原始磁盘分区</h6><p>在Windows系统上，适用于Linux和Unix系统的相同步骤和随附的准则，只是<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_data_file_path" target="_blank" rel="noopener"><code>innodb_data_file_path</code></a>Windows上的 设置略有不同。</p>
<ol>
<li><p>创建新的数据文件时，请在<code>newraw</code>该<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_data_file_path" target="_blank" rel="noopener"><code>innodb_data_file_path</code></a> 选项的数据文件大小后立即 指定关键字 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_data_home_dir=</span><br><span class="line">innodb_data_file_path=//./D::10Gnewraw</span><br></pre></td></tr></table></figure>

<p>在<code>//./</code>相当于Windows语法<code>\\.\</code>用于访问物理驱动器。在上面的示例中，<code>D:</code>是分区的驱动器号。</p>
</li>
<li><p>重新启动服务器。<code>InnoDB</code>注意 <code>newraw</code>关键字并初始化新分区。</p>
</li>
<li><p>后<code>InnoDB</code>已初始化新的分区，停止服务器，更改<code>newraw</code> 数据文件规范<code>raw</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_data_home_dir=</span><br><span class="line">innodb_data_file_path=//./D::10Graw</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新启动服务器。<code>InnoDB</code>现在允许进行更改。</p>
</li>
</ol>
<h4 id="14-6-3-2-File-Per-Table-Tablespaces"><a href="#14-6-3-2-File-Per-Table-Tablespaces" class="headerlink" title="14.6.3.2 File-Per-Table-Tablespaces"></a>14.6.3.2 File-Per-Table-Tablespaces</h4><p>每表文件表空间包含单个<code>InnoDB</code>表的数据和索引 ，并存储在文件系统中自己的数据文件中。</p>
<p>每节文件表空间特征在本节的以下主题下描述：</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-file-per-table-tablespaces.html#innodb-file-per-table-configuration" target="_blank" rel="noopener">每表文件表空间配置</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-file-per-table-tablespaces.html#innodb-file-per-table-data-files" target="_blank" rel="noopener">每表文件表空间数据文件</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-file-per-table-tablespaces.html#innodb-file-per-table-advantages" target="_blank" rel="noopener">每表文件表空间的优势</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-file-per-table-tablespaces.html#innodb-file-per-table-disadvantages" target="_blank" rel="noopener">每表文件表空间的缺点</a></li>
</ul>
<h5 id="每表文件表空间配置"><a href="#每表文件表空间配置" class="headerlink" title="每表文件表空间配置"></a>每表文件表空间配置</h5><p><code>InnoDB</code>默认情况下，在每个表文件表空间中创建表。此行为由<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a>变量控制 。禁用在系统表空间中创建表的<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a> 原因<code>InnoDB</code>。</p>
<p>的<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a> 设置可以在选项文件来指定，或者使用在运行时配置的 <a href="https://dev.mysql.com/doc/refman/5.6/en/set-variable.html" target="_blank" rel="noopener"><code>SET GLOBAL</code></a>语句。在运行时更改设置需要足够的特权来设置全局系统变量。请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/system-variable-privileges.html" target="_blank" rel="noopener">第5.1.8.1节“系统变量特权”</a>。</p>
<p>选项文件：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">innodb_file_per_table</span>=<span class="literal">ON</span></span><br></pre></td></tr></table></figure>

<p><a href="https://dev.mysql.com/doc/refman/5.6/en/set-variable.html" target="_blank" rel="noopener"><code>SET GLOBAL</code></a>在运行时 使用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL innodb_file_per_table=ON;</span><br></pre></td></tr></table></figure>

<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a>在MySQL 5.6和更高版本中默认启用。如果需要考虑与MySQL早期版本的向后兼容性，则可以考虑禁用它。</p>
<p>警告</p>
<p>禁用 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a> 可防止表复制<a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>操作将驻留在系统表空间中的表隐式移动到每个表文件表空间。表复制<a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>操作将使用当前<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a> 设置重新创建表。添加或删除二级索引时，此行为不适用，也不适用于 <a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>使用该<code>INPLACE</code>算法的操作。</p>
<h5 id="每表文件表空间数据文件"><a href="#每表文件表空间数据文件" class="headerlink" title="每表文件表空间数据文件"></a>每表文件表空间数据文件</h5><p><code>.idb</code>在MySQL数据目录下的架构目录 中的数据文件中，将创建一个每表文件表空间 。该<code>.ibd</code>文件以表（<code>*</code>table_name<code>*.ibd</code>）命名。例如，在MySQL数据目录下的目录中<code>test.t1</code> 创建表的数据文件<code>test</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE test;  </span><br><span class="line">  </span><br><span class="line">mysql&gt; CREATE TABLE t1 (</span><br><span class="line">   id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">   name VARCHAR(100) </span><br><span class="line"> ) ENGINE = InnoDB; </span><br><span class="line"> </span><br><span class="line">shell&gt; cd /path/to/mysql/data/test</span><br><span class="line">shell&gt; ls </span><br><span class="line">t1.ibd</span><br></pre></td></tr></table></figure>

<p>您可以使用该语句的<code>DATA DIRECTORY</code>子句 <a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>在数据目录外部隐式创建每表文件表空间数据文件。有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-create-table-external.html" target="_blank" rel="noopener">第14.6.1.2节“在外部创建表”</a>。</p>
<h5 id="每表文件表空间的优势"><a href="#每表文件表空间的优势" class="headerlink" title="每表文件表空间的优势"></a>每表文件表空间的优势</h5><p>每表文件表空间比共享系统表空间具有以下优点。</p>
<ul>
<li>截断或删除每个表文件表空间中创建的表后，磁盘空间将返回操作系统。截断或删除存储在系统表空间中的表会在系统表空间内创建可用空间，该可用空间仅可用于 <code>InnoDB</code>数据。换句话说，在表被截断或删除后，系统表空间的大小不会缩小。</li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a> 对驻留在系统表空间中的表进行表 复制操作可能会增加表空间占用的磁盘空间量。此类操作可能需要与表中的数据加索引一样多的额外空间。该空间不会像每个表文件表空间那样释放回操作系统。</li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/truncate-table.html" target="_blank" rel="noopener"><code>TRUNCATE TABLE</code></a> 在每个表文件表空间中的表上执行时，性能会更好。</li>
<li>可以在单独的存储设备上创建每表文件表空间数据文件，以进行I / O优化，空间管理或备份。请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-create-table-external.html" target="_blank" rel="noopener">第14.6.1.2节“在外部创建表”</a>。</li>
<li>您可以从另一个MySQL实例导入位于每个表文件表空间中的表。请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-table-import.html" target="_blank" rel="noopener">第14.6.1.3节“导入InnoDB表”</a>。</li>
<li>在每表文件表空间中创建的表使用梭子鱼文件格式。请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-file-format.html" target="_blank" rel="noopener">第14.10节“ InnoDB文件格式管理”</a>。梭子鱼文件格式启用<code>DYNAMIC</code>与<code>COMPRESSED</code> 行格式关联的功能 。请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-row-format.html" target="_blank" rel="noopener">第14.11节“ InnoDB行格式”</a>。</li>
<li>当发生数据损坏，备份或二进制日志不可用或无法重新启动MySQL服务器实例时，存储在单个表空间数据文件中的表可以节省时间并提高成功恢复的机会。</li>
<li>您可以使用MySQL Enterprise Backup快速备份或还原在每表文件表空间中创建的表，而不会中断其他<code>InnoDB</code> 表的使用。这对于具有不同备份计划的表或需要较少备份频率的表很有用。有关详细信息，请参见 <a href="https://dev.mysql.com/doc/mysql-enterprise-backup/3.12/en/partial.html" target="_blank" rel="noopener">进行部分备份</a>。</li>
<li>每表文件表空间允许通过监视表空间数据文件的大小来监视文件系统上的表大小。</li>
<li>当通用的Linux文件系统不允许并发写入到一个单一的文件，如系统表空间的数据文件 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_flush_method" target="_blank" rel="noopener"><code>innodb_flush_method</code></a>设置为<code>O_DIRECT</code>。因此，结合使用每表文件表空间和此设置时，可能会提高性能。</li>
<li>共享系统表空间中的表包含<code>InnoDB</code>64TB表空间大小限制，该表包含数据字典和Undo Log等其他结构。相比之下，每个表的每个文件表空间都有64TB的大小限制，这为单个表的大小增加提供了足够的空间。</li>
</ul>
<h5 id="每表文件表空间的缺点"><a href="#每表文件表空间的缺点" class="headerlink" title="每表文件表空间的缺点"></a>每表文件表空间的缺点</h5><p>与共享系统表空间相比，每表文件表空间具有以下缺点。</p>
<ul>
<li>使用每表文件表空间，每个表可能有未使用的空间，只能由同一表的行使用，如果管理不当，则会浪费空间。</li>
<li><code>fsync</code>对每个表的多个数据文件而不是共享系统表空间数据文件执行操作。由于 <code>fsync</code>操作是针对每个文件的，因此无法合并针对多个表的写操作，这可能导致更多的<code>fsync</code> 操作总数。</li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/mysqld.html" target="_blank" rel="noopener"><strong>mysqld</strong></a>必须为每个表文件空间保留一个打开的文件句柄，如果每个表文件空间中有许多表，则可能会影响性能。</li>
<li>每个表都有其自己的数据文件时，需要更多的文件描述符。</li>
<li>可能存在更多碎片，这可能会影响 <a href="https://dev.mysql.com/doc/refman/5.6/en/drop-table.html" target="_blank" rel="noopener"><code>DROP TABLE</code></a>表扫描性能。但是，如果管理碎片，则每表文件表空间可以提高这些操作的性能。</li>
<li>删除驻留在每个表文件表空间中的表时，将扫描缓冲池，对于大型缓冲池可能要花费几秒钟。使用宽泛的内部锁定执行扫描，这可能会延迟其他操作。</li>
<li>该<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_autoextend_increment" target="_blank" rel="noopener"><code>innodb_autoextend_increment</code></a> 变量定义用于在自动扩展系统表空间文件变满时扩展其大小的增量大小，该 变量不适用于每表文件表空间文件，无论<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_autoextend_increment" target="_blank" rel="noopener"><code>innodb_autoextend_increment</code></a> 设置如何，该文件都将自动扩展 。每个表的初始文件表扩展名很少，之后扩展名以4MB为增量。</li>
</ul>
<h4 id="14-6-3-3-Undo-Tablespaces"><a href="#14-6-3-3-Undo-Tablespaces" class="headerlink" title="14.6.3.3 Undo Tablespaces"></a>14.6.3.3 Undo Tablespaces</h4><p>撤消表空间包含Undo Log，Undo Log是Undo Log记录的集合，其中包含有关如何通过事务撤消对聚集索引记录的最新更改的信息。Undo Log段中包含Undo Log。该 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_rollback_segments" target="_blank" rel="noopener"><code>innodb_rollback_segments</code></a>变量定义分配给每个撤消表空间的回滚段的数量。</p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_undo_log" target="_blank" rel="noopener">Undo Log</a>可以存储在一个或多个<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_undo_tablespace" target="_blank" rel="noopener">撤消表空间中，</a>而不是 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_system_tablespace" target="_blank" rel="noopener">系统表空间中</a>。此布局与默认配置不同，在默认配置中，Undo Log位于<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_system_tablespace" target="_blank" rel="noopener">系统表空间中</a>。Undo Log的I / O模式使撤消表空间成为<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_ssd" target="_blank" rel="noopener">SSD</a>存储的理想候选者 ，同时将系统表空间保留在硬盘存储上。</p>
<p>所使用的撤消表空间的数量<code>InnoDB</code> 由<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_undo_tablespaces" target="_blank" rel="noopener"><code>innodb_undo_tablespaces</code></a> 配置选项控制 。仅在初始化MySQL实例时才能配置此选项。此后无法更改。</p>
<p>撤消表空间和这些表空间内的各个 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_segment" target="_blank" rel="noopener">段</a>不能删除。</p>
<h5 id="配置撤消表空间"><a href="#配置撤消表空间" class="headerlink" title="配置撤消表空间"></a>配置撤消表空间</h5><p>要为MySQL实例配置撤消表空间，请执行以下步骤。假定您在将配置部署到生产系统之前正在测试实例上执行该过程。</p>
<p>重要</p>
<p>撤消表空间的数量只能在初始化MySQL实例时配置，并且在实例生命周期内是固定的。</p>
<ol>
<li><p>使用<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_undo_directory" target="_blank" rel="noopener"><code>innodb_undo_directory</code></a> 配置选项为撤消表空间指定<u><strong>目录位置</strong></u> 。如果未指定目录位置，则在数据目录中创建撤消表空间。</p>
</li>
<li><p>使用<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_rollback_segments" target="_blank" rel="noopener"><code>innodb_rollback_segments</code></a> 配置选项定义回滚段的数量 。从一个相对较低的值开始，然后随着时间的推移逐渐增加它，以检查对性能的影响。默认设置为 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_rollback_segments" target="_blank" rel="noopener"><code>innodb_rollback_segments</code></a>128，这也是最大值。</p>
<p>一个回退段始终分配给系统表空间。因此，要将回滚段分配给撤消表空间，请设置 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_rollback_segments" target="_blank" rel="noopener"><code>innodb_rollback_segments</code></a>为大于1的值。例如，如果您有两个撤消表空间，则设置 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_rollback_segments" target="_blank" rel="noopener"><code>innodb_rollback_segments</code></a>为3可以为两个撤消表空间中的每一个分配一个回滚段。回滚段以循环方式分布在撤消表空间中。</p>
<p>配置单独的撤消表空间时，系统表空间中的回滚段将变为非活动状态。</p>
</li>
<li><p>使用该<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_undo_tablespaces" target="_blank" rel="noopener"><code>innodb_undo_tablespaces</code></a> 选项定义撤消表空间的数量 。在MySQL实例的生命周期中，指定的还原表空间数量是固定的，因此，如果不确定最佳值，请从高端进行估算。</p>
</li>
<li><p>使用您选择的选项值创建一个新的MySQL测试实例。</p>
</li>
<li><p>在测试实例上使用实际的工作负载，并使用与生产服务器类似的数据量来测试配置。</p>
</li>
<li><p>对I / O密集型工作负载的性能进行基准测试。</p>
</li>
<li><p>定期增加价值 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_rollback_segments" target="_blank" rel="noopener"><code>innodb_rollback_segments</code></a> 并重新运行性能测试，直到I / O性能没有进一步提高。</p>
</li>
</ol>
<br>

<h3 id="14-6-4-InnoDB数据字典"><a href="#14-6-4-InnoDB数据字典" class="headerlink" title="14.6.4 InnoDB数据字典"></a>14.6.4 InnoDB数据字典</h3><p>所述<code>InnoDB</code>数据字典由包含元数据的用于跟踪对象的如<u><strong>表，索引，和表中的列的内部系统表</strong></u>。元数据实际上位于<code>InnoDB</code>系统表空间中。由于历史原因，数据字典元数据在某种程度上与<code>InnoDB</code>表元数据文件（<code>.frm</code>文件）中存储的信息重叠 。</p>
<br>

<h3 id="14-6-5-Doublewrite-Buffer"><a href="#14-6-5-Doublewrite-Buffer" class="headerlink" title="14.6.5 Doublewrite Buffer"></a>14.6.5 Doublewrite Buffer</h3><p>doublewrite缓冲区是位于系统表空间中的存储区域，在此之前，<code>InnoDB</code>将从页面<code>InnoDB</code>缓冲池中刷新的页面写入页面，然后再将页面写入数据文件中的适当位置。仅在刷新页面并将页面写入doublewrite缓冲区之后，才 <code>InnoDB</code>将页面写入其适当位置。如果在页面写入过程中发生操作系统，存储子系统或 <a href="https://dev.mysql.com/doc/refman/5.6/en/mysqld.html" target="_blank" rel="noopener"><strong>mysqld</strong></a>进程崩溃，<code>InnoDB</code>以后可以在崩溃恢复期间从doublewrite缓冲区中找到该页面的良好副本。</p>
<p>尽管数据总是被写入两次，但Doublewrite Buffer并不需要两倍的I / O开销或两倍的I / O操作。<code>fsync()</code> 只需对操作系统进行一次调用，就可以将数据作为一个较大的顺序块写入Doublewrite Buffer本身。</p>
<p>默认情况下，Doublewrite Buffer处于启用状态。要禁用Doublewrite Buffer，请设置 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_doublewrite" target="_blank" rel="noopener"><code>innodb_doublewrite</code></a>为0。</p>
<br>

<h3 id="14-6-6-Redo-Log"><a href="#14-6-6-Redo-Log" class="headerlink" title="14.6.6 Redo Log"></a>14.6.6 Redo Log</h3><p>Redo Log是基于磁盘的数据结构，在崩溃恢复期间用于纠正不完整事务写入的数据。在正常操作期间，Redo Log对更改请求数据的请求进行编码，这些请求是由SQL语句或低级API调用引起的。在初始化期间以及接受连接之前，会自动重播未完成意外关闭之前未完成更新数据文件的修改。有关Redo Log在崩溃恢复中的作用的信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-recovery.html" target="_blank" rel="noopener">第14.18.2节“ InnoDB恢复”</a>。</p>
<p>默认情况下，Redo Log在磁盘上由两个名为<code>ib_logfile0</code>和的 文件物理表示<code>ib_logfile1</code>。MySQL以循环方式写入Redo Log文件。Redo Log中的数据按照受影响的记录进行编码；此数据统称为重做。通过Redo Log的数据传递以不断增加的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_lsn" target="_blank" rel="noopener">LSN</a>值表示。</p>
<p>有关相关信息，请参阅 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-init-startup-configuration.html#innodb-startup-log-file-configuration" target="_blank" rel="noopener">Redo Log文件配置</a>和 <a href="https://dev.mysql.com/doc/refman/5.6/en/optimizing-innodb-logging.html" target="_blank" rel="noopener">第8.5.4节“优化InnoDBRedo Log”</a>。</p>
<h4 id="更改Redo-Log文件的数量或大小"><a href="#更改Redo-Log文件的数量或大小" class="headerlink" title="更改Redo Log文件的数量或大小"></a>更改Redo Log文件的数量或大小</h4><p>要在MySQL 5.6.7或更早版本中更改<code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_redo_log" target="_blank" rel="noopener">Redo Log</a>文件的数量或大小，请执行以下步骤：</p>
<ol>
<li><p>如果<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_fast_shutdown" target="_blank" rel="noopener"><code>innodb_fast_shutdown</code></a>设置为2，则设置 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_fast_shutdown" target="_blank" rel="noopener"><code>innodb_fast_shutdown</code></a>为1：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL innodb_fast_shutdown = 1;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确保 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_fast_shutdown" target="_blank" rel="noopener"><code>innodb_fast_shutdown</code></a>未将其设置为2后，停止MySQL服务器并确保其关闭且没有错误（以确保日志中没有未完成事务的信息）。</p>
</li>
<li><p>将旧的日志文件复制到一个安全的地方，以防在关闭过程中出现问题并且需要它们来恢复表空间。</p>
</li>
<li><p>从日志文件目录中删除旧的日志文件。</p>
</li>
<li><p>编辑<code>my.cnf</code>以更改日志文件配置。</p>
</li>
<li><p>再次启动MySQL服务器。<a href="https://dev.mysql.com/doc/refman/5.6/en/mysqld.html" target="_blank" rel="noopener"><strong>mysqld</strong></a>发现<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-storage-engine.html" target="_blank" rel="noopener"><code>InnoDB</code></a>启动时不存在任何日志文件，并创建了新的日志文件。</p>
</li>
</ol>
<p>该<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_fast_shutdown" target="_blank" rel="noopener"><code>innodb_fast_shutdown</code></a> 改变的数量或大小时设置不再是相关的<code>InnoDB</code>日志文件。此外，尽管您可能仍希望将旧日志文件复制到一个安全的地方作为备份，但是不再需要删除旧日志文件。要更改<code>InnoDB</code>日志文件的数量或大小 ，请执行以下步骤：</p>
<ol>
<li>停止MySQL服务器，并确保它关闭且没有错误。</li>
<li>编辑<code>my.cnf</code>以更改日志文件配置。要更改日志文件的大小，请配置 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_log_file_size" target="_blank" rel="noopener"><code>innodb_log_file_size</code></a>。要增加日志文件的数量，请配置 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_log_files_in_group" target="_blank" rel="noopener"><code>innodb_log_files_in_group</code></a>。</li>
<li>再次启动MySQL服务器。</li>
</ol>
<p>如果<code>InnoDB</code>检测到 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_log_file_size" target="_blank" rel="noopener"><code>innodb_log_file_size</code></a>与Redo Log文件大小不同，它将编写日志检查点，关闭并删除旧的日志文件，以请求的大小创建新的日志文件，然后打开新的日志文件。</p>
<h4 id="组提交以Redo-Log刷新"><a href="#组提交以Redo-Log刷新" class="headerlink" title="组提交以Redo Log刷新"></a>组提交以Redo Log刷新</h4><p><code>InnoDB</code>像任何其他 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_acid" target="_blank" rel="noopener">符合ACID</a>的数据库引擎一样，在提交事务之前刷新事务的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_redo_log" target="_blank" rel="noopener">Redo Log</a>。<code>InnoDB</code> 使用<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_group_commit" target="_blank" rel="noopener">组提交</a> 功能将多个此类刷新请求分组在一起，以避免每次提交都进行一次刷新。使用组提交， <code>InnoDB</code>可以对日志文件进行一次写入操作，以对大约同时提交的多个用户事务执行提交操作，从而显着提高了吞吐量。</p>
<p>有关性能<code>COMMIT</code>和其他事务操作的更多信息 ，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/optimizing-innodb-transaction-management.html" target="_blank" rel="noopener">第8.5.2节“优化InnoDB事务管理”</a>。</p>
<br>

<h3 id="14-6-7-Undo-Logs"><a href="#14-6-7-Undo-Logs" class="headerlink" title="14.6.7 Undo Logs"></a>14.6.7 Undo Logs</h3><p><u><strong><em>回滚段</em></strong></u></p>
<p>InnoDB采用回滚段的方式来维护undo log的并发写入和持久化。回滚段实际上是一种 Undo 文件组织方式，每个回滚段又有多个undo log slot。</p>
<p>一共128个回滚段，每个回滚段维护了一个段头页，在该page中又划分了1024个slot (TRX_RSEG_N_SLOTS)，每个slot又对应到一个undo log对象，因此理论上InnoDB最多支持 96 * 1024个普通事务。</p>
<ol>
<li>rseg0预留在系统表空间ibdata中;</li>
<li>rseg 1~rseg 32这32个回滚段存放于临时表的系统表空间中;</li>
<li>rseg33~ 则根据配置存放到独立undo表空间中（如果没有打开独立Undo表空间，则存放于ibdata中）</li>
</ol>
<p><u><strong><em>Undo Log</em></strong></u></p>
<p>​        undo Log是与单个读写事务关联的 <code>undo Log</code> 记录的集合。undo Log 记录包含如何 撤消事务对 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_clustered_index" target="_blank" rel="noopener">聚簇索引</a> 记录的最新更改 的信息。如果另一个事务读取原始数据，就需要在 undo Log记录读取。</p>
<p>​        undo Log存在于 <code>undo log segment</code>。默认情况下，<code>undo log segment</code> 实际上是 <code>system tablespace</code> 的一部分 ，但它们也可以驻留在 <code>undo log tablespace</code> 中。有关更多信息，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-undo-tablespaces.html" target="_blank" rel="noopener">第14.6.3.3节“撤消表空间”</a>。</p>
<ol>
<li><p><code>InnoDB</code>支持128个回滚段，通过参数 <code>innodb_rollback_segments</code> 定义；</p>
</li>
<li><p>一个 <code>rollback segment</code> 支持的 事务数 取决（ <code>rollback segment</code> 中 <code>undo slots</code> 的数量） 和 （每个事务所需的 undo log 数）；</p>
</li>
<li><p>一个<code>rollback segment</code> 中 <code>undo slots</code> 的数量 又会因为 <code>innodb_page_size</code> 不同而不同；</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>InnoDB Page Size</th>
<th>rollback segment 中的 undo slots 数（innodb_page_size/ 16）</th>
</tr>
</thead>
<tbody><tr>
<td><code>4096 (4KB)</code></td>
<td><code>256</code></td>
</tr>
<tr>
<td><code>8192 (8KB)</code></td>
<td><code>512</code></td>
</tr>
<tr>
<td><code>16384 (16KB)</code></td>
<td><code>1024</code></td>
</tr>
</tbody></table>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191203205602.png" alt></p>
<p>以下每种操作类型，一个事务最多可以分配两个 undo Log：</p>
<ol>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a> 操作 在事务提交前只对当前事务可见，因此产生的Undo日志可以在事务提交后直接删除；</li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.6/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a> 操作 产生的Undo日志被归成一类，即update_undo；</li>
</ol>
<p>undo Log根据需要分配。例如，一个事务执行<code>INSERT</code>， <code>UPDATE</code> 和 <code>DELETE</code> 操作被分配了两个undo Log，仅执行<a href="https://dev.mysql.com/doc/refman/5.6/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>操作的事务被分配有一个 undo Log；</p>
<p>分配给事务的Undo Log在其持续时间内始终与事务相关；</p>
<p>给定上述因素，可以使用以下公式来估计<code>InnoDB</code>能够支持的并发读写事务数。</p>
<blockquote>
<p>注意：在达到 <code>InnoDB</code> 能够支持的并发读写事务数之前，事务可能会遇到并发事务限制错误。当分配给事务的 <code>rollback segment</code> 用完 <code>undo slots</code> 时，就会发生这种情况。在这种情况下，请尝试重新运行事务</p>
</blockquote>
<ul>
<li><p>如果每个事务执行任一个 insert 或 update 或 delete 操作，InnoDB支持的 并发读-写事务的数目： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(innodb_page_size / 16) * innodb_rollback_segments</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果每个事务执行任一个 insert 和（ update 或 delete） 操作，InnoDB支持的 并发读-写事务的数目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(innodb_page_size / 16 / 2) * innodb_rollback_segments</span><br></pre></td></tr></table></figure>

</li>
</ul>
<br>

<h2 id="14-12-InnoDB磁盘I-O和文件空间管理"><a href="#14-12-InnoDB磁盘I-O和文件空间管理" class="headerlink" title="14.12 InnoDB磁盘I / O和文件空间管理"></a>14.12 InnoDB磁盘I / O和文件空间管理</h2><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-disk-io.html" target="_blank" rel="noopener">14.12.1 InnoDB磁盘I / O</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-file-space.html" target="_blank" rel="noopener">14.12.2文件空间管理</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-checkpoints.html" target="_blank" rel="noopener">14.12.3 InnoDB检查点</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-file-defragmenting.html" target="_blank" rel="noopener">14.12.4对表进行碎片整理</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-truncate-table-reclaim-space.html" target="_blank" rel="noopener">14.12.5使用TRUNCATE TABLE回收磁盘空间</a></li>
</ul>
<p>作为DBA，您必须管理磁盘I / O以防止I / O子系统饱和，并管理磁盘空间以避免填满存储设备。该<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_acid" target="_blank" rel="noopener">ACID</a>设计模型需要一定量的I / O可能似乎是多余的，但有助于确保数据的可靠性。在这些限制内， <code>InnoDB</code>尝试优化数据库工作和磁盘文件的组织，以最大程度地减少磁盘I / O的数量。有时，I / O会推迟到数据库不忙之前，或者直到所有内容都需要进入一致状态为止，例如在<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_fast_shutdown" target="_blank" rel="noopener">快速关闭</a>后重新启动数据库期间。</p>
<p>本节讨论默认类型的MySQL表（也称为<code>InnoDB</code>表）对I / O和磁盘空间的主要注意事项 ：</p>
<ul>
<li>控制用于提高查询性能的后台I / O数量。</li>
<li>启用或禁用可提供额外耐用性的功能，但需要付出额外的I / O代价。</li>
<li>将表组织成许多小文件，一些大文件或两者的组合。</li>
<li>使Redo Log文件的大小与日志文件已满时发生的I / O活动保持平衡。</li>
<li>如何重组表以获得最佳查询性能。</li>
</ul>
<h3 id="14-12-1-InnoDB磁盘I-O"><a href="#14-12-1-InnoDB磁盘I-O" class="headerlink" title="14.12.1 InnoDB磁盘I / O"></a>14.12.1 InnoDB磁盘I / O</h3><p><code>InnoDB</code>在可能的情况下使用异步磁盘I / O，方法是创建多个线程来处理I / O操作，同时允许其他数据库操作在I / O仍在进行时继续进行。在Linux和Windows平台上，<code>InnoDB</code>使用可用的OS和库函数来执行“ 本机 ”异步I / O。在其他平台上，<code>InnoDB</code>仍然使用I / O线程，但是这些线程实际上可能会等待I / O请求完成。该技术称为“ 模拟 ” 异步I / O。</p>
<h4 id="预读"><a href="#预读" class="headerlink" title="预读"></a>预读</h4><p>如果<code>InnoDB</code>可以确定很快有可能需要数据的可能性很大，它将执行预读操作将数据带入缓冲池，以便在内存中可用。对连续数据进行一些大的读取请求可能比对几个分散的小请求进行效率更高。有两种预读启发式<code>InnoDB</code>：</p>
<ul>
<li>在顺序预读中，如果<code>InnoDB</code> 注意到对表空间中某个段的访问模式是顺序的，则它会将一批数据库页的读取提前发布到I / O系统。</li>
<li>在随机预读中，如果<code>InnoDB</code>注意到表空间中的某些区域似乎正在被完全读入缓冲池，则它将剩余的读操作发布到I / O系统。</li>
</ul>
<p>有关配置<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-performance-read_ahead.html" target="_blank" rel="noopener">预读</a>启发式方法的信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-performance-read_ahead.html" target="_blank" rel="noopener">第14.8.3.3节“配置InnoDB缓冲池预取（预读）”</a>。</p>
<h4 id="Doublewrite-Buffer"><a href="#Doublewrite-Buffer" class="headerlink" title="Doublewrite Buffer"></a>Doublewrite Buffer</h4><p><code>InnoDB</code>使用一种新颖的文件刷新技术，该技术涉及一种称为<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_doublewrite_buffer" target="_blank" rel="noopener">doublewrite缓冲区</a>的结构 ，默认情况下（<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_doublewrite" target="_blank" rel="noopener"><code>innodb_doublewrite=ON</code></a>）已启用。它增加了崩溃或断电后的恢复安全性，并通过减少<code>fsync()</code>操作需求来提高大多数Unix版本的性能。</p>
<p>在将页面<code>InnoDB</code> 写到数据文件之前，首先将它们写到称为doublewrite缓冲区的连续表空间区域中。仅在完成对双<code>InnoDB</code> 写缓冲区的写入和刷新之后，才将页面写入数据文件中的相应位置。如果在页面写入过程中发生操作系统，存储子系统或 <a href="https://dev.mysql.com/doc/refman/5.6/en/mysqld.html" target="_blank" rel="noopener"><strong>mysqld</strong></a>进程崩溃（导致<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_torn_page" target="_blank" rel="noopener">页面损坏的</a> 情况），<code>InnoDB</code>则以后可以在恢复期间从doublewrite缓冲区中找到该页面的良好副本。</p>
<h3 id="14-12-2文件空间管理"><a href="#14-12-2文件空间管理" class="headerlink" title="14.12.2文件空间管理"></a>14.12.2文件空间管理</h3><p>您使用<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_data_file_path" target="_blank" rel="noopener"><code>innodb_data_file_path</code></a> 配置选项在配置文件中定义的数据文件 形成<code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_system_tablespace" target="_blank" rel="noopener">系统表空间</a>。这些文件在逻辑上串联在一起形成系统表空间。没有使用中的条带化。您无法定义表在系统表空间中的分配位置。在新创建的系统表空间中，<code>InnoDB</code>从第一个数据文件开始分配空间。</p>
<p>为避免将所有表和索引存储在系统表空间内所带来的问题，可以启用 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a> 配置选项（默认选项），该选项将每个新创建的表存储在单独的表空间文件中（扩展名为 <code>.ibd</code>）。对于以这种方式存储的表，磁盘文件中的碎片较少，并且当表被截断时，该空间将返回给操作系统，而不是仍由InnoDB在系统表空间中保留。</p>
<p><img src="https://imagehome.oss-cn-beijing.aliyuncs.com/20191203205602.png" alt></p>
<blockquote>
<pre><code>在整理InnoDB存储引擎的索引的时候，发现B+树是离不开页面page的。所以先整理InnoDB的数据存储结构。</code></pre><p>关键词：Pages, Extents, Segments, and Tablespaces</p>
<p><strong>如何存储表</strong><br>MySQL 使用 InnoDB 存储表时，会将表的定义和数据索引等信息分开存储，其中前者存储在 .frm 文件中，后者存储在 .ibd 文件中，这一节就会对这两种不同的文件分别进行介绍。</p>
<p><strong>.frm</strong></p>
<p>无论在 MySQL 中选择了哪个存储引擎，所有的 MySQL 表都会在硬盘上创建一个 .frm 文件用来描述表的格式或者说定义； .frm 文件的格式在不同的平台上都是相同的。</p>
<p><strong>.ibd 文件</strong><br>InnoDB 中用于存储数据的文件总共有两个部分，一是系统表空间文件，包括 ibdata1、 ibdata2 等文件，其中存储了 InnoDB 系统信息和用户数据库表数据和索引，是所有表公用的。<br>当打开 innodb_file_per_table 选项时， .ibd 文件就是每一个表独有的表空间，文件存储了当前表的数据和相关的索引数据。</p>
<p><strong>表空间</strong><br>      innodb存储引擎在存储设计上模仿了Oracle的存储结构，其数据是按照表空间进行管理的。新建一个数据库时，innodb存储引擎会初始化一个名为ibdata1 的表空间文件，默认情况下，这个文件会存储所有表的数据，以及我们所熟知但看不到的系统表sys_tables、sys_columns、sys_indexes 、sys_fields等。此外，还会存储用来保证数据完整性的回滚段数据，当然这部分数据在新版本的MySQL中，已经可以通过参数来设置回滚段的存储位置了；</p>
<p>​    innodb存储引擎的设计很灵活，可以通过参数innodb_file_per_table来设置，使得每一个表都对应一个自己的独立表空间文件，而不是存储到公共的ibdata1文件中。独立的表空间文件之存储对应表的B+树数据、索引和插入缓冲等信息，其余信息还是存储在默认表空间中。</p>
<pre><code>这个文件所存储的内容主要就是B+树（索引），一个表可以有多个索引，也就是在一个文件中，可以存储多个索引，而如果一个表没有索引的话，用来存储数据的被称为聚簇索引，也就是说这也是一个索引。最终的结论是，ibd文件存储的就是一个表的所有索引数据。 索引文件有段（segment）,簇（extends）（有的文章翻译为区），页面（page）组成。</code></pre><p>  关于行记录格式，单独整理一篇。</p>
<p><strong>段（segment</strong><br>      段是表空间文件中的主要组织结构，它是一个逻辑概念，用来管理物理文件，是构成索引、表、回滚段的基本元素。<br>     上图中显示了表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等。InnoDB存储引擎表是索引组织的（index organized），因此数据即索引，索引即数据。那么数据段即为B+树的页节点（上图的leaf node segment），索引段即为B+树的非索引节点（上图的non-leaf node segment）。</p>
<p>   创建一个索引（B+树）时会同时创建两个段，分别是内节点段和叶子段，内节点段用来管理（存储）B+树非叶子（页面）的数据，叶子段用来管理（存储）B+树叶子节点的数据；也就是说，在索引数据量一直增长的过程中，所有新的存储空间的申请，都是从“段”这个概念中申请的。</p>
<p>  为了介绍索引为目的，所以不展开介绍回滚段等内容。</p>
<p><strong>区/簇（extents）</strong><br>     段是个逻辑概念，innodb引入了簇的概念，在代码中被称为extent；</p>
<pre><code>簇是由64个连续的页组成的，每个页大小为16KB，即每个簇的大小为1MB。簇是构成段的基本元素，一个段由若干个簇构成。一个簇是物理上连续分配的一个段空间，每一个段至少会有一个簇，在创建一个段时会创建一个默认的簇。如果存储数据时，一个簇已经不足以放下更多的数据，此时需要从这个段中分配一个新的簇来存放新的数据。一个段所管理的空间大小是无限的，可以一直扩展下去，但是扩展的最小单位就是簇。</code></pre><p><strong>页（page）</strong><br>InnoDB有页（page）的概念，可以理解为簇的细化。页是InnoDB磁盘管理的最小单位。</p>
<p>常见的页类型有：<br>数据页（B-tree Node）。<br>Undo页（Undo Log Page）。<br>系统页（System Page）。<br>事务数据页（Transaction system Page）。<br>插入缓冲位图页（Insert Buffer Bitmap）。<br>插入缓冲空闲列表页（Insert Buffer Free List）。<br>未压缩的二进制大对象页（Uncompressed BLOB Page）。<br>压缩的二进制大对象页（Compressed BLOB Page）。</p>
<pre><code>在逻辑上（页面号都是从小到大连续的）及物理上都是连续的。在向表中插入数据时，如果一个页面已经被写完，系统会从当前簇中分配一个新的空闲页面处理使用，如果当前簇中的64个页面都被分配完，系统会从当前页面所在段中分配一个新的簇，然后再从这个簇中分配一个新的页面来使用；</code></pre></blockquote>
<h4 id="页面，范围，段和表空间"><a href="#页面，范围，段和表空间" class="headerlink" title="页面，范围，段和表空间"></a>页面，范围，段和表空间</h4><p>每个表空间由数据库<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_page" target="_blank" rel="noopener">页面</a>组成 。MySQL实例中的每个表空间都具有相同的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_page_size" target="_blank" rel="noopener">页面大小</a>。默认情况下，所有表空间的页面大小均为16KB；您可以<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_page_size" target="_blank" rel="noopener"><code>innodb_page_size</code></a>在创建MySQL实例时通过指定选项将页面大小减小到8KB或4KB 。</p>
<p>这些页面分为 大小为1MB的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_extent" target="_blank" rel="noopener">扩展</a>区（64个连续的16KB页面，128个8KB页面或256个4KB页面）。在 “ 文件 ”表空间内被称为 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_segment" target="_blank" rel="noopener">段</a>在 <code>InnoDB</code>。（这些段与<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_rollback_segment" target="_blank" rel="noopener">回滚段</a>不同， <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_rollback_segment" target="_blank" rel="noopener">回滚段</a>实际上包含许多表空间段。）</p>
<p>当段在表空间内增长时， <code>InnoDB</code>将前32页一次分配给它。之后，<code>InnoDB</code>开始将整个扩展区分配给该段。<code>InnoDB</code> 一次最多可以向一个大段中添加4个扩展区，以确保数据的良好顺序。</p>
<p>为中的每个索引分配了两个段 <code>InnoDB</code>。一个用于 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_b_tree" target="_blank" rel="noopener">B树</a>的非叶节点，另一个用于叶节点。将叶子节点保持在磁盘上连续可以实现更好的顺序I / O操作，因为这些叶子节点包含实际的表数据。</p>
<p>表空间中的某些页面包含其他页面的位图，因此表空间中的某些扩展数据<code>InnoDB</code>块无法整体分配给段，而只能分配给单个页面。</p>
<p>当您通过发出一条<a href="https://dev.mysql.com/doc/refman/5.6/en/show-table-status.html" target="_blank" rel="noopener"><code>SHOW TABLE STATUS</code></a>语句在表空间中请求可用空间时，请 <code>InnoDB</code>报告表空间中绝对可用的扩展区。<code>InnoDB</code>始终保留一定程度的清理和其他内部用途；这些保留的范围不包括在可用空间中。</p>
<p>从表中删除数据时，将<code>InnoDB</code> 收缩相应的B树索引。释放的空间是否可供其他用户使用取决于删除模式是否将单个页面或扩展区释放到表空间中。删除表或删除表中的所有行可以保证将空间释放给其他用户，但请记住，删除的行仅通过<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_purge" target="_blank" rel="noopener">清除</a>操作才能物理删除， <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_purge" target="_blank" rel="noopener">清除</a>操作会在不再需要事务回滚或一致读取后的一段时间自动发生。 。（请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-multi-versioning.html" target="_blank" rel="noopener">第14.3节“ InnoDB多版本”</a>。）</p>
<p>要查看有关表空间的信息，请使用表空间监视器。请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-monitors.html" target="_blank" rel="noopener">第14.17节“ InnoDB监视器”</a>。</p>
<h4 id="页面如何与表格行相关"><a href="#页面如何与表格行相关" class="headerlink" title="页面如何与表格行相关"></a>页面如何与表格行相关</h4><p>最大行长度略小于数据库页面的一半。例如，对于默认的16KB <code>InnoDB</code>页面大小，最大行长度略小于8KB ，这是由<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_page_size" target="_blank" rel="noopener"><code>innodb_page_size</code></a> 配置选项定义的。</p>
<p>如果一行没有超过页面限制的一半，则所有行都将存储在页面内。如果某行超出了半页限制，那么 将选择<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_variable_length_type" target="_blank" rel="noopener">可变长度列</a>用于外部页外存储，直到该行适合半页之内。可变长度列的外部页外存储因行格式而异：</p>
<ul>
<li><p><em>紧凑和冗余行格式</em></p>
<p>当将可变长度列选择用于外部页外存储时，<code>InnoDB</code>将前768个字节本地存储在该行中，其余部分从外部存储到溢出页中。每个此类列都有其自己的溢出页面列表。768字节的前缀附带一个20字节的值，该值存储列的真实长度，并指向存储剩余值的溢出列表。请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-row-format.html" target="_blank" rel="noopener">第14.11节“ InnoDB行格式”</a>。</p>
</li>
<li><p><em>动态和压缩行格式</em></p>
<p>如果将可变长度列选择用于外部页外存储，<code>InnoDB</code>则在行中本地存储一个20字节的指针，其余部分在外部存储到溢出页中。请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-row-format.html" target="_blank" rel="noopener">第14.11节“ InnoDB行格式”</a>。</p>
</li>
</ul>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/blob.html" target="_blank" rel="noopener"><code>LONGBLOB</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.6/en/blob.html" target="_blank" rel="noopener"><code>LONGTEXT</code></a>列必须小于4GB，并且总行长（包括 <a href="https://dev.mysql.com/doc/refman/5.6/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.6/en/blob.html" target="_blank" rel="noopener"><code>TEXT</code></a>列）必须小于4GB。</p>
<h3 id="14-12-3-InnoDB检查点"><a href="#14-12-3-InnoDB检查点" class="headerlink" title="14.12.3 InnoDB检查点"></a>14.12.3 InnoDB检查点</h3><p>使你的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_log_file" target="_blank" rel="noopener">日志文件</a>非常大时可以减少磁盘I / O的 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_checkpoint" target="_blank" rel="noopener">检查点</a>。通常将日志文件的总大小设置为与缓冲池一样大，甚至更大。尽管从MySQL 5.5开始，过去大型日志文件可能会使崩溃恢复花费大量时间，但崩溃恢复的性能增强使崩溃后可以快速启动使用大型日志文件。（严格来说，对于具有InnoDB插件1.0.7和更高版本的MySQL 5.1，可以实现这种性能改进。对于MySQL 5.5，可以在默认的InnoDB存储引擎中实现此改进。）</p>
<h4 id="检查点处理的工作原理"><a href="#检查点处理的工作原理" class="headerlink" title="检查点处理的工作原理"></a>检查点处理的工作原理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InnoDB`实现称为[模糊检查点](https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_fuzzy_checkpointing)的 [检查点](https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_checkpoint)机制。小批量地从缓冲池中刷新已修改的数据库页面。无需单批刷新缓冲池，这会在检查点过程中中断用户SQL语句的处理。 `InnoDB</span><br></pre></td></tr></table></figure>

<p>在<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_crash_recovery" target="_blank" rel="noopener">崩溃恢复</a>期间， <code>InnoDB</code>查找写入日志文件的检查点标签。它知道在标签之前对数据库的所有修改都存在于数据库的磁盘映像中。然后<code>InnoDB</code>从检查点向前扫描日志文件，将记录的修改应用于数据库。</p>
<h3 id="14-12-4对表进行碎片整理"><a href="#14-12-4对表进行碎片整理" class="headerlink" title="14.12.4对表进行碎片整理"></a>14.12.4对表进行碎片整理</h3><p>随机插入二级索引或从二级索引中删除可能导致索引碎片化。碎片意味着磁盘上索引页的物理顺序与页面上记录的索引顺序不接近，或者64页块中有许多未使用的页已分配给索引。</p>
<p>碎片的一个症状是表占用的空间超过了它应 “占用”的空间。到底有多少是很难确定的。所有<code>InnoDB</code>数据和索引都存储在<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_b_tree" target="_blank" rel="noopener">B树中</a>，它们的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_fill_factor" target="_blank" rel="noopener">填充因子</a>可能在50％到100％之间变化。碎片化的另一个症状是，这样的表扫描花费的时间比“ 应该 ”花费的时间更多 ：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> non_indexed_column &lt;&gt; <span class="number">12345</span>;</span><br></pre></td></tr></table></figure>

<p>前面的查询要求MySQL执行全表扫描，这是大型表的最慢查询类型。</p>
<p>为了加快索引扫描的速度，您可以定期执行 “ null ” <a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a> 操作，这会导致MySQL重建表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span></span><br></pre></td></tr></table></figure>

<p>在MySQL 5.6.3中，你也可以使用 执行 “ 空 ”，重建表alter操作。以前，该选项已被识别但被忽略。 <a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE *</code>tbl_name<code>* FORCE</code></a><code>FORCE</code></p>
<p>在MySQL 5.6.17，双方 并 使用 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-online-ddl.html" target="_blank" rel="noopener">在线DDL</a>。有关更多信息，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-online-ddl.html" target="_blank" rel="noopener">第14.13节“ InnoDB和在线DDL”</a>。 <a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE *</code>tbl_name<code>* ENGINE=INNODB</code></a><a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE *</code>tbl_name<code>* FORCE</code></a></p>
<p>执行碎片整理操作的另一种方法是使用 <a href="https://dev.mysql.com/doc/refman/5.6/en/mysqldump.html" target="_blank" rel="noopener"><strong>mysqldump</strong></a>将表转储到文本文件，删除表并从转储文件重新加载它。</p>
<p>如果对索引的插入总是递增的，并且记录仅从末尾删除，则<code>InnoDB</code> 文件空间管理算法可确保不会发生索引中的碎片。</p>
<h3 id="14-12-5使用TRUNCATE-TABLE回收磁盘空间"><a href="#14-12-5使用TRUNCATE-TABLE回收磁盘空间" class="headerlink" title="14.12.5使用TRUNCATE TABLE回收磁盘空间"></a>14.12.5使用TRUNCATE TABLE回收磁盘空间</h3><p>当回收操作系统的磁盘空间 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_truncate" target="_blank" rel="noopener">截断</a>的 <code>InnoDB</code>表，该表必须存放在自己的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_ibd_file" target="_blank" rel="noopener">的.ibd</a>文件。若要将表存储在其自己的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_ibd_file" target="_blank" rel="noopener">.ibd</a> 文件中，<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a>必须在创建表时启用该表。此外，被截断的表和其他表之间不能有 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_foreign_key" target="_blank" rel="noopener">外键</a>约束，否则 <code>TRUNCATE TABLE</code>操作将失败。但是，允许在同一表的两列之间使用外键约束。</p>
<p>截断表后，将其删除并在新<code>.ibd</code>文件中重新创建 ，并将释放的空间返回给操作系统。这与<code>InnoDB</code>存储在 <code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_system_tablespace" target="_blank" rel="noopener">系统表空间</a> （在时创建的表 <code>innodb_file_per_table=OFF</code>）中<code>InnoDB</code>的表被截断相反 ，后者在表被截断后只能 使用释放的空间。</p>
<p>截断表并将磁盘空间返回给操作系统的能力还意味着 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_physical_backup" target="_blank" rel="noopener">物理备份</a>可以更小。截断存储在系统表空间中的表（时创建的表 <code>innodb_file_per_table=OFF</code>）在系统表空间中留下未使用空间的块。</p>
<br>

<h2 id="14-17-InnoDB监视器"><a href="#14-17-InnoDB监视器" class="headerlink" title="14.17 InnoDB监视器"></a>14.17 InnoDB监视器</h2><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-monitor-types.html" target="_blank" rel="noopener">14.17.1 InnoDB监视器类型</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-enabling-monitors.html" target="_blank" rel="noopener">14.17.2启用InnoDB监视器</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-standard-monitor.html" target="_blank" rel="noopener">14.17.3 InnoDB标准监视器和锁定监视器输出</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-tablespace-monitor.html" target="_blank" rel="noopener">14.17.4 InnoDB表空间监视器输出</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-table-monitor.html" target="_blank" rel="noopener">14.17.5 InnoDB表监视器输出</a></li>
</ul>
<p><code>InnoDB</code>监视器提供有关 <code>InnoDB</code>内部状态的信息。此信息对于性能调整很有用。</p>
<h3 id="14-17-1-InnoDB监视器类型"><a href="#14-17-1-InnoDB监视器类型" class="headerlink" title="14.17.1 InnoDB监视器类型"></a>14.17.1 InnoDB监视器类型</h3><p><code>InnoDB</code>监视器 有四种类型：</p>
<ul>
<li><p>标准<code>InnoDB</code>监视器显示以下类型的信息：</p>
<ul>
<li>主后台线程完成的工作</li>
<li>信号量等待</li>
<li>有关最新外键和死锁错误的数据</li>
<li>锁等待交易</li>
<li>活动交易持有的表和记录锁</li>
<li>待处理的I / O操作和相关统计信息</li>
<li>插入缓冲区和自适应哈希索引统计信息</li>
<li>Redo Log数据</li>
<li>缓冲池统计</li>
<li>行操作数据</li>
</ul>
</li>
<li><p>该<code>InnoDB</code>锁监控打印附加锁信息作为标准的一部分 <code>InnoDB</code>监视器输出。</p>
</li>
<li><p>的<code>InnoDB</code>表空间监视器打印在共享表文件的段的列表并验证表分配的数据结构。</p>
</li>
<li><p>该<code>InnoDB</code>表监控打印内容<code>InnoDB</code>的内部数据字典。</p>
<p>注意</p>
<p>Tablespace Monitor和Table Monitor已过时，并将在以后的MySQL版本中删除。可以从<code>InnoDB</code> <code>INFORMATION_SCHEMA</code>表中获得表监视器的类似信息 。请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-i_s-tables.html" target="_blank" rel="noopener">第21.30节“ INFORMATION_SCHEMA InnoDB表”</a>。</p>
</li>
</ul>
<p>有关<code>InnoDB</code>表和表空间监视器的其他信息，请参见 <a href="http://www.markleith.co.uk/?p=25" target="_blank" rel="noopener">Mark Leith：InnoDB表和表空间监视器</a>。</p>
<h3 id="14-17-2启用InnoDB监视器"><a href="#14-17-2启用InnoDB监视器" class="headerlink" title="14.17.2启用InnoDB监视器"></a>14.17.2启用InnoDB监视器</h3><p>当<code>InnoDB</code>监视器用于周期性输出使能，<code>InnoDB</code>将输出写入 <a href="https://dev.mysql.com/doc/refman/5.6/en/mysqld.html" target="_blank" rel="noopener"><strong>的mysqld</strong></a>服务器标准错误输出（<code>stderr</code>）每15秒，约。</p>
<p><code>InnoDB</code>将监视器的输出发送到 内存缓冲区，<code>stderr</code>而不是<code>stdout</code>固定大小的缓冲区，以免潜在的缓冲区溢出。</p>
<p>在Windows上，<code>stderr</code>除非另有配置，否则定向到默认日志文件。如果要将输出定向到控制台窗口而不是错误日志，请从控制台窗口中带有<a href="https://dev.mysql.com/doc/refman/5.6/en/server-options.html#option_mysqld_console" target="_blank" rel="noopener"><code>--console</code></a>选项的命令提示符启动服务器 。有关更多信息，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/error-log-windows.html" target="_blank" rel="noopener">第5.4.2.1节“ Windows上的错误记录”</a>。</p>
<p>在Unix和类似Unix的系统上，<code>stderr</code>除非另行配置，否则通常直接指向终端。有关更多信息，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/error-log-unix.html" target="_blank" rel="noopener">第5.4.2.2节“在Unix和类似Unix的系统上记录错误”</a>。</p>
<p><code>InnoDB</code>仅在您实际希望查看监视器信息时才应启用监视器，因为输出生成会导致性能降低。另外，如果将监视器输出定向到错误日志，则如果以后忘记通过删除监视器表来禁用监视器，则日志可能会变得很大。</p>
<p>注意</p>
<p>为了帮助进行故障排除，请在某些情况下<code>InnoDB</code> 临时启用标准<code>InnoDB</code>Monitor输出。有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-troubleshooting.html" target="_blank" rel="noopener">第14.21节“ InnoDB故障排除”</a>。</p>
<p>每个监视器都以包含时间戳和监视器名称的标题开头。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">=====================================</span><br><span class="line">2014-10-16 16:28:15 7feee43c5700 INNODB MONITOR OUTPUT</span><br><span class="line">=====================================</span><br></pre></td></tr></table></figure>

<p>标准<code>InnoDB</code>监视器（<code>INNODB MONITOR OUTPUT</code>）的标头也用于锁定监视器，因为锁定监视器在增加额外的锁定信息的情况下会产生相同的输出。</p>
<p>启用<code>InnoDB</code>标准监视器和锁定监视器以进行定期输出可以通过以下两种方法之一执行：</p>
<ul>
<li><p>使用<code>CREATE TABLE</code>语句创建<code>InnoDB</code>与监视器关联的特别命名的表。例如，要启用标准<code>InnoDB</code>Monitor，您将创建一个<code>InnoDB</code>名为的表 <code>innodb_monitor</code>。还使用该<code>CREATE TABLE</code>方法启用了表空间监视器和表监视器。</p>
<p>使用<a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>语法只是<code>InnoDB</code> 通过MySQL的SQL解析器将命令传递给引擎的一种方法。唯一重要的是表名以及它是一个<code>InnoDB</code> 表。表的结构与创建表的数据库无关。如果关闭服务器，则在重新启动服务器时监视器不会自动重新启动。删除监视器表并发出新的 <a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>语句以启动监视器。</p>
<p>注意</p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>启用<code>InnoDB</code>监视器 的方法已过时，将来的发行版中可能会删除该方法。从MySQL 5.6.16开始，您可以使用和 系统变量启用标准<code>InnoDB</code> Monitor和<code>InnoDB</code>Lock Monitor 。 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_status_output" target="_blank" rel="noopener"><code>innodb_status_output</code></a><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_status_output_locks" target="_blank" rel="noopener"><code>innodb_status_output_locks</code></a></p>
</li>
<li><p>使用 MySQL 5.6.16中引入的 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_status_output" target="_blank" rel="noopener"><code>innodb_status_output</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_status_output_locks" target="_blank" rel="noopener"><code>innodb_status_output_locks</code></a>系统变量。</p>
</li>
</ul>
<p>该<a href="https://dev.mysql.com/doc/refman/5.6/en/privileges-provided.html#priv_process" target="_blank" rel="noopener"><code>PROCESS</code></a>权限才能启用或禁用<code>InnoDB</code>监视器。</p>
<h4 id="启用标准InnoDB监视器"><a href="#启用标准InnoDB监视器" class="headerlink" title="启用标准InnoDB监视器"></a>启用标准InnoDB监视器</h4><p>要启用标准InnoDB Monitor的定期输出，请创建<code>innodb_monitor</code>表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> innodb_monitor (a <span class="built_in">INT</span>) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span>;</span><br></pre></td></tr></table></figure>

<p>要禁用标准<code>InnoDB</code>监视器，请删除表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> innodb_monitor;</span><br></pre></td></tr></table></figure>

<p>从MySQL 5.6.16开始，您还可以<code>InnoDB</code>通过将<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_status_output" target="_blank" rel="noopener"><code>innodb_status_output</code></a>系统变量设置为来启用标准 Monitor <code>ON</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> innodb_status_output=<span class="keyword">ON</span>;</span><br></pre></td></tr></table></figure>

<p>要禁用标准<code>InnoDB</code>监视器，请设置 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_status_output" target="_blank" rel="noopener"><code>innodb_status_output</code></a>为 <code>OFF</code>。</p>
<p>关闭服务器时，该 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_status_output" target="_blank" rel="noopener"><code>innodb_status_output</code></a>变量将设置为默认<code>OFF</code>值。</p>
<h4 id="启用InnoDB锁定监视器"><a href="#启用InnoDB锁定监视器" class="headerlink" title="启用InnoDB锁定监视器"></a>启用InnoDB锁定监视器</h4><p>要启用<code>InnoDB</code>锁定监视器以进行定期输出，请创建<code>innodb_lock_monitor</code>表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> innodb_lock_monitor (a <span class="built_in">INT</span>) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span>;</span><br></pre></td></tr></table></figure>

<p>要禁用<code>InnoDB</code>锁定监视器，请删除表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> innodb_lock_monitor;</span><br></pre></td></tr></table></figure>

<p>从MySQL 5.6.16开始，您还可以<code>InnoDB</code>通过将<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_status_output_locks" target="_blank" rel="noopener"><code>innodb_status_output_locks</code></a>系统变量设置为来启用 锁定监视器 <code>ON</code>。与<a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>启用<code>InnoDB</code>监视器 的 方法一样， 必须同时启用<code>InnoDB</code>标准监视器和 <code>InnoDB</code>锁定监视器，才能 <code>InnoDB</code>定期打印锁定监视器数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> innodb_status_output=<span class="keyword">ON</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> innodb_status_output_locks=<span class="keyword">ON</span>;</span><br></pre></td></tr></table></figure>

<p>关闭服务器时， <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_status_output" target="_blank" rel="noopener"><code>innodb_status_output</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_status_output_locks" target="_blank" rel="noopener"><code>innodb_status_output_locks</code></a> 变量将设置为默认<code>OFF</code>值。</p>
<p>要禁用<code>InnoDB</code>锁定监视器，请设置 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_status_output_locks" target="_blank" rel="noopener"><code>innodb_status_output_locks</code></a>为 <code>OFF</code>。设置 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_status_output" target="_blank" rel="noopener"><code>innodb_status_output</code></a>为OFF也将禁用标准<code>InnoDB</code>监视器。</p>
<p>注意</p>
<p>要启用<code>InnoDB</code>锁定监视器的 <a href="https://dev.mysql.com/doc/refman/5.6/en/show-engine.html" target="_blank" rel="noopener"><code>SHOW ENGINE INNODB STATUS</code></a>输出，只需启用 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_status_output_locks" target="_blank" rel="noopener"><code>innodb_status_output_locks</code></a>。</p>
<h4 id="获得标准的InnoDB监视器按需输出"><a href="#获得标准的InnoDB监视器按需输出" class="headerlink" title="获得标准的InnoDB监视器按需输出"></a>获得标准的InnoDB监视器按需输出</h4><p>作为启用标准<code>InnoDB</code>Monitor定期输出的替代方法 ，您可以<code>InnoDB</code>使用<a href="https://dev.mysql.com/doc/refman/5.6/en/show-engine.html" target="_blank" rel="noopener"><code>SHOW ENGINE INNODB STATUS</code></a>SQL语句按需获取标准Monitor输出，该语句将输出提取到客户端程序。如果您使用的是<a href="https://dev.mysql.com/doc/refman/5.6/en/mysql.html" target="_blank" rel="noopener"><strong>mysql</strong></a> 交互式客户端，则将常用的分号语句终止符替换为，则输出更具可读性<code>\G</code>：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW ENGINE INNODB STATUS\G</span><br></pre></td></tr></table></figure>

<p><a href="https://dev.mysql.com/doc/refman/5.6/en/show-engine.html" target="_blank" rel="noopener"><code>SHOW ENGINE INNODB STATUS</code></a><code>InnoDB</code> 如果<code>InnoDB</code>启用了锁定监视器，则输出还包括锁定监视器数据。</p>
<h4 id="将标准InnoDB监视器输出定向到状态文件"><a href="#将标准InnoDB监视器输出定向到状态文件" class="headerlink" title="将标准InnoDB监视器输出定向到状态文件"></a>将标准InnoDB监视器输出定向到状态文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InnoDB`通过`--innodb-status-file`在启动时指定选项，可以启用 标准监视器输出并将其定向到状态文件 。使用此选项时，`InnoDB`将 在数据目录中创建一个名称为文件的文件 ，并大约每15秒将输出写入其中。 `innodb_status.*`pid`*</span><br></pre></td></tr></table></figure>

<p><code>InnoDB</code>正常关闭服务器后，将删除状态文件。如果发生异常关闭，则可能必须手动删除状态文件。</p>
<p>该<code>--innodb-status-file</code>选项仅供临时使用，因为输出生成会影响性能，并且 文件会随着时间变得很大。 <code>innodb_status.*</code>pid<code>*</code></p>
<h4 id="启用InnoDB表空间监视器"><a href="#启用InnoDB表空间监视器" class="headerlink" title="启用InnoDB表空间监视器"></a>启用InnoDB表空间监视器</h4><p>要为<code>InnoDB</code>表空间监视器启用定期输出，请创建 <code>innodb_tablespace_monitor</code>表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> innodb_tablespace_monitor (a <span class="built_in">INT</span>) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span>;</span><br></pre></td></tr></table></figure>

<p>要禁用标准<code>InnoDB</code>表空间监视器，请删除表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> innodb_tablespace_monitor;</span><br></pre></td></tr></table></figure>

<p>注意</p>
<p>Tablespace Monitor已弃用，并将在以后的MySQL版本中删除。</p>
<h4 id="启用InnoDB表监视器"><a href="#启用InnoDB表监视器" class="headerlink" title="启用InnoDB表监视器"></a>启用InnoDB表监视器</h4><p>要为<code>InnoDB</code>表监视器启用定期输出，请创建<code>innodb_table_monitor</code>表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> innodb_table_monitor (a <span class="built_in">INT</span>) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span>;</span><br></pre></td></tr></table></figure>

<p>要禁用<code>InnoDB</code>表监视器，请删除表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> innodb_table_monitor;</span><br></pre></td></tr></table></figure>

<p>注意</p>
<p>Tablespace Monitor已弃用，并将在以后的MySQL版本中删除。</p>
<h3 id="14-17-3-InnoDB标准监视器和锁定监视器输出"><a href="#14-17-3-InnoDB标准监视器和锁定监视器输出" class="headerlink" title="14.17.3 InnoDB标准监视器和锁定监视器输出"></a>14.17.3 InnoDB标准监视器和锁定监视器输出</h3><p>锁定监视器与标准监视器相同，只是它包含其他锁定信息。为任一监视器启用定期输出会打开同一输出流，但是如果启用了锁定监视器，则该流将包含其他信息。例如，如果启用“标准监视器”和“锁定监视器”，则将打开单个输出流。在禁用锁定监视器之前，流中将包含其他锁定信息。</p>
<p>使用该<a href="https://dev.mysql.com/doc/refman/5.6/en/show-engine.html" target="_blank" rel="noopener"><code>SHOW ENGINE INNODB STATUS</code></a>语句生成时，Standard Monitor的输出限制为1MB 。此限制不适用于写入服务器标准错误输出（<code>stderr</code>）的输出。</p>
<p>标准监视器输出示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW ENGINE INNODB STATUS\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Type: InnoDB</span><br><span class="line">  Name:</span><br><span class="line">Status:</span><br><span class="line">=====================================</span><br><span class="line">2014-10-17 10:33:50 7f47bcd64700 INNODB MONITOR OUTPUT</span><br><span class="line">=====================================</span><br><span class="line">Per second averages calculated from the last 6 seconds</span><br><span class="line"><span class="comment">-----------------</span></span><br><span class="line">BACKGROUND THREAD</span><br><span class="line"><span class="comment">-----------------</span></span><br><span class="line">srv_master_thread loops: 167 srv_active, 0 srv_shutdown, 3023 srv_idle</span><br><span class="line">srv_master_thread log <span class="keyword">flush</span> <span class="keyword">and</span> writes: <span class="number">3190</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">SEMAPHORES</span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">OS <span class="keyword">WAIT</span> <span class="built_in">ARRAY</span> INFO: reservation <span class="keyword">count</span> <span class="number">1040</span></span><br><span class="line">OS <span class="keyword">WAIT</span> <span class="built_in">ARRAY</span> INFO: signal <span class="keyword">count</span> <span class="number">959</span></span><br><span class="line"><span class="keyword">Mutex</span> spin waits <span class="number">677</span>, rounds <span class="number">20336</span>, OS waits <span class="number">644</span></span><br><span class="line">RW-<span class="keyword">shared</span> spins <span class="number">180</span>, rounds <span class="number">5400</span>, OS waits <span class="number">180</span></span><br><span class="line">RW-excl spins <span class="number">0</span>, rounds <span class="number">6420</span>, OS waits <span class="number">214</span></span><br><span class="line">Spin rounds per <span class="keyword">wait</span>: <span class="number">30.04</span> <span class="keyword">mutex</span>, <span class="number">30.00</span> RW-<span class="keyword">shared</span>, <span class="number">6420.00</span> RW-excl</span><br><span class="line"><span class="comment">------------------------</span></span><br><span class="line">LATEST <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> <span class="keyword">ERROR</span></span><br><span class="line"><span class="comment">------------------------</span></span><br><span class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-17</span> <span class="number">09</span>:<span class="number">51</span>:<span class="number">31</span> <span class="number">7</span>f47bcde6700 <span class="keyword">Transaction</span>:</span><br><span class="line"><span class="keyword">TRANSACTION</span> <span class="number">436786</span>, ACTIVE <span class="number">0</span> sec inserting</span><br><span class="line">mysql <span class="keyword">tables</span> <span class="keyword">in</span> <span class="keyword">use</span> <span class="number">1</span>, <span class="keyword">locked</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">lock</span> <span class="keyword">struct</span>(s), <span class="keyword">heap</span> <span class="keyword">size</span> <span class="number">1184</span>, <span class="number">3</span> <span class="keyword">row</span> <span class="keyword">lock</span>(s), <span class="keyword">undo</span> <span class="keyword">log</span> entries <span class="number">3</span></span><br><span class="line">MySQL <span class="keyword">thread</span> <span class="keyword">id</span> <span class="number">1</span>, OS <span class="keyword">thread</span> handle <span class="number">0x7f47bcde6700</span>, <span class="keyword">query</span> <span class="keyword">id</span> <span class="number">96</span> localhost</span><br><span class="line">root <span class="keyword">update</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">child</span> <span class="keyword">VALUES</span></span><br><span class="line">    (<span class="literal">NULL</span>, <span class="number">1</span>)</span><br><span class="line">    , (<span class="literal">NULL</span>, <span class="number">2</span>)</span><br><span class="line">    , (<span class="literal">NULL</span>, <span class="number">3</span>)</span><br><span class="line">    , (<span class="literal">NULL</span>, <span class="number">4</span>)</span><br><span class="line">    , (<span class="literal">NULL</span>, <span class="number">5</span>)</span><br><span class="line">    , (<span class="literal">NULL</span>, <span class="number">6</span>)</span><br><span class="line"><span class="keyword">Foreign</span> <span class="keyword">key</span> <span class="keyword">constraint</span> fails <span class="keyword">for</span> <span class="keyword">table</span> <span class="string">`mysql`</span>.<span class="string">`child`</span>:</span><br><span class="line">,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`child_ibfk_1`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`parent_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`parent`</span></span><br><span class="line">  (<span class="string">`id`</span>)</span><br><span class="line"> <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span></span><br><span class="line">Trying <span class="keyword">to</span> <span class="keyword">add</span> <span class="keyword">in</span> <span class="keyword">child</span> <span class="keyword">table</span>, <span class="keyword">in</span> <span class="keyword">index</span> <span class="string">`par_ind`</span> tuple:</span><br><span class="line"><span class="keyword">DATA</span> TUPLE: <span class="number">2</span> <span class="keyword">fields</span>;</span><br><span class="line"> 0: len 4; hex 80000003; asc     ;;</span><br><span class="line"> 1: len 4; hex 80000003; asc     ;;</span><br><span class="line"></span><br><span class="line">But in parent table `mysql`.`parent`, in index `PRIMARY`,</span><br><span class="line">the closest match we can find is record:</span><br><span class="line">PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 80000004; asc     ;;</span><br><span class="line"> 1: len 6; hex 00000006aa26; asc      &amp;;;</span><br><span class="line"> 2: len 7; hex 9d000001610137; asc     a 7;;</span><br><span class="line"><span class="comment">------------------------</span></span><br><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line"><span class="comment">------------------------</span></span><br><span class="line">2014-10-17 09:52:38 7f47bcde6700</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 436801, ACTIVE 12 sec starting index read</span><br><span class="line">mysql tables in <span class="keyword">use</span> <span class="number">1</span>, <span class="keyword">locked</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">LOCK</span> <span class="keyword">WAIT</span> <span class="number">2</span> <span class="keyword">lock</span> <span class="keyword">struct</span>(s), <span class="keyword">heap</span> <span class="keyword">size</span> <span class="number">360</span>, <span class="number">1</span> <span class="keyword">row</span> <span class="keyword">lock</span>(s)</span><br><span class="line">MySQL <span class="keyword">thread</span> <span class="keyword">id</span> <span class="number">2</span>, OS <span class="keyword">thread</span> handle <span class="number">0x7f47bcda5700</span>, <span class="keyword">query</span> <span class="keyword">id</span> <span class="number">102</span> localhost</span><br><span class="line">root updating</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> i = <span class="number">1</span></span><br><span class="line">*** (<span class="number">1</span>) WAITING <span class="keyword">FOR</span> THIS <span class="keyword">LOCK</span> <span class="keyword">TO</span> BE GRANTED:</span><br><span class="line"><span class="built_in">RECORD</span> LOCKS <span class="keyword">space</span> <span class="keyword">id</span> <span class="number">3693</span> page <span class="keyword">no</span> <span class="number">3</span> n bits <span class="number">72</span> <span class="keyword">index</span> <span class="string">`GEN_CLUST_INDEX`</span> <span class="keyword">of</span></span><br><span class="line"><span class="keyword">table</span> <span class="string">`mysql`</span>.<span class="string">`t`</span> trx <span class="keyword">id</span> <span class="number">436801</span> lock_mode X waiting</span><br><span class="line"><span class="built_in">Record</span> <span class="keyword">lock</span>, <span class="keyword">heap</span> <span class="keyword">no</span> <span class="number">2</span> <span class="keyword">PHYSICAL</span> <span class="built_in">RECORD</span>: n_fields <span class="number">4</span>; compact format; info</span><br><span class="line">bits 0</span><br><span class="line"> 0: len 6; hex 000000003a00; asc     : ;;</span><br><span class="line"> 1: len 6; hex 00000006aa3f; asc      ?;;</span><br><span class="line"> 2: len 7; hex ad0000021d0110; asc        ;;</span><br><span class="line"> 3: len 4; hex 80000001; asc     ;;</span><br><span class="line"></span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 436800, ACTIVE 34 sec starting index read</span><br><span class="line">mysql tables in <span class="keyword">use</span> <span class="number">1</span>, <span class="keyword">locked</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">lock</span> <span class="keyword">struct</span>(s), <span class="keyword">heap</span> <span class="keyword">size</span> <span class="number">1184</span>, <span class="number">3</span> <span class="keyword">row</span> <span class="keyword">lock</span>(s)</span><br><span class="line">MySQL <span class="keyword">thread</span> <span class="keyword">id</span> <span class="number">1</span>, OS <span class="keyword">thread</span> handle <span class="number">0x7f47bcde6700</span>, <span class="keyword">query</span> <span class="keyword">id</span> <span class="number">103</span> localhost</span><br><span class="line">root updating</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> i = <span class="number">1</span></span><br><span class="line">*** (<span class="number">2</span>) HOLDS THE <span class="keyword">LOCK</span>(S):</span><br><span class="line"><span class="built_in">RECORD</span> LOCKS <span class="keyword">space</span> <span class="keyword">id</span> <span class="number">3693</span> page <span class="keyword">no</span> <span class="number">3</span> n bits <span class="number">72</span> <span class="keyword">index</span> <span class="string">`GEN_CLUST_INDEX`</span> <span class="keyword">of</span></span><br><span class="line"><span class="keyword">table</span> <span class="string">`mysql`</span>.<span class="string">`t`</span> trx <span class="keyword">id</span> <span class="number">436800</span> <span class="keyword">lock</span> <span class="keyword">mode</span> S</span><br><span class="line"><span class="built_in">Record</span> <span class="keyword">lock</span>, <span class="keyword">heap</span> <span class="keyword">no</span> <span class="number">1</span> <span class="keyword">PHYSICAL</span> <span class="built_in">RECORD</span>: n_fields <span class="number">1</span>; compact format; info</span><br><span class="line">bits 0 0: len 8; hex 73757072656d756d; asc supremum;;</span><br><span class="line"></span><br><span class="line">Record <span class="keyword">lock</span>, <span class="keyword">heap</span> <span class="keyword">no</span> <span class="number">2</span> <span class="keyword">PHYSICAL</span> <span class="built_in">RECORD</span>: n_fields <span class="number">4</span>; compact format; info</span><br><span class="line">bits 0</span><br><span class="line"> 0: len 6; hex 000000003a00; asc     : ;;</span><br><span class="line"> 1: len 6; hex 00000006aa3f; asc      ?;;</span><br><span class="line"> 2: len 7; hex ad0000021d0110; asc        ;;</span><br><span class="line"> 3: len 4; hex 80000001; asc     ;;</span><br><span class="line"></span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 3693 page no 3 n bits 72 index `GEN_CLUST_INDEX` of</span><br><span class="line">table `mysql`.`t` trx id 436800 lock_mode X waiting</span><br><span class="line">Record <span class="keyword">lock</span>, <span class="keyword">heap</span> <span class="keyword">no</span> <span class="number">2</span> <span class="keyword">PHYSICAL</span> <span class="built_in">RECORD</span>: n_fields <span class="number">4</span>; compact format; info</span><br><span class="line">bits 0</span><br><span class="line"> 0: len 6; hex 000000003a00; asc     : ;;</span><br><span class="line"> 1: len 6; hex 00000006aa3f; asc      ?;;</span><br><span class="line"> 2: len 7; hex ad0000021d0110; asc        ;;</span><br><span class="line"> 3: len 4; hex 80000001; asc     ;;</span><br><span class="line"></span><br><span class="line">*** WE ROLL BACK TRANSACTION (1)</span><br><span class="line"><span class="comment">------------</span></span><br><span class="line">TRANSACTIONS</span><br><span class="line"><span class="comment">------------</span></span><br><span class="line">Trx id counter 437661</span><br><span class="line"><span class="keyword">Purge</span> done <span class="keyword">for</span> trx<span class="string">'s n:o &lt; 437657 undo n:o &lt; 0 state: running but</span></span><br><span class="line"><span class="string">idle History list length 371</span></span><br><span class="line"><span class="string">LIST OF TRANSACTIONS FOR EACH SESSION:</span></span><br><span class="line"><span class="string">---TRANSACTION 0, not started</span></span><br><span class="line"><span class="string">MySQL thread id 10, OS thread handle 0x7f47bcd64700, query id 1001 localhost</span></span><br><span class="line"><span class="string">root init</span></span><br><span class="line"><span class="string">SHOW ENGINE INNODB STATUS</span></span><br><span class="line"><span class="string">---TRANSACTION 436801, not started</span></span><br><span class="line"><span class="string">MySQL thread id 2, OS thread handle 0x7f47bcda5700, query id 102 localhost</span></span><br><span class="line"><span class="string">root ceaning up</span></span><br><span class="line"><span class="string">---TRANSACTION 437660, ACTIVE 0 sec inserting</span></span><br><span class="line"><span class="string">mysql tables in use 1, locked 1</span></span><br><span class="line"><span class="string">43 lock struct(s), heap size 6544, 6474 row lock(s), undo log entries 7124</span></span><br><span class="line"><span class="string">MySQL thread id 14, OS thread handle 0x7f47bcde6700, query id 1000 localhost</span></span><br><span class="line"><span class="string">root update</span></span><br><span class="line"><span class="string">INSERT INTO `dept_emp` VALUES (100258,'</span>d002<span class="string">','</span><span class="number">1994</span><span class="number">-03</span><span class="number">-21</span><span class="string">','</span><span class="number">9999</span><span class="number">-01</span><span class="number">-01</span><span class="string">'),</span></span><br><span class="line"><span class="string">(100259, '</span>d005<span class="string">','</span><span class="number">1998</span><span class="number">-11</span><span class="number">-04</span><span class="string">','</span><span class="number">9999</span><span class="number">-01</span><span class="number">-01</span><span class="string">'),(100259,'</span>d008<span class="string">','</span><span class="number">1988</span><span class="number">-02</span><span class="number">-03</span><span class="string">',</span></span><br><span class="line"><span class="string">'</span><span class="number">1998</span><span class="number">-11</span><span class="number">-04</span><span class="string">'),(100 260,'</span>d005<span class="string">','</span><span class="number">1998</span><span class="number">-09</span><span class="number">-18</span><span class="string">','</span><span class="number">9999</span><span class="number">-01</span><span class="number">-01</span><span class="string">'),(100261,'</span>d004<span class="string">',</span></span><br><span class="line"><span class="string">'</span><span class="number">1989</span><span class="number">-03</span><span class="number">-11</span><span class="string">','</span><span class="number">9999</span><span class="number">-01</span><span class="number">-01</span><span class="string">'), (100262,'</span>d008<span class="string">','</span><span class="number">1996</span><span class="number">-08</span><span class="number">-12</span><span class="string">','</span><span class="number">9999</span><span class="number">-01</span><span class="number">-01</span><span class="string">'),</span></span><br><span class="line"><span class="string">(100263,'</span>d002<span class="string">','</span><span class="number">1998</span><span class="number">-06</span><span class="number">-24</span><span class="string">','</span><span class="number">1998</span><span class="number">-10</span><span class="number">-0</span> <span class="number">5</span><span class="string">'),(100264,'</span>d005<span class="string">','</span><span class="number">1989</span><span class="number">-11</span><span class="number">-09</span><span class="string">',</span></span><br><span class="line"><span class="string">'</span><span class="number">9999</span><span class="number">-01</span><span class="number">-01</span><span class="string">'),(100265,'</span>d001<span class="string">','</span><span class="number">1992</span><span class="number">-06</span><span class="number">-27</span><span class="string">','</span><span class="number">9999</span>- <span class="number">01</span><span class="number">-01</span><span class="string">'),(100266,'</span>d009<span class="string">',</span></span><br><span class="line"><span class="string">'</span><span class="number">1990</span><span class="number">-09</span><span class="number">-10</span><span class="string">','</span><span class="number">9999</span><span class="number">-01</span><span class="number">-01</span><span class="string">'),(100267,'</span>d009<span class="string">','</span><span class="number">1992</span><span class="number">-04</span><span class="number">-14</span><span class="string">','</span><span class="number">9</span> <span class="number">999</span><span class="number">-01</span><span class="number">-01</span><span class="string">'),</span></span><br><span class="line"><span class="string">(100268,'</span>d005<span class="string">','</span><span class="number">1998</span><span class="number">-05</span><span class="number">-01</span><span class="string">','</span><span class="number">2000</span><span class="number">-04</span><span class="number">-07</span><span class="string">'),(100269,'</span>d007<span class="string">','</span><span class="number">1994</span><span class="number">-01</span><span class="number">-02</span><span class="string">',</span></span><br><span class="line"><span class="string">'</span><span class="number">1999</span><span class="number">-09</span><span class="number">-18</span><span class="string">'),(100269,'</span>d009<span class="string">','</span><span class="number">1999</span><span class="number">-09</span>-</span><br><span class="line"><span class="comment">--------</span></span><br><span class="line"><span class="keyword">FILE</span> I/O</span><br><span class="line"><span class="comment">--------</span></span><br><span class="line">I/O <span class="keyword">thread</span> <span class="number">0</span> state: waiting <span class="keyword">for</span> completed aio requests (<span class="keyword">insert</span> buffer <span class="keyword">thread</span>)</span><br><span class="line">I/O <span class="keyword">thread</span> <span class="number">1</span> state: waiting <span class="keyword">for</span> completed aio requests (<span class="keyword">log</span> <span class="keyword">thread</span>)</span><br><span class="line">I/O <span class="keyword">thread</span> <span class="number">2</span> state: waiting <span class="keyword">for</span> completed aio requests (<span class="keyword">read</span> <span class="keyword">thread</span>)</span><br><span class="line">I/O <span class="keyword">thread</span> <span class="number">3</span> state: waiting <span class="keyword">for</span> completed aio requests (<span class="keyword">read</span> <span class="keyword">thread</span>)</span><br><span class="line">I/O <span class="keyword">thread</span> <span class="number">4</span> state: waiting <span class="keyword">for</span> completed aio requests (<span class="keyword">read</span> <span class="keyword">thread</span>)</span><br><span class="line">I/O <span class="keyword">thread</span> <span class="number">5</span> state: waiting <span class="keyword">for</span> completed aio requests (<span class="keyword">read</span> <span class="keyword">thread</span>)</span><br><span class="line">I/O <span class="keyword">thread</span> <span class="number">6</span> state: waiting <span class="keyword">for</span> completed aio requests (write <span class="keyword">thread</span>)</span><br><span class="line">I/O <span class="keyword">thread</span> <span class="number">7</span> state: waiting <span class="keyword">for</span> completed aio requests (write <span class="keyword">thread</span>)</span><br><span class="line">I/O <span class="keyword">thread</span> <span class="number">8</span> state: waiting <span class="keyword">for</span> completed aio requests (write <span class="keyword">thread</span>)</span><br><span class="line">I/O <span class="keyword">thread</span> <span class="number">9</span> state: waiting <span class="keyword">for</span> completed aio requests (write <span class="keyword">thread</span>)</span><br><span class="line">Pending <span class="keyword">normal</span> aio <span class="keyword">reads</span>: <span class="number">0</span> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>] , aio writes: <span class="number">0</span> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>] ,</span><br><span class="line"> ibuf aio <span class="keyword">reads</span>: <span class="number">0</span>, <span class="keyword">log</span> i/o<span class="string">'s: 0, sync i/o'</span>s: <span class="number">0</span></span><br><span class="line">Pending flushes (fsync) <span class="keyword">log</span>: <span class="number">0</span>; buffer pool: 0</span><br><span class="line">344 OS file reads, 45666 OS file writes, 4030 OS fsyncs</span><br><span class="line">0.00 reads/s, 0 avg bytes/read, 202.80 writes/s, 48.33 fsyncs/s</span><br><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> BUFFER <span class="keyword">AND</span> ADAPTIVE <span class="keyword">HASH</span> <span class="keyword">INDEX</span></span><br><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line">Ibuf: <span class="keyword">size</span> <span class="number">1</span>, free <span class="keyword">list</span> <span class="keyword">len</span> <span class="number">0</span>, seg <span class="keyword">size</span> <span class="number">2</span>, <span class="number">0</span> merges</span><br><span class="line">merged <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br><span class="line">discarded <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">4425293</span>, node <span class="keyword">heap</span> has <span class="number">143</span> buffer(s)</span><br><span class="line"><span class="number">137083.82</span> <span class="keyword">hash</span> searches/s, <span class="number">2495.92</span> non-<span class="keyword">hash</span> searches/s</span><br><span class="line"><span class="comment">---</span></span><br><span class="line"><span class="keyword">LOG</span></span><br><span class="line"><span class="comment">---</span></span><br><span class="line"><span class="keyword">Log</span> <span class="keyword">sequence</span> <span class="built_in">number</span> <span class="number">3091027710</span></span><br><span class="line"><span class="keyword">Log</span> flushed up <span class="keyword">to</span>   <span class="number">3090240098</span></span><br><span class="line">Pages flushed up <span class="keyword">to</span> <span class="number">3074432960</span></span><br><span class="line"><span class="keyword">Last</span> checkpoint <span class="keyword">at</span>  <span class="number">3050856266</span></span><br><span class="line"><span class="number">0</span> pending <span class="keyword">log</span> writes, <span class="number">0</span> pending chkp writes</span><br><span class="line"><span class="number">1187</span> <span class="keyword">log</span> i/o<span class="string">'s done, 14.67 log i/o'</span>s/<span class="keyword">second</span></span><br><span class="line"><span class="comment">----------------------</span></span><br><span class="line">BUFFER POOL <span class="keyword">AND</span> <span class="keyword">MEMORY</span></span><br><span class="line"><span class="comment">----------------------</span></span><br><span class="line">Total <span class="keyword">memory</span> allocated <span class="number">2197815296</span>; in additional pool allocated 0</span><br><span class="line">Dictionary memory allocated 155455</span><br><span class="line">Buffer pool size   131071</span><br><span class="line">Free buffers       92158</span><br><span class="line">Database pages     38770</span><br><span class="line">Old database pages 14271</span><br><span class="line">Modified db pages  619</span><br><span class="line">Pending reads 0</span><br><span class="line">Pending writes: LRU 0, <span class="keyword">flush</span> <span class="keyword">list</span> <span class="number">0</span>, single page <span class="number">0</span></span><br><span class="line">Pages made young <span class="number">4</span>, <span class="keyword">not</span> young <span class="number">0</span></span><br><span class="line"><span class="number">0.00</span> youngs/s, <span class="number">0.00</span> non-youngs/s</span><br><span class="line">Pages <span class="keyword">read</span> <span class="number">322</span>, created <span class="number">38448</span>, written <span class="number">42083</span></span><br><span class="line"><span class="number">0.00</span> <span class="keyword">reads</span>/s, <span class="number">222.30</span> creates/s, <span class="number">159.47</span> writes/s</span><br><span class="line">Buffer pool hit rate <span class="number">1000</span> / <span class="number">1000</span>, young-making rate <span class="number">0</span> / <span class="number">1000</span> <span class="keyword">not</span> <span class="number">0</span> / <span class="number">1000</span></span><br><span class="line">Pages <span class="keyword">read</span> ahead <span class="number">0.00</span>/s, evicted <span class="keyword">without</span> <span class="keyword">access</span> <span class="number">0.00</span>/s, Random <span class="keyword">read</span> ahead</span><br><span class="line"><span class="number">0.00</span>/s</span><br><span class="line">LRU <span class="keyword">len</span>: <span class="number">38770</span>, unzip_LRU <span class="keyword">len</span>: <span class="number">0</span></span><br><span class="line">I/O <span class="keyword">sum</span>[<span class="number">0</span>]:cur[<span class="number">0</span>], unzip <span class="keyword">sum</span>[<span class="number">0</span>]:cur[<span class="number">0</span>]</span><br><span class="line"><span class="comment">----------------------</span></span><br><span class="line">INDIVIDUAL BUFFER POOL INFO</span><br><span class="line"><span class="comment">----------------------</span></span><br><span class="line"><span class="comment">---BUFFER POOL 0</span></span><br><span class="line">Buffer pool <span class="keyword">size</span>   <span class="number">65536</span></span><br><span class="line">Free buffers       <span class="number">46120</span></span><br><span class="line"><span class="keyword">Database</span> pages     <span class="number">19345</span></span><br><span class="line"><span class="keyword">Old</span> <span class="keyword">database</span> pages <span class="number">7121</span></span><br><span class="line">Modified db pages  <span class="number">291</span></span><br><span class="line">Pending <span class="keyword">reads</span> <span class="number">0</span></span><br><span class="line">Pending writes: LRU <span class="number">0</span>, <span class="keyword">flush</span> <span class="keyword">list</span> <span class="number">0</span>, single page <span class="number">0</span></span><br><span class="line">Pages made young <span class="number">3</span>, <span class="keyword">not</span> young <span class="number">0</span></span><br><span class="line"><span class="number">0.00</span> youngs/s, <span class="number">0.00</span> non-youngs/s</span><br><span class="line">Pages <span class="keyword">read</span> <span class="number">163</span>, created <span class="number">19182</span>, written <span class="number">21149</span></span><br><span class="line"><span class="number">0.00</span> <span class="keyword">reads</span>/s, <span class="number">103.48</span> creates/s, <span class="number">83.15</span> writes/s</span><br><span class="line">Buffer pool hit rate <span class="number">1000</span> / <span class="number">1000</span>, young-making rate <span class="number">0</span> / <span class="number">1000</span> <span class="keyword">not</span> <span class="number">0</span> / <span class="number">1000</span></span><br><span class="line">Pages <span class="keyword">read</span> ahead <span class="number">0.00</span>/s, evicted <span class="keyword">without</span> <span class="keyword">access</span> <span class="number">0.00</span>/s, Random <span class="keyword">read</span> ahead</span><br><span class="line"><span class="number">0.00</span>/s</span><br><span class="line">LRU <span class="keyword">len</span>: <span class="number">19345</span>, unzip_LRU <span class="keyword">len</span>: <span class="number">0</span></span><br><span class="line">I/O <span class="keyword">sum</span>[<span class="number">0</span>]:cur[<span class="number">0</span>], unzip <span class="keyword">sum</span>[<span class="number">0</span>]:cur[<span class="number">0</span>]</span><br><span class="line"><span class="comment">---BUFFER POOL 1</span></span><br><span class="line">Buffer pool <span class="keyword">size</span>   <span class="number">65535</span></span><br><span class="line">Free buffers       <span class="number">46038</span></span><br><span class="line"><span class="keyword">Database</span> pages     <span class="number">19425</span></span><br><span class="line"><span class="keyword">Old</span> <span class="keyword">database</span> pages <span class="number">7150</span></span><br><span class="line">Modified db pages  <span class="number">328</span></span><br><span class="line">Pending <span class="keyword">reads</span> <span class="number">0</span></span><br><span class="line">Pending writes: LRU <span class="number">0</span>, <span class="keyword">flush</span> <span class="keyword">list</span> <span class="number">0</span>, single page <span class="number">0</span></span><br><span class="line">Pages made young <span class="number">1</span>, <span class="keyword">not</span> young <span class="number">0</span></span><br><span class="line"><span class="number">0.00</span> youngs/s, <span class="number">0.00</span> non-youngs/s</span><br><span class="line">Pages <span class="keyword">read</span> <span class="number">159</span>, created <span class="number">19266</span>, written <span class="number">20934</span></span><br><span class="line"><span class="number">0.00</span> <span class="keyword">reads</span>/s, <span class="number">118.81</span> creates/s, <span class="number">76.32</span> writes/s</span><br><span class="line">Buffer pool hit rate <span class="number">1000</span> / <span class="number">1000</span>, young-making rate <span class="number">0</span> / <span class="number">1000</span> <span class="keyword">not</span> <span class="number">0</span> / <span class="number">1000</span></span><br><span class="line">Pages <span class="keyword">read</span> ahead <span class="number">0.00</span>/s, evicted <span class="keyword">without</span> <span class="keyword">access</span> <span class="number">0.00</span>/s, Random <span class="keyword">read</span> ahead</span><br><span class="line"><span class="number">0.00</span>/s</span><br><span class="line">LRU <span class="keyword">len</span>: <span class="number">19425</span>, unzip_LRU <span class="keyword">len</span>: <span class="number">0</span></span><br><span class="line">I/O <span class="keyword">sum</span>[<span class="number">0</span>]:cur[<span class="number">0</span>], unzip <span class="keyword">sum</span>[<span class="number">0</span>]:cur[<span class="number">0</span>]</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line"><span class="keyword">ROW</span> <span class="keyword">OPERATIONS</span></span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line"><span class="number">0</span> queries inside <span class="keyword">InnoDB</span>, <span class="number">0</span> queries <span class="keyword">in</span> queue</span><br><span class="line"><span class="number">0</span> <span class="keyword">read</span> views <span class="keyword">open</span> inside <span class="keyword">InnoDB</span></span><br><span class="line"><span class="keyword">Main</span> <span class="keyword">thread</span> process no. <span class="number">54607</span>, <span class="keyword">id</span> <span class="number">139946075744000</span>, state: sleeping</span><br><span class="line"><span class="built_in">Number</span> <span class="keyword">of</span> <span class="keyword">rows</span> inserted <span class="number">12163964</span>, <span class="keyword">updated</span> <span class="number">0</span>, deleted <span class="number">3</span>, <span class="keyword">read</span> <span class="number">4</span></span><br><span class="line"><span class="number">67807.03</span> inserts/s, <span class="number">0.00</span> updates/s, <span class="number">0.00</span> deletes/s, <span class="number">0.00</span> <span class="keyword">reads</span>/s</span><br><span class="line"><span class="comment">----------------------------</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">OF</span> <span class="keyword">INNODB</span> MONITOR <span class="keyword">OUTPUT</span></span><br><span class="line">============================</span><br></pre></td></tr></table></figure>

<h4 id="标准监视器输出部分"><a href="#标准监视器输出部分" class="headerlink" title="标准监视器输出部分"></a>标准监视器输出部分</h4><p>有关标准监视器报告的每个度量的说明，请参阅 《<a href="https://dev.mysql.com/doc/mysql-em-plugin/en/" target="_blank" rel="noopener">Oracle Enterprise Manager for MySQL数据库用户指南》中的“ </a><a href="https://dev.mysql.com/doc/mysql-em-plugin/en/myoem-metrics.html" target="_blank" rel="noopener">度量”</a>一章 。</p>
<ul>
<li><p><code>Status</code></p>
<p>本节显示时间戳，监视器名称以及每秒平均值所基于的秒数。秒数是从当前时间到最后一次<code>InnoDB</code>打印监视器输出之间经过的时间。</p>
</li>
<li><p><code>BACKGROUND THREAD</code></p>
<p>这些<code>srv_master_thread</code>行显示了由主后台线程完成的工作。</p>
</li>
<li><p><code>SEMAPHORES</code></p>
<p>本节报告线程等待信号量的统计信息，并统计线程需要旋转或等待互斥量或rw-lock信号量的次数。等待信号量的大量线程可能是磁盘I / O或内部争用的结果<code>InnoDB</code>。争用可能是由于查询的高度并行性或操作系统线程调度中的问题。<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_thread_concurrency" target="_blank" rel="noopener"><code>innodb_thread_concurrency</code></a> 在这种情况下，将系统变量设置为 小于默认值可能会有所帮助。该<code>Spin rounds per wait</code> 行显示每个操作系统等待互斥锁的自旋锁轮数。</p>
</li>
<li><p><code>LATEST FOREIGN KEY ERROR</code></p>
<p>本节提供有关最新外键约束错误的信息。如果没有发生此类错误，则不存在。内容包括失败的语句以及有关失败的约束以及所引用和引用表的信息。</p>
</li>
<li><p><code>LATEST DETECTED DEADLOCK</code></p>
<p>本节提供有关最新死锁的信息。如果没有发生死锁，则不存在。内容显示涉及哪些事务，每个尝试执行的语句，它们拥有和需要的锁，以及哪个事务<code>InnoDB</code> 决定回滚以打破死锁。<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-locking.html" target="_blank" rel="noopener">第14.7.1节“ InnoDB锁定”</a>中说明了本节中报告的锁定模式 。</p>
</li>
<li><p><code>TRANSACTIONS</code></p>
<p>如果此部分报告锁定等待，则您的应用程序可能具有锁定争用。输出还可以帮助跟踪事务死锁的原因。</p>
</li>
<li><p><code>FILE I/O</code></p>
<p>本节提供有关<code>InnoDB</code>用于执行各种I / O的线程的信息 。其中的前几个专用于常规 <code>InnoDB</code>处理。内容还显示有关挂起的I / O操作的信息和有关I / O性能的统计信息。</p>
<p>这些线程的数量由<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_read_io_threads" target="_blank" rel="noopener"><code>innodb_read_io_threads</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_write_io_threads" target="_blank" rel="noopener"><code>innodb_write_io_threads</code></a> 参数控制 。请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html" target="_blank" rel="noopener">第14.14节“ InnoDB启动选项和系统变量”</a>。</p>
</li>
<li><p><code>INSERT BUFFER AND ADAPTIVE HASH INDEX</code></p>
<p>本部分显示 <code>InnoDB</code>插入缓冲区（也称为<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_change_buffer" target="_blank" rel="noopener">Change Buffer</a>）和自适应哈希索引的状态。</p>
<p>有关相关信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-change-buffer.html" target="_blank" rel="noopener">第14.5.2节“Change Buffer”</a>和 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-adaptive-hash.html" target="_blank" rel="noopener">第14.5.3节“自适应哈希索引”</a>。</p>
</li>
<li><p><code>LOG</code></p>
<p>本部分显示有关<code>InnoDB</code>日志的信息 。内容包括当前日志序列号，已将日志刷新到磁盘的距离以及<code>InnoDB</code>上次执行检查点的位置 。（请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-checkpoints.html" target="_blank" rel="noopener">第14.12.3节“ InnoDB检查点”</a>。）本节还显示有关挂起的写入和写入性能统计信息。</p>
</li>
<li><p><code>BUFFER POOL AND MEMORY</code></p>
<p>本节为您提供有关已读和已写页面的统计信息。您可以从这些数字中计算出查询当前正在执行多少个数据文件I / O操作。</p>
<p>有关缓冲池统计信息的描述，请参阅 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-buffer-pool.html#innodb-buffer-pool-monitoring" target="_blank" rel="noopener">使用InnoDB Standard Monitor监视缓冲池</a>。有关缓冲池操作的更多信息，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-buffer-pool.html" target="_blank" rel="noopener">第14.5.1节“缓冲池”</a>。</p>
</li>
<li><p><code>ROW OPERATIONS</code></p>
<p>本节显示了主线程在做什么，包括每种行操作的数量和性能比率。</p>
</li>
</ul>
<h3 id="14-17-4-InnoDB表空间监视器输出"><a href="#14-17-4-InnoDB表空间监视器输出" class="headerlink" title="14.17.4 InnoDB表空间监视器输出"></a>14.17.4 InnoDB表空间监视器输出</h3><p>注意</p>
<p>该<code>InnoDB</code>表空间监视器是过时的，并且可以在未来版本中删除。</p>
<p>的<code>InnoDB</code>表空间监视器打印关于共享表的文件段的信息，并验证该表空间分配数据结构。表空间监视器未描述使用该<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a>选项创建的每表文件表空间 。</p>
<p><code>InnoDB</code>表空间监视器输出 示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">================================================</span><br><span class="line">090408 21:28:09 INNODB TABLESPACE MONITOR OUTPUT</span><br><span class="line">================================================</span><br><span class="line">FILE SPACE INFO: id 0</span><br><span class="line">size 13440, free limit 3136, free extents 28</span><br><span class="line">not full frag extents 2: used pages 78, full frag extents 3</span><br><span class="line">first seg id not used 0 23845</span><br><span class="line">SEGMENT id 0 1 space 0; page 2; res 96 used 46; full ext 0</span><br><span class="line">fragm pages 32; free extents 0; not full extents 1: pages 14</span><br><span class="line">SEGMENT id 0 2 space 0; page 2; res 1 used 1; full ext 0</span><br><span class="line">fragm pages 1; free extents 0; not full extents 0: pages 0</span><br><span class="line">SEGMENT id 0 3 space 0; page 2; res 1 used 1; full ext 0</span><br><span class="line">fragm pages 1; free extents 0; not full extents 0: pages 0</span><br><span class="line">...</span><br><span class="line">SEGMENT id 0 15 space 0; page 2; res 160 used 160; full ext 2</span><br><span class="line">fragm pages 32; free extents 0; not full extents 0: pages 0</span><br><span class="line">SEGMENT id 0 488 space 0; page 2; res 1 used 1; full ext 0</span><br><span class="line">fragm pages 1; free extents 0; not full extents 0: pages 0</span><br><span class="line">SEGMENT id 0 17 space 0; page 2; res 1 used 1; full ext 0</span><br><span class="line">fragm pages 1; free extents 0; not full extents 0: pages 0</span><br><span class="line">...</span><br><span class="line">SEGMENT id 0 171 space 0; page 2; res 592 used 481; full ext 7</span><br><span class="line">fragm pages 16; free extents 0; not full extents 2: pages 17</span><br><span class="line">SEGMENT id 0 172 space 0; page 2; res 1 used 1; full ext 0</span><br><span class="line">fragm pages 1; free extents 0; not full extents 0: pages 0</span><br><span class="line">SEGMENT id 0 173 space 0; page 2; res 96 used 44; full ext 0</span><br><span class="line">fragm pages 32; free extents 0; not full extents 1: pages 12</span><br><span class="line">...</span><br><span class="line">SEGMENT id 0 601 space 0; page 2; res 1 used 1; full ext 0</span><br><span class="line">fragm pages 1; free extents 0; not full extents 0: pages 0</span><br><span class="line">NUMBER of file segments: 73</span><br><span class="line">Validating tablespace</span><br><span class="line">Validation ok</span><br><span class="line"><span class="comment">---------------------------------------</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">OF</span> <span class="keyword">INNODB</span> <span class="keyword">TABLESPACE</span> MONITOR <span class="keyword">OUTPUT</span></span><br><span class="line">=======================================</span><br></pre></td></tr></table></figure>

<p>表空间监视器输出包括有关共享表空间整体的信息，其后是一个列表，其中包含表空间内每个段的细分。</p>
<p>在此示例中，使用默认 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_page_size" target="_blank" rel="noopener">页面大小</a>，表空间由每个16KB的数据库页面组成。这些页面分为大小为1MB的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_extent" target="_blank" rel="noopener">扩展</a>区（连续64个页面）。</p>
<p>显示总体表空间信息的输出的初始部分具有以下格式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FILE SPACE INFO: id 0</span><br><span class="line">size 13440, free limit 3136, free extents 28</span><br><span class="line">not full frag extents 2: used pages 78, full frag extents 3</span><br><span class="line">first seg id not used 0 23845</span><br></pre></td></tr></table></figure>

<p>表空间的总体信息包括以下值：</p>
<ul>
<li><p><code>id</code></p>
<p>表空间ID。值为0表示共享表空间。</p>
</li>
<li><p><code>size</code></p>
<p>当前表空间大小（以页为单位）。</p>
</li>
<li><p><code>free limit</code></p>
<p>空闲列表尚未初始化的最小页码。达到或超过此限制的页面是免费的。</p>
</li>
<li><p><code>free extents</code></p>
<p>免费范围的数量。</p>
</li>
<li><p><code>not full frag extents</code>， <code>used pages</code></p>
<p>未完全填充的片段扩展区数，以及这些扩展区中已分配的页数。</p>
</li>
<li><p><code>full frag extents</code></p>
<p>完全完整的片段范围的数量。</p>
</li>
<li><p><code>first seg id not used</code></p>
<p>第一个未使用的段ID。</p>
</li>
</ul>
<p>各个细分受众群信息具有以下格式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SEGMENT id 0 15 space 0; page 2; res 160 used 160; full ext 2</span><br><span class="line">fragm pages 32; free extents 0; not full extents 0: pages 0</span><br></pre></td></tr></table></figure>

<p>细分信息包括以下值：</p>
<ul>
<li><p><code>id</code>：</p>
<p>细分ID。</p>
</li>
<li><p><code>space</code>， <code>page</code></p>
<p>表空间号和段“ inode ”所在的表空间内的页面。表空间号0表示共享表空间。 <code>InnoDB</code>使用inode来跟踪表空间中的段。为段显示的其他字段（<code>id</code>，<code>res</code>等）从inode中的信息派生。</p>
</li>
<li><p><code>res</code></p>
<p>为该段分配（保留）的页面数。</p>
</li>
<li><p><code>used</code></p>
<p>段正在使用的已分配页面数。</p>
</li>
<li><p><code>full ext</code></p>
<p>完全使用的为段分配的扩展区数。</p>
</li>
<li><p><code>fragm pages</code></p>
<p>已分配给该段的初始页面数。</p>
</li>
<li><p><code>free extents</code></p>
<p>完全未使用的为段分配的扩展区数。</p>
</li>
<li><p><code>not full extents</code></p>
<p>为该段分配的部分使用的扩展区数。</p>
</li>
<li><p><code>pages</code></p>
<p>在未满范围内使用的页面数。</p>
</li>
</ul>
<p>当一个段增长时，它从一个页面开始，并 <code>InnoDB</code>一次为其分配前几页，最多32页（这是<code>fragm pages</code> 值）。之后，<code>InnoDB</code>分配完整范围。<code>InnoDB</code>一次最多可以向一个大段中添加4个扩展区，以确保数据的良好顺序。</p>
<p>对于前面显示的示例段，它具有32个片段页面，外加2个完整扩展（每个64页），在分配的160个页面中总共使用了160个页面。以下部分包含32个片段页面和一个部分完整的范围，使用14个页面，在分配的96个页面中总共使用了46个页面：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SEGMENT id 0 1 space 0; page 2; res 96 used 46; full ext 0</span><br><span class="line">fragm pages 32; free extents 0; not full extents 1: pages 14</span><br></pre></td></tr></table></figure>

<p>如果在扩展区分配之后<code>fragm pages</code>某些个别页面已被重新分配，则为其分配扩展区的段的值可能小于32。</p>
<h3 id="14-17-5-InnoDB表监视器输出"><a href="#14-17-5-InnoDB表监视器输出" class="headerlink" title="14.17.5 InnoDB表监视器输出"></a>14.17.5 InnoDB表监视器输出</h3><p>注意</p>
<p>该<code>InnoDB</code>表监控已弃用，可能在将来的版本中删除。可以从<code>InnoDB</code> <code>INFORMATION_SCHEMA</code>表中获得类似的信息。请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-i_s-tables.html" target="_blank" rel="noopener">第21.30节“ INFORMATION_SCHEMA InnoDB表”</a>。</p>
<p>该<code>InnoDB</code>表监控打印内容<code>InnoDB</code>的内部数据字典。</p>
<p>输出每个表包含一个部分。在 <code>SYS_FOREIGN</code>与 <code>SYS_FOREIGN_COLS</code>部分是维持大约外键的信息的内部数据字典表。表监视器表和每个用户创建的<code>InnoDB</code>表也有一些部分。假设已在<code>test</code>数据库中创建以下两个表 ：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">parent</span></span><br><span class="line">(</span><br><span class="line">  par_id    <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  fname      <span class="built_in">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">  lname      <span class="built_in">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (par_id),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> (lname, fname)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">child</span></span><br><span class="line">(</span><br><span class="line">  par_id      <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  child_id    <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">name</span>        <span class="built_in">VARCHAR</span>(<span class="number">40</span>),</span><br><span class="line">  birth       <span class="built_in">DATE</span>,</span><br><span class="line">  weight      <span class="built_in">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">  misc_info   <span class="built_in">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">  last_update <span class="built_in">TIMESTAMP</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (par_id, child_id),</span><br><span class="line">  <span class="keyword">INDEX</span> (<span class="keyword">name</span>),</span><br><span class="line">  <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (par_id) <span class="keyword">REFERENCES</span> <span class="keyword">parent</span> (par_id)</span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span></span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span></span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span>;</span><br></pre></td></tr></table></figure>

<p>然后，表监视器的输出将类似于以下内容（略微更改）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">===========================================</span><br><span class="line">090420 12:09:32 INNODB TABLE MONITOR OUTPUT</span><br><span class="line">===========================================</span><br><span class="line"><span class="comment">--------------------------------------</span></span><br><span class="line">TABLE: name SYS_FOREIGN, id 0 11, columns 7, indexes 3, appr.rows 1</span><br><span class="line">  COLUMNS: ID: DATA_VARCHAR DATA_ENGLISH len 0;</span><br><span class="line">           FOR_NAME: DATA_VARCHAR DATA_ENGLISH len 0;</span><br><span class="line">           REF_NAME: DATA_VARCHAR DATA_ENGLISH len 0;</span><br><span class="line">           N_COLS: DATA_INT len 4;</span><br><span class="line">           DB_ROW_ID: DATA_SYS prtype 256 len 6;</span><br><span class="line">           DB_TRX_ID: DATA_SYS prtype 257 len 6;</span><br><span class="line">  INDEX: name ID_IND, id 0 11, fields 1/6, uniq 1, type 3</span><br><span class="line">   root page 46, appr.key vals 1, leaf pages 1, size pages 1</span><br><span class="line">   FIELDS:  ID DB_TRX_ID DB_ROLL_PTR FOR_NAME REF_NAME N_COLS</span><br><span class="line">  INDEX: name FOR_IND, id 0 12, fields 1/2, uniq 2, type 0</span><br><span class="line">   root page 47, appr.key vals 1, leaf pages 1, size pages 1</span><br><span class="line">   FIELDS:  FOR_NAME ID</span><br><span class="line">  INDEX: name REF_IND, id 0 13, fields 1/2, uniq 2, type 0</span><br><span class="line">   root page 48, appr.key vals 1, leaf pages 1, size pages 1</span><br><span class="line">   FIELDS:  REF_NAME ID</span><br><span class="line"><span class="comment">--------------------------------------</span></span><br><span class="line">TABLE: name SYS_FOREIGN_COLS, id 0 12, columns 7, indexes 1, appr.rows 1</span><br><span class="line">  COLUMNS: ID: DATA_VARCHAR DATA_ENGLISH len 0;</span><br><span class="line">           POS: DATA_INT len 4;</span><br><span class="line">           FOR_COL_NAME: DATA_VARCHAR DATA_ENGLISH len 0;</span><br><span class="line">           REF_COL_NAME: DATA_VARCHAR DATA_ENGLISH len 0;</span><br><span class="line">           DB_ROW_ID: DATA_SYS prtype 256 len 6;</span><br><span class="line">           DB_TRX_ID: DATA_SYS prtype 257 len 6;</span><br><span class="line">  INDEX: name ID_IND, id 0 14, fields 2/6, uniq 2, type 3</span><br><span class="line">   root page 49, appr.key vals 1, leaf pages 1, size pages 1</span><br><span class="line">   FIELDS:  ID POS DB_TRX_ID DB_ROLL_PTR FOR_COL_NAME REF_COL_NAME</span><br><span class="line"><span class="comment">--------------------------------------</span></span><br><span class="line">TABLE: name test/child, id 0 14, columns 10, indexes 2, appr.rows 201</span><br><span class="line">  COLUMNS: par_id: DATA_INT DATA_BINARY_TYPE DATA_NOT_NULL len 4;</span><br><span class="line">           child_id: DATA_INT DATA_BINARY_TYPE DATA_NOT_NULL len 4;</span><br><span class="line">           name: DATA_VARCHAR prtype 524303 len 40;</span><br><span class="line">           birth: DATA_INT DATA_BINARY_TYPE len 3;</span><br><span class="line">           weight: DATA_FIXBINARY DATA_BINARY_TYPE len 5;</span><br><span class="line">           misc_info: DATA_VARCHAR prtype 524303 len 255;</span><br><span class="line">           last_update: DATA_INT DATA_UNSIGNED DATA_BINARY_TYPE DATA_NOT_NULL len 4;</span><br><span class="line">           DB_ROW_ID: DATA_SYS prtype 256 len 6;</span><br><span class="line">           DB_TRX_ID: DATA_SYS prtype 257 len 6;</span><br><span class="line">  INDEX: name PRIMARY, id 0 17, fields 2/9, uniq 2, type 3</span><br><span class="line">   root page 52, appr.key vals 201, leaf pages 5, size pages 6</span><br><span class="line">   FIELDS:  par_id child_id DB_TRX_ID DB_ROLL_PTR name birth weight misc_info last_update</span><br><span class="line">  INDEX: name name, id 0 18, fields 1/3, uniq 3, type 0</span><br><span class="line">   root page 53, appr.key vals 210, leaf pages 1, size pages 1</span><br><span class="line">   FIELDS:  name par_id child_id</span><br><span class="line">  FOREIGN KEY CONSTRAINT test/child_ibfk_1: test/child ( par_id )</span><br><span class="line">             REFERENCES test/parent ( par_id )</span><br><span class="line"><span class="comment">--------------------------------------</span></span><br><span class="line">TABLE: name test/innodb_table_monitor, id 0 15, columns 4, indexes 1, appr.rows 0</span><br><span class="line">  COLUMNS: i: DATA_INT DATA_BINARY_TYPE len 4;</span><br><span class="line">           DB_ROW_ID: DATA_SYS prtype 256 len 6;</span><br><span class="line">           DB_TRX_ID: DATA_SYS prtype 257 len 6;</span><br><span class="line">  INDEX: name GEN_CLUST_INDEX, id 0 19, fields 0/4, uniq 1, type 1</span><br><span class="line">   root page 193, appr.key vals 0, leaf pages 1, size pages 1</span><br><span class="line">   FIELDS:  DB_ROW_ID DB_TRX_ID DB_ROLL_PTR i</span><br><span class="line"><span class="comment">--------------------------------------</span></span><br><span class="line">TABLE: name test/parent, id 0 13, columns 6, indexes 2, appr.rows 299</span><br><span class="line">  COLUMNS: par_id: DATA_INT DATA_BINARY_TYPE DATA_NOT_NULL len 4;</span><br><span class="line">           fname: DATA_CHAR prtype 524542 len 20;</span><br><span class="line">           lname: DATA_CHAR prtype 524542 len 20;</span><br><span class="line">           DB_ROW_ID: DATA_SYS prtype 256 len 6;</span><br><span class="line">           DB_TRX_ID: DATA_SYS prtype 257 len 6;</span><br><span class="line">  INDEX: name PRIMARY, id 0 15, fields 1/5, uniq 1, type 3</span><br><span class="line">   root page 50, appr.key vals 299, leaf pages 2, size pages 3</span><br><span class="line">   FIELDS:  par_id DB_TRX_ID DB_ROLL_PTR fname lname</span><br><span class="line">  INDEX: name lname, id 0 16, fields 2/3, uniq 2, type 2</span><br><span class="line">   root page 51, appr.key vals 300, leaf pages 1, size pages 1</span><br><span class="line">   FIELDS:  lname fname par_id</span><br><span class="line">  FOREIGN KEY CONSTRAINT test/child_ibfk_1: test/child ( par_id )</span><br><span class="line">             REFERENCES test/parent ( par_id )</span><br><span class="line"><span class="comment">-----------------------------------</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">OF</span> <span class="keyword">INNODB</span> <span class="keyword">TABLE</span> MONITOR <span class="keyword">OUTPUT</span></span><br><span class="line">==================================</span><br></pre></td></tr></table></figure>

<p>对于每个表，表监视器输出包含一个部分，该部分显示有关表的常规信息以及有关其列，索引和外键的特定信息。</p>
<p>每个表的常规信息包括表名（ 内部表以外的格式），其ID，列数和索引数以及大概的行数。 <code>*</code>db_name<code>*/*</code>tbl_name<code>*</code></p>
<p><code>COLUMNS</code>表部分 的一部分列出了表中的每一列。每列的信息指示其名称和数据类型特征。某些内部列由添加<code>InnoDB</code>，例如 <code>DB_ROW_ID</code>（行ID）， <code>DB_TRX_ID</code>（事务ID）和 <code>DB_ROLL_PTR</code>（指向回滚/撤消数据的指针）。</p>
<ul>
<li><p><code>DATA_*</code>xxx<code>*</code></p>
<p>这些符号表示数据类型。给定列可能有多个 符号。 <code>DATA_*</code>xxx<code>*</code></p>
</li>
<li><p><code>prtype</code></p>
<p>列的“ 精确 ”类型。该字段包括诸如列数据类型，字符集代码，可空性，带符号以及是否为二进制字符串之类的信息。此字段在<code>innobase/include/data0type.h</code>源文件中描述 。</p>
</li>
<li><p><code>len</code></p>
<p>列长度（以字节为单位）。</p>
</li>
</ul>
<p><code>INDEX</code>表部分的 每一部分提供一个表索引的名称和特征：</p>
<ul>
<li><p><code>name</code></p>
<p>索引名称。如果名称为<code>PRIMARY</code>，则索引为主键。如果名称为 <code>GEN_CLUST_INDEX</code>，则索引为聚集索引，如果表定义不包含主键或非<code>NULL</code> 唯一索引，则聚集索引将自动创建。请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-index-types.html" target="_blank" rel="noopener">第14.6.2.1节“聚集索引和二级索引”</a>。</p>
</li>
<li><p><code>id</code></p>
<p>索引ID。</p>
</li>
<li><p><code>fields</code></p>
<p>索引中的字段数， 格式为： <code>*</code>m<code>*/*</code>n<code>*</code></p>
<ul>
<li><em><code>m</code></em>是用户定义的列数；也就是说，您将在<code>CREATE TABLE</code> 语句的索引定义中看到的列数。</li>
<li><em><code>n</code></em>是索引列的总数，包括内部添加的索引列。对于聚集索引，总数包括表定义中的其他列，以及内部添加的所有列。对于二级索引，总数包括主键中不属于二级索引的列。</li>
</ul>
</li>
<li><p><code>uniq</code></p>
<p>足以唯一确定索引值的前导字段数。</p>
</li>
<li><p><code>type</code></p>
<p>索引类型。这是一个位字段。例如，1表示聚集索引，2表示唯一索引，因此聚集索引（始终包含唯一值）的<code>type</code>值将为3。<code>type</code>值为0 的索引 既不是聚集也不是唯一。标志值在<code>innobase/include/dict0mem.h</code>源文件中定义 。</p>
</li>
<li><p><code>root page</code></p>
<p>索引根页号。</p>
</li>
<li><p><code>appr. key vals</code></p>
<p>近似索引基数。</p>
</li>
<li><p><code>leaf pages</code></p>
<p>索引中叶子页的大概数量。</p>
</li>
<li><p><code>size pages</code></p>
<p>索引中的大约总页数。</p>
</li>
<li><p><code>FIELDS</code></p>
<p>索引中字段的名称。对于自动生成的聚集索引，字段列表以内部<code>DB_ROW_ID</code>（行ID）字段开头。 <code>DB_TRX_ID</code>并且 <code>DB_ROLL_PTR</code>总是在内部构成聚簇索引之后，紧跟构成主键的字段。对于二级索引，最终字段是主键中不属于二级索引的字段。</p>
</li>
</ul>
<p>表部分的末尾列出了<code>FOREIGN KEY</code>适用于表的定义。无论表是引用表还是引用表，都会显示此信息。</p>
<h2 id="14-21-InnoDB故障排除"><a href="#14-21-InnoDB故障排除" class="headerlink" title="14.21 InnoDB故障排除"></a>14.21 InnoDB故障排除</h2><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/error-creating-innodb.html" target="_blank" rel="noopener">14.21.1对InnoDB I / O问题进行故障排除</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/forcing-innodb-recovery.html" target="_blank" rel="noopener">14.21.2强制InnoDB恢复</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-troubleshooting-datadict.html" target="_blank" rel="noopener">14.21.3对InnoDB数据字典操作进行故障排除</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-error-handling.html" target="_blank" rel="noopener">14.21.4 InnoDB错误处理</a></li>
</ul>
<p>以下一般准则适用于故障排除 <code>InnoDB</code>问题：</p>
<ul>
<li><p>当操作失败或怀疑有错误时，请查看MySQL服务器错误日志（请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/error-log.html" target="_blank" rel="noopener">第5.4.2节“错误日志”</a>）。 <a href="https://dev.mysql.com/doc/refman/5.6/en/server-error-reference.html" target="_blank" rel="noopener">第B.3.1节“服务器错误消息参考”</a>提供了有关<code>InnoDB</code>您可能遇到的一些常见特定错误的故障排除信息 。</p>
</li>
<li><p>如果故障与<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_deadlock" target="_blank" rel="noopener">死锁</a>有关 ，请在<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_print_all_deadlocks" target="_blank" rel="noopener"><code>innodb_print_all_deadlocks</code></a> 启用该选项的情况下运行， 以便将有关每个死锁的详细信息打印到MySQL服务器错误日志中。有关死锁的信息，请参见<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-deadlocks.html" target="_blank" rel="noopener">第14.7.5节“ InnoDB中的死锁”</a>。</p>
</li>
<li><p>与<code>InnoDB</code>数据字典有关的问题包括失败的<a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a> 语句（孤立表文件），无法打开 <code>InnoDB</code>文件以及系统找不到指定的路径错误。有关此类问题和错误的信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-troubleshooting-datadict.html" target="_blank" rel="noopener">第14.21.3节“对InnoDB数据字典操作进行故障排除”</a>。</p>
</li>
<li><p>在进行故障排除时，通常最好从命令提示符下运行MySQL服务器，而不是通过 <a href="https://dev.mysql.com/doc/refman/5.6/en/mysqld-safe.html" target="_blank" rel="noopener"><strong>mysqld_safe</strong></a>或作为Windows服务运行。然后，您可以查看<a href="https://dev.mysql.com/doc/refman/5.6/en/mysqld.html" target="_blank" rel="noopener"><strong>mysqld</strong></a>打印到控制台的内容，因此可以更好地了解正在发生的情况。在Windows上，使用选项启动<a href="https://dev.mysql.com/doc/refman/5.6/en/mysqld.html" target="_blank" rel="noopener"><strong>mysqld</strong></a>以 <a href="https://dev.mysql.com/doc/refman/5.6/en/server-options.html#option_mysqld_console" target="_blank" rel="noopener"><code>--console</code></a>将输出定向到控制台窗口。</p>
</li>
<li><p>使<code>InnoDB</code>监视器能够获取有关问题的信息（请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-monitors.html" target="_blank" rel="noopener">第14.17节“ InnoDB监视器”</a>）。如果问题与性能有关，或者服务器似乎已挂起，则应启用标准监视器以打印有关的内部状态的信息<code>InnoDB</code>。如果问题出在锁上，请启用锁监视器。如果问题出在创建表或其他数据字典操作中，请启用表监视器以打印<code>InnoDB</code>内部数据字典的内容 。要查看表空间信息，请启用表空间监视器。</p>
<p><code>InnoDB``InnoDB</code>在以下情况下临时启用标准 Monitor输出：</p>
<ul>
<li>长时间的信号灯等待</li>
<li><code>InnoDB</code> 在缓冲池中找不到可用的块</li>
<li>超过67％的缓冲池被锁堆或自适应哈希索引占用</li>
</ul>
</li>
<li><p>如果怀疑表已损坏，请<a href="https://dev.mysql.com/doc/refman/5.6/en/check-table.html" target="_blank" rel="noopener"><code>CHECK TABLE</code></a>在该表上运行 。</p>
</li>
</ul>
<h3 id="14-21-1对InnoDB-I-O问题进行故障排除"><a href="#14-21-1对InnoDB-I-O问题进行故障排除" class="headerlink" title="14.21.1对InnoDB I / O问题进行故障排除"></a>14.21.1对InnoDB I / O问题进行故障排除</h3><p><code>InnoDB</code>I / O问题 的疑难解答步骤取决于问题发生的时间：在MySQL服务器启动期间，或在正常操作过程中，由于文件系统级别的问题而导致DML或DDL语句失败。</p>
<h4 id="初始化问题"><a href="#初始化问题" class="headerlink" title="初始化问题"></a>初始化问题</h4><p>如果在<code>InnoDB</code>尝试初始化其表空间或日志文件时出现问题，请删除由<code>InnoDB</code>：所有 <code>ibdata</code>文件和所有<code>ib_logfile</code>文件创建的所有 文件。如果已经创建了一些 <code>InnoDB</code>表，还请从MySQL数据库目录中删除<code>.frm</code>这些表的相应 文件，以及<code>.ibd</code>如果使用多个表空间的所有 文件。然后<code>InnoDB</code>再次尝试 创建数据库。为了最简单的故障排除，请从命令提示符启动MySQL服务器，以便了解发生了什么。</p>
<h4 id="运行时问题"><a href="#运行时问题" class="headerlink" title="运行时问题"></a>运行时问题</h4><p>如果<code>InnoDB</code>在文件操作过程中显示操作系统错误，通常该问题具有以下解决方案之一：</p>
<ul>
<li>确保<code>InnoDB</code>数据文件目录和<code>InnoDB</code>日志目录存在。</li>
<li>确保<a href="https://dev.mysql.com/doc/refman/5.6/en/mysqld.html" target="_blank" rel="noopener"><strong>mysqld</strong></a>具有在这些目录中创建文件的访问权限。</li>
<li>确保<a href="https://dev.mysql.com/doc/refman/5.6/en/mysqld.html" target="_blank" rel="noopener"><strong>mysqld</strong></a>可以读取正确的 文件<code>my.cnf</code>或<code>my.ini</code>选项文件，以便它以您指定的选项开头。</li>
<li>确保磁盘未满，并且没有超出任何磁盘配额。</li>
<li>确保为子目录和数据文件指定的名称不冲突。</li>
<li>仔细检查<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_data_home_dir" target="_blank" rel="noopener"><code>innodb_data_home_dir</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_data_file_path" target="_blank" rel="noopener"><code>innodb_data_file_path</code></a>值的语法 。特别是，<code>MAX</code>该<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_data_file_path" target="_blank" rel="noopener"><code>innodb_data_file_path</code></a>选项中的任何值 都是硬限制，超过该限制会导致致命错误。</li>
</ul>
<h3 id="14-21-2强制InnoDB恢复"><a href="#14-21-2强制InnoDB恢复" class="headerlink" title="14.21.2强制InnoDB恢复"></a>14.21.2强制InnoDB恢复</h3><p>要调查数据库页面损坏，您可以使用来从数据库中转储表 <a href="https://dev.mysql.com/doc/refman/5.6/en/select-into.html" target="_blank" rel="noopener"><code>SELECT ... INTO OUTFILE</code></a>。通常，以这种方式获得的大多数数据都是完整的。严重损坏可能导致语句或 后台操作崩溃或断言，甚至导致前滚恢复崩溃。在这种情况下，您可以使用该 选项在阻止后台操作运行的同时强制启动存储引擎，以便转储表。例如，您可以在重新启动服务器之前将以下行添加到选项文件的部分中： <code>SELECT * FROM *</code>tbl_name<code>*``InnoDB``InnoDB</code><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_force_recovery" target="_blank" rel="noopener"><code>innodb_force_recovery</code></a><code>InnoDB``[mysqld]</code></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">innodb_force_recovery</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>有关使用选项文件的信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/option-files.html" target="_blank" rel="noopener">第4.2.2.2节“使用选项文件”</a>。</p>
<p>警告</p>
<p>仅<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_force_recovery" target="_blank" rel="noopener"><code>innodb_force_recovery</code></a> 在紧急情况下设置为大于0的值，以便您可以启动<code>InnoDB</code>和转储表。这样做之前，请确保您拥有数据库的备份副本，以防万一您需要重新创建它。值大于等于4可能会永久损坏数据文件。<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_force_recovery" target="_blank" rel="noopener"><code>innodb_force_recovery</code></a>在数据库的单独物理副本上成功测试设置之后，请仅在生产服务器实例上使用 4或更大的设置。强制<code>InnoDB</code>恢复时，应始终从头开始， <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_force_recovery" target="_blank" rel="noopener"><code>innodb_force_recovery=1</code></a>并根据需要仅逐渐增加该值。</p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_force_recovery" target="_blank" rel="noopener"><code>innodb_force_recovery</code></a>默认情况下为0（正常启动而不强制恢复）。允许的非零值 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_force_recovery" target="_blank" rel="noopener"><code>innodb_force_recovery</code></a>是1到6。较大的值包括较小值的功能。例如，值3包含值1和2的所有功能。</p>
<p>如果能够转储 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_force_recovery" target="_blank" rel="noopener"><code>innodb_force_recovery</code></a>值为3或更小的表，则相对安全的是，仅丢失损坏的单个页面上的某些数据。4或更大的值被认为是危险的，因为数据文件可能会永久损坏。值6被认为是过大的，因为数据库页面处于过时状态，这反过来可能会使<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_b_tree" target="_blank" rel="noopener">B树</a> 和其他数据库结构遭受更多破坏。</p>
<p>为了安全起见，请<code>InnoDB</code>防止 <a href="https://dev.mysql.com/doc/refman/5.6/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>， <a href="https://dev.mysql.com/doc/refman/5.6/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>或 <a href="https://dev.mysql.com/doc/refman/5.6/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>在<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_force_recovery" target="_blank" rel="noopener"><code>innodb_force_recovery</code></a>大于0 时进行操作 。从MySQL 5.6.15开始， 在只读模式下<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_force_recovery" target="_blank" rel="noopener"><code>innodb_force_recovery</code></a>设置4个或更多位置<code>InnoDB</code>。</p>
<ul>
<li><p><code>1</code> （<code>SRV_FORCE_IGNORE_CORRUPT</code>）</p>
<p>使服务器即使检测到损坏的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_page" target="_blank" rel="noopener">页面</a>也可以运行 。尝试 跳过损坏的索引记录和页，这有助于转储表。 <code>SELECT * FROM *</code>tbl_name<code>*</code></p>
</li>
<li><p><code>2</code> （<code>SRV_FORCE_NO_BACKGROUND</code>）</p>
<p>阻止<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_master_thread" target="_blank" rel="noopener">主线程</a>和任何<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_purge_thread" target="_blank" rel="noopener">清除线程</a>运行。如果在<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_purge" target="_blank" rel="noopener">清除</a>操作期间发生崩溃，则此恢复值可防止崩溃 。</p>
</li>
<li><p><code>3</code> （<code>SRV_FORCE_NO_TRX_UNDO</code>）</p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_crash_recovery" target="_blank" rel="noopener">崩溃恢复</a>后 不运行事务 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_rollback" target="_blank" rel="noopener">回滚</a>。</p>
</li>
<li><p><code>4</code> （<code>SRV_FORCE_NO_IBUF_MERGE</code>）</p>
<p>防止<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_insert_buffer" target="_blank" rel="noopener">插入缓冲区</a>合并操作。如果它们会导致崩溃，请不要这样做。不计算表 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_statistics" target="_blank" rel="noopener">统计信息</a>。此值可能会永久损坏数据文件。使用此值后，准备删除并重新创建所有二级索引。从MySQL 5.6.15开始，设置<code>InnoDB</code>为只读。</p>
</li>
<li><p><code>5</code> （<code>SRV_FORCE_NO_UNDO_LOG_SCAN</code>）</p>
<p>启动数据库时 不查看<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_undo_log" target="_blank" rel="noopener">Undo Log</a>： <code>InnoDB</code>甚至将未完成的事务也视为已提交。此值可能会永久损坏数据文件。从MySQL 5.6.15开始，设置<code>InnoDB</code>为只读。</p>
</li>
<li><p><code>6</code> （<code>SRV_FORCE_NO_LOG_REDO</code>）</p>
<p>不进行与<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_redo_log" target="_blank" rel="noopener">恢复</a>有关的<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_redo_log" target="_blank" rel="noopener">Redo Log前</a> 滚。此值可能会永久损坏数据文件。使数据库页面处于过时状态，从而可能导致B树和其他数据库结构遭受更多破坏。从MySQL 5.6.15开始，设置<code>InnoDB</code>为只读。</p>
</li>
</ul>
<p>您可以<a href="https://dev.mysql.com/doc/refman/5.6/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>从表中转储它们。随着 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_force_recovery" target="_blank" rel="noopener"><code>innodb_force_recovery</code></a>3或更低就可以值<code>DROP</code>或 <code>CREATE</code>表。从MySQL 5.6.27开始， <a href="https://dev.mysql.com/doc/refman/5.6/en/drop-table.html" target="_blank" rel="noopener"><code>DROP TABLE</code></a>还支持<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_force_recovery" target="_blank" rel="noopener"><code>innodb_force_recovery</code></a>大于3 的值。</p>
<p>如果您知道给定的表导致回滚崩溃，则可以将其删除。如果遇到由于批量导入或失败而导致的失控回滚<a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>，则可以<a href="https://dev.mysql.com/doc/refman/5.6/en/mysqld.html" target="_blank" rel="noopener"><strong>终止mysqld</strong></a>进程并设置 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_force_recovery" target="_blank" rel="noopener"><code>innodb_force_recovery</code></a>为 <code>3</code>不回滚就启动数据库，然后<code>DROP</code>启动导致失控回滚的表。</p>
<p>如果表数据中的损坏阻止您转储整个表内容，则带有子句的查询可能能够转储损坏部分后的表部分。 <code>ORDER BY *</code>primary_key<code>* DESC</code></p>
<p>如果一个高<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_force_recovery" target="_blank" rel="noopener"><code>innodb_force_recovery</code></a> 值是必需的开始<code>InnoDB</code>，有可能是，可能导致（含有查询的复杂查询损坏的数据结构<code>WHERE</code>，<code>ORDER BY</code>或其它条款）失败。在这种情况下，您可能只能运行基本<code>SELECT * FROM t</code> 查询。</p>
<h3 id="14-21-3对InnoDB数据字典操作进行故障排除"><a href="#14-21-3对InnoDB数据字典操作进行故障排除" class="headerlink" title="14.21.3对InnoDB数据字典操作进行故障排除"></a>14.21.3对InnoDB数据字典操作进行故障排除</h3><p>有关表定义的信息既存储在<code>.frm</code>文件中，又存储 在InnoDB <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_data_dictionary" target="_blank" rel="noopener">数据字典中</a>。如果您移动<code>.frm</code>文件，或者服务器在数据字典操作过程中崩溃，则这些信息源可能会变得不一致。</p>
<p>如果数据字典损坏或一致性问题使您无法启动<code>InnoDB</code>，请参阅 <a href="https://dev.mysql.com/doc/refman/5.6/en/forcing-innodb-recovery.html" target="_blank" rel="noopener">第14.21.2节“强制InnoDB恢复”</a>以获取有关手动恢复的信息。</p>
<h4 id="由于孤立表导致CREATE-TABLE失败"><a href="#由于孤立表导致CREATE-TABLE失败" class="headerlink" title="由于孤立表导致CREATE TABLE失败"></a>由于孤立表导致CREATE TABLE失败</h4><p>数据字典不同步的症状是 <a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>语句失败。如果发生这种情况，请查看服务器的错误日志。如果日志表明<code>InnoDB</code>内部数据字典中已经存在该 表，则<code>InnoDB</code>表空间文件中有一个孤立表，该表没有相应的<code>.frm</code>文件。错误消息如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">InnoDB: Error: table test/parent already exists in InnoDB internal</span><br><span class="line">InnoDB: data dictionary. Have you deleted the .frm file</span><br><span class="line">InnoDB: and not used DROP TABLE? Have you used DROP DATABASE</span><br><span class="line">InnoDB: for InnoDB tables in MySQL version &lt;= 3.23.43?</span><br><span class="line">InnoDB: See the Restrictions section of the InnoDB manual.</span><br><span class="line">InnoDB: You can drop the orphaned table inside InnoDB by</span><br><span class="line">InnoDB: creating an InnoDB table with the same name in another</span><br><span class="line">InnoDB: database and moving the .frm file to the current database.</span><br><span class="line">InnoDB: Then MySQL thinks the table exists, and DROP TABLE will</span><br><span class="line">InnoDB: succeed.</span><br></pre></td></tr></table></figure>

<p>您可以按照错误消息中给出的说明删除孤立表。如果仍然无法<a href="https://dev.mysql.com/doc/refman/5.6/en/drop-table.html" target="_blank" rel="noopener"><code>DROP TABLE</code></a>成功使用 ，则问题可能是由于<a href="https://dev.mysql.com/doc/refman/5.6/en/mysql.html" target="_blank" rel="noopener"><strong>mysql</strong></a>客户端中的名称完成 。要解决此问题，请使用 选项启动<a href="https://dev.mysql.com/doc/refman/5.6/en/mysql.html" target="_blank" rel="noopener"><strong>mysql</strong></a>客户端， <a href="https://dev.mysql.com/doc/refman/5.6/en/mysql-command-options.html#option_mysql_auto-rehash" target="_blank" rel="noopener"><code>--skip-auto-rehash</code></a>然后重试<a href="https://dev.mysql.com/doc/refman/5.6/en/drop-table.html" target="_blank" rel="noopener"><code>DROP TABLE</code></a>。（启用名称完成功能后，<a href="https://dev.mysql.com/doc/refman/5.6/en/mysql.html" target="_blank" rel="noopener"><strong>mysql</strong></a>试图构造一个表名称列表，当存在上述问题时，该列表将失败。）</p>
<h4 id="无法打开文件错误"><a href="#无法打开文件错误" class="headerlink" title="无法打开文件错误"></a>无法打开文件错误</h4><p>数据字典不同步的另一个症状是MySQL打印出一个无法打开<code>InnoDB</code>文件的错误 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1016: Can&apos;t open file: &apos;child2.ibd&apos;. (errno: 1)</span><br></pre></td></tr></table></figure>

<p>在错误日志中，您可以找到以下消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InnoDB: Cannot find table test/child2 from the internal data dictionary</span><br><span class="line">InnoDB: of InnoDB though the .frm file for the table exists. Maybe you</span><br><span class="line">InnoDB: have deleted and recreated InnoDB data files but have forgotten</span><br><span class="line">InnoDB: to delete the corresponding .frm files of InnoDB tables?</span><br></pre></td></tr></table></figure>

<p>这意味着存在一个孤立<code>.frm</code> 文件，里面没有对应的表 <code>InnoDB</code>。您可以<code>.frm</code>通过手动删除孤立 文件来删除它。</p>
<h4 id="孤立的中间表"><a href="#孤立的中间表" class="headerlink" title="孤立的中间表"></a>孤立的中间表</h4><p>如果MySQL在就地<a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>操作（<code>ALGORITHM=INPLACE</code>）中间退出，则 可能会留下孤立的中间表，该表占用了系统空间。本节介绍如何识别和删除孤立的中间表。</p>
<p>中间表名称以<code>#sql-ib</code>前缀（例如 <code>#sql-ib87-856498050</code>）开头 。随附 <code>.frm</code>文件具有 <code>#sql-*</code>前缀，并且命名不同（例如<code>#sql-36ab_2.frm</code>）。</p>
<p>要识别系统上的孤立中间表，可以查看<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-monitors.html" target="_blank" rel="noopener">表监视器的</a>输出或查询 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-sys-tables-table.html" target="_blank" rel="noopener"><code>INFORMATION_SCHEMA.INNODB_SYS_TABLES</code></a>。查找以开头的表名<code>#sql</code>。如果原始表位于 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_file_per_table" target="_blank" rel="noopener">每个</a> 表文件<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_file_per_table" target="_blank" rel="noopener">表</a>空间中，<code>#sql-*.ibd</code>则孤立中间表的表空间文件（该 文件）应在数据库目录中可见。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_SYS_TABLES <span class="keyword">WHERE</span> <span class="keyword">NAME</span> <span class="keyword">LIKE</span> <span class="string">'%#sql%'</span>;</span><br></pre></td></tr></table></figure>

<p>要删除孤立的中间表，请执行以下步骤：</p>
<ol>
<li><p>在数据库目录中，重命名 <code>#sql-*.frm</code>文件以匹配孤立中间表的基本名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; mv #sql-36ab_2.frm #sql-ib87-856498050.frm</span><br></pre></td></tr></table></figure>

<p>注意</p>
<p>如果没有<code>.frm</code>文件，则可以重新创建它。该<code>.frm</code>文件必须具有与孤立中间表相同的表架构（它必须具有相同的列和索引），并且必须放置在孤立中间表的数据库目录中。</p>
</li>
<li><p>通过发出一条<a href="https://dev.mysql.com/doc/refman/5.6/en/drop-table.html" target="_blank" rel="noopener"><code>DROP TABLE</code></a>语句，在表名前面加上前缀 <code>#mysql50#</code>并将表名括在反引号中来删除孤立的中间表 。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DROP TABLE `#mysql50##sql-ib87-856498050`;</span><br></pre></td></tr></table></figure>

<p>该<code>#mysql50#</code>前缀告诉MySQL忽略<code>file name safe encoding</code>在MySQL 5.1中引入的。要对具有特殊字符（例如，“ ＃ ”）的表名执行SQL语句，需要将表名括在反引号中。</p>
</li>
</ol>
<h4 id="孤儿临时表"><a href="#孤儿临时表" class="headerlink" title="孤儿临时表"></a>孤儿临时表</h4><p>如果MySQL在表复制<a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>操作（<code>ALGORITHM=COPY</code>）中间退出，则 可能会留下一个孤立的临时表，该表会占用系统空间。本节介绍如何识别和删除孤立的临时表。</p>
<p>孤立的临时表名称以<code>#sql-</code>前缀（例如 <code>#sql-540_3</code>）开头 。随附 <code>.frm</code>文件的名称与孤立临时表的名称相同。</p>
<p>注意</p>
<p>如果没有<code>.frm</code>文件，则可以重新创建它。该<code>.frm</code>文件必须具有与孤立临时表相同的表架构（它必须具有相同的列和索引），并且必须放置在孤立临时表的数据库目录中。</p>
<p>要在系统上标识孤立的临时表，可以查看 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-monitors.html" target="_blank" rel="noopener">表监视器的</a>输出或查询 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-sys-tables-table.html" target="_blank" rel="noopener"><code>INFORMATION_SCHEMA.INNODB_SYS_TABLES</code></a>。查找以开头的表名<code>#sql</code>。如果原始表位于 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_file_per_table" target="_blank" rel="noopener">每个</a> 表文件<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_file_per_table" target="_blank" rel="noopener">表</a>空间中，<code>#sql-*.ibd</code>则孤立临时表的表空间文件（该 文件）应该在数据库目录中可见。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_SYS_TABLES <span class="keyword">WHERE</span> <span class="keyword">NAME</span> <span class="keyword">LIKE</span> <span class="string">'%#sql%'</span>;</span><br></pre></td></tr></table></figure>

<p>要删除孤立的临时表，请通过发出一条<a href="https://dev.mysql.com/doc/refman/5.6/en/drop-table.html" target="_blank" rel="noopener"><code>DROP TABLE</code></a>语句来删除该表，在该表 名的前面加上前缀，<code>#mysql50#</code>并将表名括在反引号中。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DROP TABLE `#mysql50##sql-540_3`;</span><br></pre></td></tr></table></figure>

<p>该<code>#mysql50#</code>前缀告诉MySQL忽略 <code>file name safe encoding</code>在MySQL 5.1中引入的。要对具有特殊字符（例如，“ ＃ ”）的表名执行SQL语句，需要将表名括在反引号中。</p>
<h4 id="表空间不存在"><a href="#表空间不存在" class="headerlink" title="表空间不存在"></a>表空间不存在</h4><p>与<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a> 启用，如果可能会出现以下消息 <code>.frm</code>或<code>.ibd</code>文件（或两者）丢失：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InnoDB: in InnoDB data dictionary has tablespace id N,</span><br><span class="line">InnoDB: but tablespace with that id or name does not exist. Have</span><br><span class="line">InnoDB: you deleted or moved .ibd files?</span><br><span class="line">InnoDB: This may also be a table created with CREATE TEMPORARY TABLE</span><br><span class="line">InnoDB: whose .ibd and .frm files MySQL automatically removed, but the</span><br><span class="line">InnoDB: table still exists in the InnoDB internal data dictionary.</span><br></pre></td></tr></table></figure>

<p>如果发生这种情况，请尝试以下步骤解决问题：</p>
<ol>
<li><code>.frm</code>在其他一些数据库目录中 创建一个匹配文件，并将其复制到孤立表所在的数据库目录中。</li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/drop-table.html" target="_blank" rel="noopener"><code>DROP TABLE</code></a>原始表的 发行。那应该成功删除该表，并且 <code>InnoDB</code>应该在错误日志中显示一条警告，指出该<code>.ibd</code>文件已丢失。</li>
</ol>
<h4 id="恢复每表孤立文件ibd文件"><a href="#恢复每表孤立文件ibd文件" class="headerlink" title="恢复每表孤立文件ibd文件"></a>恢复每表孤立文件ibd文件</h4><p>此过程描述了如何将<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_file_per_table" target="_blank" rel="noopener">每表</a> 孤立<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_file_per_table" target="_blank" rel="noopener">文件</a>还原 <code>.ibd</code>到另一个MySQL实例。如果系统表空间丢失或不可恢复，并且要<code>.ibd</code> 在新的MySQL实例上还原文件备份，则可以使用此过程。</p>
<p>该过程假定您只有 <code>.ibd</code>文件备份，并且要恢复到最初创建孤立<code>.ibd</code>文件的MySQL版本 ，并且 <code>.ibd</code>文件备份是干净的。有关创建干净备份的信息<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-migration.html" target="_blank" rel="noopener">，</a>请参见 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-migration.html" target="_blank" rel="noopener">第14.6.1.4节“移动或复制InnoDB表”</a>。</p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-table-import.html" target="_blank" rel="noopener">第14.6.1.3节“导入InnoDB表”</a>中 概述的表导入限制 适用于此过程。</p>
<ol>
<li><p>在新的MySQL实例上，在同名数据库中重新创建表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE sakila;</span><br><span class="line"></span><br><span class="line">mysql&gt; USE sakila;</span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE actor (</span><br><span class="line">         actor_id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">         first_name VARCHAR(45) NOT NULL,</span><br><span class="line">         last_name VARCHAR(45) NOT NULL,</span><br><span class="line">         last_update TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">         PRIMARY <span class="keyword">KEY</span>  (actor_id),</span><br><span class="line">         <span class="keyword">KEY</span> idx_actor_last_name (last_name)</span><br><span class="line">       )<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>
</li>
<li><p>丢弃新创建的表的表空间。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE sakila.actor DISCARD TABLESPACE;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将孤立<code>.ibd</code>文件从备份目录复制到新的数据库目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; cp /backup_directory/actor.ibd path/to/mysql-5.6/data/sakila/</span><br></pre></td></tr></table></figure>
</li>
<li><p>确保<code>.ibd</code>文件具有必要的文件权限。</p>
</li>
<li><p>导入孤立<code>.ibd</code>文件。发出警告，指示<code>InnoDB</code>将尝试在不进行模式验证的情况下导入文件。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE sakila.actor IMPORT TABLESPACE; SHOW WARNINGS;    </span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.15 sec)</span><br><span class="line"></span><br><span class="line">Warning | 1810 | InnoDB: IO Read error: (2, No such file or directory)</span><br><span class="line">Error opening './sakila/actor.cfg', will attempt to import</span><br><span class="line">without schema verification</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询表以确认<code>.ibd</code> 文件已成功还原。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT COUNT(*) FROM sakila.actor;</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| count(*) |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">|      200 |</span><br><span class="line">+<span class="comment">----------+</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="14-21-4-InnoDB错误处理"><a href="#14-21-4-InnoDB错误处理" class="headerlink" title="14.21.4 InnoDB错误处理"></a>14.21.4 InnoDB错误处理</h3><p>以下各项描述了如何<code>InnoDB</code> 执行错误处理。<code>InnoDB</code>有时仅回滚失败的语句，而其他时候回滚整个事务。</p>
<ul>
<li><p>如果<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_tablespace" target="_blank" rel="noopener">表</a>空间中的文件空间用完 ，<code>Table is full</code>则会发生MySQL 错误并 <code>InnoDB</code>回滚SQL语句。</p>
</li>
<li><p>一个事务<a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_deadlock" target="_blank" rel="noopener">死锁</a> 导致<code>InnoDB</code>要 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_rollback" target="_blank" rel="noopener">回滚</a>整个 <a href="https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_transaction" target="_blank" rel="noopener">事务</a>。发生这种情况时，请重试整个事务。</p>
<p>锁定等待超时导致<code>InnoDB</code>仅回滚正在等待锁定且遇到超时的单个语句。（要使整个事务回滚，请使用<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_rollback_on_timeout" target="_blank" rel="noopener"><code>--innodb-rollback-on-timeout</code></a> 选项启动服务器 。）如果使用当前行为，请重试该语句；如果使用，请重试该事务 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_rollback_on_timeout" target="_blank" rel="noopener"><code>--innodb-rollback-on-timeout</code></a>。</p>
<p>死锁和锁等待超时在繁忙的服务器上都是正常的，应用程序必须意识到它们可能发生并通过重试来处理它们。您可以通过在事务期间第一次更改数据和提交之间进行尽可能少的工作来减少它们的可能性，因此将锁保持在最短的时间内，并且行的数量最少。有时，在不同交易之间分配工作可能是实用且有用的。</p>
<p>当由于死锁或锁定等待超时而导致事务回滚时，它将取消事务中语句的影响。但是，如果start-transaction语句为 <a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>START TRANSACTION</code></a>或 <a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>BEGIN</code></a> 语句，则回滚不会取消该语句。进一步的SQL语句成为交易的一部分，直到发生<a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a>， <a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>ROLLBACK</code></a>或某些SQL语句导致隐式提交。</p>
</li>
<li><p>如果未<code>IGNORE</code>在语句中指定选项，则重复键错误会回滚SQL 语句。</p>
</li>
<li><p>一个<code>row too long error</code>回滚SQL语句。</p>
</li>
<li><p>其他错误大多数由MySQL代码层（在<code>InnoDB</code>存储引擎级别之上）检测到，并且它们回滚相应的SQL语句。在单个SQL语句的回滚中不会释放锁。</p>
</li>
</ul>
<p>在隐式回滚期间以及在执行显式 <a href="https://dev.mysql.com/doc/refman/5.6/en/commit.html" target="_blank" rel="noopener"><code>ROLLBACK</code></a>SQL语句期间，将在相关连接的 列中<a href="https://dev.mysql.com/doc/refman/5.6/en/show-processlist.html" target="_blank" rel="noopener"><code>SHOW PROCESSLIST</code></a> 显示。 <code>Rolling back``State</code></p>
<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>




      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/message-queue/kafka/2-kafka-concept-and-role/" rel="next" title="2、kafka中的概念和角色">
                <i class="fa fa-chevron-left"></i> 2、kafka中的概念和角色
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/message-queue/kafka/3-kafka-design-principle/" rel="prev" title="3、kafka设计原理">
                3、kafka设计原理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80NjI1OC8yMjc2OQ=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Focus-1</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">236</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">59</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">100</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://gitee.com/carloz" title="repository - https://gitee.com/carloz" target="_blank">repository - https://gitee.com/carloz</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#目录"><span class="nav-text">目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-1-InnoDB简介"><span class="nav-text">14.1 InnoDB简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB的主要优势"><span class="nav-text">InnoDB的主要优势</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-2-InnoDB和ACID模型"><span class="nav-text">14.2 InnoDB和ACID模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原子性"><span class="nav-text">原子性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一致性"><span class="nav-text">一致性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#隔离"><span class="nav-text">隔离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#耐用性"><span class="nav-text">耐用性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-3-InnoDB-MVCC"><span class="nav-text">14.3 InnoDB MVCC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多版本索引和二级索引"><span class="nav-text">多版本索引和二级索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-4-InnoDB架构"><span class="nav-text">14.4 InnoDB架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-5-InnoDB内存结构"><span class="nav-text">14.5 InnoDB内存结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#14-5-1-Buffer-Pool"><span class="nav-text">14.5.1 Buffer Pool</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#缓冲池LRU算法"><span class="nav-text">缓冲池LRU算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缓冲池配置"><span class="nav-text">缓冲池配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用InnoDB标准监视器监视缓冲池"><span class="nav-text">使用InnoDB标准监视器监视缓冲池</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-5-2-Change-Buffer"><span class="nav-text">14.5.2 Change Buffer</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#配置Change-Buffer"><span class="nav-text">配置Change Buffer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#配置Change-Buffer最大大小"><span class="nav-text">配置Change Buffer最大大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#监视Change-Buffer"><span class="nav-text">监视Change Buffer</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-5-3自适应哈希索引"><span class="nav-text">14.5.3自适应哈希索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-5-4-Log-Buffer"><span class="nav-text">14.5.4 Log Buffer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-6-InnoDB磁盘结构"><span class="nav-text">14.6 InnoDB磁盘结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#14-6-1-Tables"><span class="nav-text">14.6.1 Tables</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#14-6-1-1创建InnoDB表"><span class="nav-text">14.6.1.1创建InnoDB表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#InnoDB表和-frm文件"><span class="nav-text">InnoDB表和.frm文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#InnoDB表和行格式"><span class="nav-text">InnoDB表和行格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#InnoDB表和主键"><span class="nav-text">InnoDB表和主键</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查看InnoDB表属性"><span class="nav-text">查看InnoDB表属性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-6-1-5将表从MyISAM转换为InnoDB"><span class="nav-text">14.6.1.5将表从MyISAM转换为InnoDB</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#调整MyISAM和InnoDB的内存使用量"><span class="nav-text">调整MyISAM和InnoDB的内存使用量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#处理太长或太短的交易"><span class="nav-text">处理太长或太短的交易</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#处理死锁"><span class="nav-text">处理死锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#规划存储布局"><span class="nav-text">规划存储布局</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#转换现有表"><span class="nav-text">转换现有表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#克隆表的结构"><span class="nav-text">克隆表的结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#传输现有数据"><span class="nav-text">传输现有数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#储存要求"><span class="nav-text">储存要求</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为每个表定义一个主键"><span class="nav-text">为每个表定义一个主键</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#应用程序性能注意事项"><span class="nav-text">应用程序性能注意事项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#了解与InnoDB表关联的文件"><span class="nav-text">了解与InnoDB表关联的文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-6-2-Index"><span class="nav-text">14.6.2 Index</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#14-6-2-1聚集索引和二级索引"><span class="nav-text">14.6.2.1聚集索引和二级索引</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#聚集索引如何加快查询"><span class="nav-text">聚集索引如何加快查询</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二级索引如何与聚簇索引相关"><span class="nav-text">二级索引如何与聚簇索引相关</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-6-2-2-InnoDB索引的物理结构"><span class="nav-text">14.6.2.2 InnoDB索引的物理结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-6-2-3-InnoDB全文索引"><span class="nav-text">14.6.2.3 InnoDB全文索引</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#InnoDB全文索引设计"><span class="nav-text">InnoDB全文索引设计</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#InnoDB全文索引表"><span class="nav-text">InnoDB全文索引表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#InnoDB全文索引缓存"><span class="nav-text">InnoDB全文索引缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#InnoDB全文索引文档ID和FTS-DOC-ID列"><span class="nav-text">InnoDB全文索引文档ID和FTS_DOC_ID列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#InnoDB全文索引删除处理"><span class="nav-text">InnoDB全文索引删除处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#InnoDB全文索引事务处理"><span class="nav-text">InnoDB全文索引事务处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#监控InnoDB全文索引"><span class="nav-text">监控InnoDB全文索引</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-6-3-Tablespace"><span class="nav-text">14.6.3 Tablespace</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#14-6-3-1系统表空间"><span class="nav-text">14.6.3.1系统表空间</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#调整系统表空间的大小"><span class="nav-text">调整系统表空间的大小</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#增加系统表空间的大小"><span class="nav-text">增加系统表空间的大小</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#减少InnoDB系统表空间的大小"><span class="nav-text">减少InnoDB系统表空间的大小</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#对系统表空间使用原始磁盘分区"><span class="nav-text">对系统表空间使用原始磁盘分区</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#在Linux和Unix系统上分配原始磁盘分区"><span class="nav-text">在Linux和Unix系统上分配原始磁盘分区</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#在Windows上分配原始磁盘分区"><span class="nav-text">在Windows上分配原始磁盘分区</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-6-3-2-File-Per-Table-Tablespaces"><span class="nav-text">14.6.3.2 File-Per-Table-Tablespaces</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#每表文件表空间配置"><span class="nav-text">每表文件表空间配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#每表文件表空间数据文件"><span class="nav-text">每表文件表空间数据文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#每表文件表空间的优势"><span class="nav-text">每表文件表空间的优势</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#每表文件表空间的缺点"><span class="nav-text">每表文件表空间的缺点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-6-3-3-Undo-Tablespaces"><span class="nav-text">14.6.3.3 Undo Tablespaces</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#配置撤消表空间"><span class="nav-text">配置撤消表空间</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-6-4-InnoDB数据字典"><span class="nav-text">14.6.4 InnoDB数据字典</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-6-5-Doublewrite-Buffer"><span class="nav-text">14.6.5 Doublewrite Buffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-6-6-Redo-Log"><span class="nav-text">14.6.6 Redo Log</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#更改Redo-Log文件的数量或大小"><span class="nav-text">更改Redo Log文件的数量或大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#组提交以Redo-Log刷新"><span class="nav-text">组提交以Redo Log刷新</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-6-7-Undo-Logs"><span class="nav-text">14.6.7 Undo Logs</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-12-InnoDB磁盘I-O和文件空间管理"><span class="nav-text">14.12 InnoDB磁盘I / O和文件空间管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#14-12-1-InnoDB磁盘I-O"><span class="nav-text">14.12.1 InnoDB磁盘I / O</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#预读"><span class="nav-text">预读</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Doublewrite-Buffer"><span class="nav-text">Doublewrite Buffer</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-12-2文件空间管理"><span class="nav-text">14.12.2文件空间管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#页面，范围，段和表空间"><span class="nav-text">页面，范围，段和表空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#页面如何与表格行相关"><span class="nav-text">页面如何与表格行相关</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-12-3-InnoDB检查点"><span class="nav-text">14.12.3 InnoDB检查点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#检查点处理的工作原理"><span class="nav-text">检查点处理的工作原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-12-4对表进行碎片整理"><span class="nav-text">14.12.4对表进行碎片整理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-12-5使用TRUNCATE-TABLE回收磁盘空间"><span class="nav-text">14.12.5使用TRUNCATE TABLE回收磁盘空间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-17-InnoDB监视器"><span class="nav-text">14.17 InnoDB监视器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#14-17-1-InnoDB监视器类型"><span class="nav-text">14.17.1 InnoDB监视器类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-17-2启用InnoDB监视器"><span class="nav-text">14.17.2启用InnoDB监视器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#启用标准InnoDB监视器"><span class="nav-text">启用标准InnoDB监视器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#启用InnoDB锁定监视器"><span class="nav-text">启用InnoDB锁定监视器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获得标准的InnoDB监视器按需输出"><span class="nav-text">获得标准的InnoDB监视器按需输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#将标准InnoDB监视器输出定向到状态文件"><span class="nav-text">将标准InnoDB监视器输出定向到状态文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#启用InnoDB表空间监视器"><span class="nav-text">启用InnoDB表空间监视器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#启用InnoDB表监视器"><span class="nav-text">启用InnoDB表监视器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-17-3-InnoDB标准监视器和锁定监视器输出"><span class="nav-text">14.17.3 InnoDB标准监视器和锁定监视器输出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#标准监视器输出部分"><span class="nav-text">标准监视器输出部分</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-17-4-InnoDB表空间监视器输出"><span class="nav-text">14.17.4 InnoDB表空间监视器输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-17-5-InnoDB表监视器输出"><span class="nav-text">14.17.5 InnoDB表监视器输出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-21-InnoDB故障排除"><span class="nav-text">14.21 InnoDB故障排除</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#14-21-1对InnoDB-I-O问题进行故障排除"><span class="nav-text">14.21.1对InnoDB I / O问题进行故障排除</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化问题"><span class="nav-text">初始化问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#运行时问题"><span class="nav-text">运行时问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-21-2强制InnoDB恢复"><span class="nav-text">14.21.2强制InnoDB恢复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-21-3对InnoDB数据字典操作进行故障排除"><span class="nav-text">14.21.3对InnoDB数据字典操作进行故障排除</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#由于孤立表导致CREATE-TABLE失败"><span class="nav-text">由于孤立表导致CREATE TABLE失败</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#无法打开文件错误"><span class="nav-text">无法打开文件错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#孤立的中间表"><span class="nav-text">孤立的中间表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#孤儿临时表"><span class="nav-text">孤儿临时表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#表空间不存在"><span class="nav-text">表空间不存在</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#恢复每表孤立文件ibd文件"><span class="nav-text">恢复每表孤立文件ibd文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-21-4-InnoDB错误处理"><span class="nav-text">14.21.4 InnoDB错误处理</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Focus-1</span>

  
</div>








  <div class="footer-custom">Hosted by <a target="_blank" href="https://gitee.com/carloz">Gitee Repo</a></div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
